<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DSA Mastery — Interview Prep Portal</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=DM+Serif+Display&family=IBM+Plex+Mono:wght@400;500;600&family=DM+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
*{box-sizing:border-box;margin:0;padding:0}
:root{
--bg:#0e0f11;--bg2:#151619;--bg3:#1b1c21;--bg4:#22232a;
--text:#d4d0c8;--text2:#9e9a90;--text3:#6b6760;
--accent:#c9944a;--accent2:#e5b06e;--accent-bg:rgba(201,148,74,0.08);--accent-border:rgba(201,148,74,0.2);
--green:#5cb870;--green-bg:rgba(92,184,112,0.1);
--blue:#5b9fd4;--blue-bg:rgba(91,159,212,0.1);
--purple:#9b7ad4;--purple-bg:rgba(155,122,212,0.1);
--red:#d45b5b;--red-bg:rgba(212,91,91,0.08);
--orange:#d49a3e;--orange-bg:rgba(212,154,62,0.08);
--cyan:#4ac9b0;--cyan-bg:rgba(74,201,176,0.08);
--radius:10px;--radius-sm:6px;
--font-display:'DM Serif Display',Georgia,serif;
--font-body:'DM Sans',-apple-system,sans-serif;
--font-mono:'IBM Plex Mono','Fira Code',monospace;
--shadow:0 2px 20px rgba(0,0,0,0.3);
}
html{scroll-behavior:smooth}
body{background:var(--bg);color:var(--text);font-family:var(--font-body);line-height:1.6;min-height:100vh}
::-webkit-scrollbar{width:6px}::-webkit-scrollbar-track{background:transparent}::-webkit-scrollbar-thumb{background:rgba(201,148,74,0.15);border-radius:3px}
::selection{background:rgba(201,148,74,0.25);color:#fff}
.container{max-width:1100px;margin:0 auto;padding:0 24px}

/* Hero */
.hero{text-align:center;padding:48px 0 32px;position:relative}
.hero::after{content:'';position:absolute;bottom:0;left:50%;transform:translateX(-50%);width:120px;height:1px;background:linear-gradient(90deg,transparent,var(--accent-border),transparent)}
.hero-label{font:600 11px/1 var(--font-mono);letter-spacing:4px;text-transform:uppercase;color:var(--accent);margin-bottom:12px}
.hero h1{font:normal 38px/1.1 var(--font-display);background:linear-gradient(135deg,var(--text) 30%,var(--accent));-webkit-background-clip:text;-webkit-text-fill-color:transparent;margin-bottom:6px}
.hero p{color:var(--text3);font-size:14px;font-style:italic}

/* Stats */
.stats-bar{display:flex;justify-content:center;gap:28px;padding:20px 0 24px;flex-wrap:wrap}
.stat{text-align:center}.stat-num{font:600 22px/1 var(--font-display);color:var(--accent2)}.stat-label{font:500 10px/1 var(--font-mono);color:var(--text3);margin-top:4px;letter-spacing:1px;text-transform:uppercase}

/* Quick action buttons */
.quick-actions{display:flex;gap:8px;justify-content:center;margin-bottom:24px;flex-wrap:wrap}
.qa-btn{display:flex;align-items:center;gap:6px;padding:8px 16px;border:1px solid rgba(255,255,255,0.06);background:var(--bg2);color:var(--text2);font:500 12px/1 var(--font-body);cursor:pointer;border-radius:20px;transition:all .2s}
.qa-btn:hover{border-color:var(--accent-border);color:var(--accent);background:var(--accent-bg)}
.qa-btn .qa-icon{font-size:14px}
.qa-btn.active-timer{border-color:var(--red);color:var(--red);background:var(--red-bg);animation:pulse 1.5s infinite}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:.7}}

/* Nav */
.nav{display:flex;gap:2px;margin-bottom:24px;overflow-x:auto;padding-bottom:2px;border-bottom:1px solid rgba(255,255,255,0.04);position:sticky;top:0;background:var(--bg);z-index:100;padding-top:8px}
.nav-btn{padding:10px 16px;border:none;background:transparent;color:var(--text3);font:600 13px/1 var(--font-body);cursor:pointer;white-space:nowrap;border-bottom:2px solid transparent;transition:all .2s;border-radius:var(--radius-sm) var(--radius-sm) 0 0}
.nav-btn:hover{color:var(--text2);background:rgba(255,255,255,0.02)}
.nav-btn.active{color:var(--accent);border-bottom-color:var(--accent);background:var(--accent-bg)}

/* Topic grid */
.topic-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(320px,1fr));gap:12px;margin-bottom:28px}
.topic-card{background:var(--bg2);border:1px solid rgba(255,255,255,0.04);border-radius:var(--radius);padding:20px;cursor:pointer;transition:all .25s;position:relative;overflow:hidden}
.topic-card:hover{border-color:var(--accent-border);background:var(--bg3);transform:translateY(-2px);box-shadow:var(--shadow)}
.topic-card::before{content:'';position:absolute;top:0;left:0;right:0;height:2px;background:linear-gradient(90deg,var(--accent),transparent);opacity:0;transition:opacity .25s}
.topic-card:hover::before{opacity:1}
.tc-top{display:flex;align-items:center;gap:12px;margin-bottom:8px}
.topic-icon{font-size:24px}.topic-name{font:normal 18px/1.2 var(--font-display);color:var(--text)}
.topic-meta{font:500 11px/1 var(--font-mono);color:var(--text3);margin-bottom:8px}
.topic-patterns{display:flex;flex-wrap:wrap;gap:4px;margin-bottom:10px}
.pattern-tag{font:500 10px/1 var(--font-mono);padding:3px 8px;border-radius:20px;background:var(--accent-bg);border:1px solid rgba(201,148,74,0.1);color:var(--accent)}
.topic-progress{height:3px;background:rgba(255,255,255,0.04);border-radius:2px;overflow:hidden}
.topic-progress-bar{height:100%;background:var(--green);border-radius:2px;transition:width .5s}

/* Sub nav */
.sub-nav{display:flex;gap:8px;margin-bottom:20px;flex-wrap:wrap}
.sub-btn{padding:7px 16px;border:1px solid rgba(255,255,255,0.06);background:var(--bg2);color:var(--text2);font:500 12px/1 var(--font-body);cursor:pointer;border-radius:20px;transition:all .2s}
.sub-btn:hover{border-color:var(--accent-border);color:var(--text)}
.sub-btn.active{background:var(--accent-bg);border-color:var(--accent-border);color:var(--accent)}

/* Section header */
.section-header{margin-bottom:20px}.section-header h2{font:normal 28px/1.2 var(--font-display);color:var(--text);margin-bottom:4px}.section-header p{color:var(--text3);font-size:13px}

/* Back button */
.back-btn{display:inline-flex;align-items:center;gap:6px;padding:6px 14px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:var(--text3);font:500 12px/1 var(--font-body);cursor:pointer;border-radius:20px;transition:all .2s;margin-bottom:14px}
.back-btn:hover{border-color:var(--accent-border);color:var(--accent)}

/* Search */
.search-wrap{margin-bottom:20px;position:relative}
.search-input{width:100%;padding:11px 16px 11px 38px;background:var(--bg2);border:1px solid rgba(255,255,255,0.06);border-radius:var(--radius);color:var(--text);font:400 13px/1 var(--font-body);outline:none;transition:border-color .2s}
.search-input:focus{border-color:var(--accent-border)}
.search-input::placeholder{color:var(--text3)}
.search-icon{position:absolute;left:12px;top:50%;transform:translateY(-50%);color:var(--text3);font-size:14px}
.search-count{position:absolute;right:12px;top:50%;transform:translateY(-50%);font:500 10px/1 var(--font-mono);color:var(--text3)}

/* Filter bar */
.filter-bar{display:flex;gap:6px;margin-bottom:14px;flex-wrap:wrap;align-items:center}
.filter-label{font:500 10px/1 var(--font-mono);color:var(--text3);margin-right:4px;text-transform:uppercase;letter-spacing:1px}
.filter-btn{padding:4px 10px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:var(--text3);font:500 11px/1 var(--font-body);cursor:pointer;border-radius:20px;transition:all .2s}
.filter-btn:hover{border-color:rgba(255,255,255,0.12);color:var(--text2)}
.filter-btn.active{background:var(--accent-bg);border-color:var(--accent-border);color:var(--accent)}

/* Tier section */
.tier-section{margin-bottom:20px}
.tier-header{display:flex;align-items:center;gap:10px;padding:12px 0;border-bottom:1px solid rgba(255,255,255,0.04);margin-bottom:8px;cursor:pointer}
.tier-dot{width:10px;height:10px;border-radius:50%;flex-shrink:0}
.tier-name{font:600 14px/1 var(--font-body);color:var(--text)}
.tier-count{font:500 10px/1 var(--font-mono);color:var(--text3);margin-left:auto}
.tier-desc{font-size:12px;color:var(--text3);margin-bottom:10px;line-height:1.5}

/* Problem row */
.problem-row{display:flex;align-items:center;gap:10px;padding:9px 12px;border-radius:var(--radius-sm);transition:background .15s;cursor:pointer;margin-bottom:1px;position:relative}
.problem-row:hover{background:rgba(255,255,255,0.025)}
.problem-row.completed{opacity:0.45}
.problem-row.completed .problem-title{text-decoration:line-through}

.problem-check{width:17px;height:17px;border:1.5px solid rgba(255,255,255,0.12);border-radius:4px;cursor:pointer;display:flex;align-items:center;justify-content:center;transition:all .2s;flex-shrink:0;background:transparent}
.problem-check:hover{border-color:var(--green)}
.problem-check.checked{background:var(--green);border-color:var(--green)}
.problem-check.checked::after{content:'✓';color:#fff;font-size:10px;font-weight:700}

.problem-num{font:500 10px/1 var(--font-mono);color:var(--text3);min-width:30px}
.problem-title{font:500 13px/1.3 var(--font-body);color:var(--text);flex:1}
.problem-blind75{font:600 8px/1 var(--font-mono);padding:2px 5px;border-radius:3px;background:var(--cyan-bg);border:1px solid rgba(74,201,176,0.2);color:var(--cyan);margin-left:4px;flex-shrink:0}
.problem-diff{font:600 9px/1 var(--font-mono);padding:2px 7px;border-radius:20px;text-transform:uppercase;letter-spacing:0.3px;flex-shrink:0}
.diff-Easy{background:var(--green-bg);color:var(--green)}.diff-Medium{background:var(--orange-bg);color:var(--orange)}.diff-Hard{background:var(--red-bg);color:var(--red)}
.problem-patterns{display:flex;gap:3px;flex-wrap:wrap}
.problem-pattern{font:400 9px/1 var(--font-mono);padding:2px 6px;border-radius:10px;background:var(--blue-bg);color:var(--blue)}

/* Problem note / hints */
.problem-note{padding:10px 14px 10px 42px;font:400 12px/1.6 var(--font-body);color:var(--text2);background:rgba(255,255,255,0.015);border-left:2px solid var(--accent-border);margin:2px 0 6px;border-radius:0 var(--radius-sm) var(--radius-sm) 0}
.hint-steps{padding:8px 14px 8px 42px;margin:2px 0 6px}
.hint-step{display:flex;gap:8px;padding:4px 0;font-size:12px;color:var(--text3);cursor:pointer;transition:color .2s;user-select:none}
.hint-step.revealed{color:var(--text2)}
.hint-step.revealed .hint-num{color:var(--accent)}
.hint-step.hidden{filter:blur(4px);pointer-events:none}
.hint-num{font:600 10px/1 var(--font-mono);color:var(--text3);min-width:18px}
.reveal-btn{font:500 11px/1 var(--font-mono);color:var(--accent);cursor:pointer;padding:4px 10px;border:1px dashed var(--accent-border);border-radius:var(--radius-sm);background:transparent;transition:all .2s;margin-top:4px;display:inline-block}
.reveal-btn:hover{background:var(--accent-bg)}

/* Timer */
.timer-bar{position:fixed;top:0;left:0;right:0;height:40px;background:var(--bg2);border-bottom:1px solid rgba(212,91,91,0.2);display:flex;align-items:center;justify-content:center;gap:16px;z-index:200;box-shadow:0 2px 12px rgba(0,0,0,0.3)}
.timer-display{font:600 18px/1 var(--font-mono);color:var(--red);min-width:80px;text-align:center}
.timer-label{font:500 12px/1 var(--font-body);color:var(--text2)}
.timer-btn{padding:4px 12px;border:1px solid rgba(255,255,255,0.08);background:transparent;color:var(--text2);font:500 11px/1 var(--font-body);cursor:pointer;border-radius:var(--radius-sm);transition:all .2s}
.timer-btn:hover{background:rgba(255,255,255,0.05)}
.timer-progress{position:fixed;top:40px;left:0;height:2px;background:var(--red);z-index:200;transition:width 1s linear}

/* Cards */
.card{background:var(--bg2);border:1px solid rgba(255,255,255,0.04);border-radius:var(--radius);margin-bottom:8px;overflow:hidden;transition:border-color .2s}
.card:hover{border-color:rgba(255,255,255,0.08)}
.card-header{padding:14px 18px;display:flex;align-items:center;justify-content:space-between;cursor:pointer;user-select:none}
.card-header h3{font:normal 15px/1.3 var(--font-display);color:var(--text)}
.card-toggle{font-size:11px;color:var(--text3);transition:transform .3s}
.card-toggle.open{transform:rotate(180deg)}
.card-body{padding:0 18px 18px;border-top:1px solid rgba(255,255,255,0.03)}
.card-body p{color:var(--text2);font-size:13px;line-height:1.7;margin-bottom:10px}

/* Code */
.code-block{background:var(--bg);border:1px solid rgba(255,255,255,0.04);border-radius:var(--radius-sm);padding:14px;font:400 12px/1.6 var(--font-mono);color:#a8c4a0;overflow-x:auto;margin:10px 0;white-space:pre;tab-size:4}
.code-block .keyword{color:#c9944a}.code-block .type{color:#5b9fd4}.code-block .string{color:#8ec07c}.code-block .comment{color:#555;font-style:italic}.code-block .number{color:#d3869b}

/* Variant card */
.variant-when{font:500 11px/1.5 var(--font-mono);color:var(--accent);background:var(--accent-bg);padding:5px 10px;border-radius:var(--radius-sm);margin-bottom:10px;display:inline-block}
.variant-problem{display:flex;gap:8px;padding:5px 0;font-size:12px;color:var(--text2)}
.variant-problem b{color:var(--text);font-weight:500}
.variant-hint{color:var(--text3);font-size:11px}

/* Decision tree */
.dt-node{background:var(--bg2);border:1px solid rgba(255,255,255,0.04);border-radius:var(--radius);padding:16px;margin-bottom:10px;cursor:pointer;transition:all .2s}
.dt-node:hover{border-color:var(--accent-border);background:var(--bg3)}
.dt-question{font:600 14px/1.4 var(--font-body);color:var(--text);margin-bottom:8px}
.dt-options{display:flex;flex-direction:column;gap:6px}
.dt-option{display:flex;align-items:center;gap:8px;padding:8px 12px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.04);border-radius:var(--radius-sm);cursor:pointer;transition:all .2s;font-size:13px;color:var(--text2)}
.dt-option:hover{border-color:var(--accent-border);background:var(--accent-bg);color:var(--accent)}
.dt-arrow{color:var(--accent);font-size:14px}
.dt-result{background:var(--accent-bg);border:1px solid var(--accent-border);border-radius:var(--radius);padding:16px;margin-bottom:10px}
.dt-result h4{font:normal 16px/1.3 var(--font-display);color:var(--accent);margin-bottom:6px}
.dt-result p{font-size:13px;color:var(--text2);line-height:1.6}

/* Complexity badge */
.complexity-badge{display:inline-flex;gap:8px;flex-wrap:wrap;margin-top:6px}
.cb{font:500 10px/1 var(--font-mono);padding:2px 8px;border-radius:20px}
.cb-fast{background:var(--green-bg);color:var(--green)}
.cb-med{background:var(--blue-bg);color:var(--blue)}
.cb-slow{background:var(--orange-bg);color:var(--orange)}

/* Overview table */
.overview-table{width:100%;border-collapse:separate;border-spacing:0;font-size:11px;margin:12px 0}
.overview-table th{text-align:left;padding:7px 10px;font:600 9px/1 var(--font-mono);color:var(--accent);text-transform:uppercase;letter-spacing:1px;border-bottom:1px solid rgba(255,255,255,0.06)}
.overview-table td{padding:7px 10px;border-bottom:1px solid rgba(255,255,255,0.02);font-family:var(--font-mono)}
.overview-table tr:hover td{background:rgba(255,255,255,0.015)}
.c-fast{color:var(--green)}.c-med{color:var(--blue)}.c-slow{color:var(--orange)}

/* Keyboard shortcut hint */
.kbd{font:500 10px/1 var(--font-mono);padding:1px 5px;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.08);border-radius:3px;color:var(--text3);margin-left:6px}

/* Collapsible */
.collapsible-trigger{display:flex;align-items:center;gap:8px;cursor:pointer;padding:6px 0;font:500 11px/1 var(--font-mono);color:var(--accent);text-transform:uppercase;letter-spacing:1px;user-select:none}
.collapsible-trigger:hover{color:var(--accent2)}

/* Toast notification */
.toast{position:fixed;bottom:24px;left:50%;transform:translateX(-50%);padding:10px 20px;background:var(--bg4);border:1px solid rgba(255,255,255,0.08);border-radius:var(--radius);font:500 13px/1 var(--font-body);color:var(--text);box-shadow:var(--shadow);z-index:300;opacity:0;transition:opacity .3s}
.toast.show{opacity:1}

/* Reset/utility */
.reset-btn{padding:4px 10px;border:1px solid rgba(212,91,91,0.2);background:rgba(212,91,91,0.05);color:var(--red);font:500 10px/1 var(--font-body);cursor:pointer;border-radius:20px;transition:all .2s}
.reset-btn:hover{background:rgba(212,91,91,0.12)}
.empty{text-align:center;padding:32px;color:var(--text3);font-style:italic}

/* Responsive */
@media(max-width:700px){
  .hero h1{font-size:28px}.topic-grid{grid-template-columns:1fr}.stats-bar{gap:16px}
  .nav-btn{padding:8px 10px;font-size:11px}.problem-patterns{display:none}.container{padding:0 12px}
  .timer-bar{height:36px;gap:10px}.timer-display{font-size:15px}
}
@keyframes fadeIn{from{opacity:0;transform:translateY(8px)}to{opacity:1;transform:translateY(0)}}
.fade-in{animation:fadeIn .3s ease}
</style>
</head>
<body>
<div id="app"></div>
<div id="toast" class="toast"></div>
<script>
// ====== DATA ======
const PROBLEMS = {"arrays-strings":[{"name":"Tier 1 — Must Know","color":"#e85d4a","description":"Solve these first. They cover the foundational patterns and appear constantly in interviews. If you can solve all of these cleanly, you're in strong shape.","problems":[{"id":1,"title":"Two Sum","num":1,"difficulty":"Easy","patterns":["Hash Map"],"url":"https://leetcode.com/problems/two-sum/","note":"THE classic. HashMap stores complement. Foundation for all pair-sum problems."},{"id":2,"title":"Best Time to Buy and Sell Stock","num":121,"difficulty":"Easy","patterns":["Sliding Window","Greedy"],"url":"https://leetcode.com/problems/best-time-to-buy-and-sell-stock/","note":"Track min price so far, update max profit. One-pass O(n)."},{"id":3,"title":"Valid Palindrome","num":125,"difficulty":"Easy","patterns":["Two Pointers"],"url":"https://leetcode.com/problems/valid-palindrome/","note":"Two pointers from ends. Character.isLetterOrDigit() + Character.toLowerCase()."},{"id":4,"title":"Valid Anagram","num":242,"difficulty":"Easy","patterns":["Hash Map","Frequency"],"url":"https://leetcode.com/problems/valid-anagram/","note":"int[26] frequency count. Increment for s, decrement for t, check all zero."},{"id":5,"title":"Contains Duplicate","num":217,"difficulty":"Easy","patterns":["Hash Set"],"url":"https://leetcode.com/problems/contains-duplicate/","note":"HashSet. Add returns false if element exists. One-liner possible."},{"id":6,"title":"Merge Sorted Array","num":88,"difficulty":"Easy","patterns":["Two Pointers","Merge"],"url":"https://leetcode.com/problems/merge-sorted-array/","note":"Merge from the END. Three pointers: p1 at m-1, p2 at n-1, write at m+n-1."},{"id":7,"title":"Move Zeroes","num":283,"difficulty":"Easy","patterns":["Two Pointers"],"url":"https://leetcode.com/problems/move-zeroes/","note":"Slow/fast pointers. Swap non-zero to slow position. Maintains relative order."},{"id":8,"title":"3Sum","num":15,"difficulty":"Medium","patterns":["Two Pointers","Sort"],"url":"https://leetcode.com/problems/3sum/","note":"Sort + fix one, two-pointer on rest. Skip duplicates at all three levels."},{"id":9,"title":"Container With Most Water","num":11,"difficulty":"Medium","patterns":["Two Pointers"],"url":"https://leetcode.com/problems/container-with-most-water/","note":"Opposite-end pointers. Move the shorter side inward. Greedy proof."},{"id":10,"title":"Longest Substring Without Repeating Characters","num":3,"difficulty":"Medium","patterns":["Sliding Window","Hash Map"],"url":"https://leetcode.com/problems/longest-substring-without-repeating-characters/","note":"Variable window. HashMap<Character, lastIndex> or HashSet. Shrink on duplicate."},{"id":11,"title":"Product of Array Except Self","num":238,"difficulty":"Medium","patterns":["Prefix Sum"],"url":"https://leetcode.com/problems/product-of-array-except-self/","note":"Left prefix product × right suffix product. O(1) extra space with two passes."},{"id":12,"title":"Group Anagrams","num":49,"difficulty":"Medium","patterns":["Hash Map","Sort"],"url":"https://leetcode.com/problems/group-anagrams/","note":"Sorted string as key, or int[26] → String as key. HashMap<String, List<String>>."},{"id":13,"title":"Subarray Sum Equals K","num":560,"difficulty":"Medium","patterns":["Prefix Sum","Hash Map"],"url":"https://leetcode.com/problems/subarray-sum-equals-k/","note":"Prefix sum + HashMap. The most important prefix sum pattern. map.put(0, 1) init."}]},{"name":"Tier 2 — Core Practice","color":"#d49a3e","description":"These build on Tier 1 patterns with slightly harder twists. Solidifies your understanding and covers common interview variations.","problems":[{"id":14,"title":"Two Sum II (Sorted)","num":167,"difficulty":"Easy","patterns":["Two Pointers"],"url":"https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/","note":"Opposite-end two pointers on sorted input. Pure two-pointer, no hash map needed."},{"id":15,"title":"Remove Duplicates from Sorted Array","num":26,"difficulty":"Easy","patterns":["Two Pointers"],"url":"https://leetcode.com/problems/remove-duplicates-from-sorted-array/","note":"Slow/fast same-direction. If arr[fast] != arr[slow-1], copy forward."},{"id":16,"title":"Maximum Subarray (Kadane's)","num":53,"difficulty":"Medium","patterns":["DP","Greedy"],"url":"https://leetcode.com/problems/maximum-subarray/","note":"Kadane's: maxEndingHere = Math.max(num, maxEndingHere + num). Reset or extend."},{"id":17,"title":"Minimum Size Subarray Sum","num":209,"difficulty":"Medium","patterns":["Sliding Window"],"url":"https://leetcode.com/problems/minimum-size-subarray-sum/","note":"Variable window. Expand until sum >= target, shrink to minimize length."},{"id":18,"title":"Find All Anagrams in a String","num":438,"difficulty":"Medium","patterns":["Sliding Window","Frequency"],"url":"https://leetcode.com/problems/find-all-anagrams-in-a-string/","note":"Fixed window of p.length(). int[26] + match count. Classic frequency window."},{"id":19,"title":"Longest Repeating Character Replacement","num":424,"difficulty":"Medium","patterns":["Sliding Window"],"url":"https://leetcode.com/problems/longest-repeating-character-replacement/","note":"Window valid if (windowLen - maxFreq) <= k. Track maxFreq without decrementing."},{"id":20,"title":"Sort Colors","num":75,"difficulty":"Medium","patterns":["Two Pointers"],"url":"https://leetcode.com/problems/sort-colors/","note":"Dutch National Flag. Three pointers: low, mid, high. One-pass O(n) swap logic."},{"id":21,"title":"String to Integer (atoi)","num":8,"difficulty":"Medium","patterns":["String Parsing"],"url":"https://leetcode.com/problems/string-to-integer-atoi/","note":"Handle: whitespace, sign, digits, overflow. Check before multiply: result > MAX/10."},{"id":22,"title":"Rotate Array","num":189,"difficulty":"Medium","patterns":["Array Manipulation"],"url":"https://leetcode.com/problems/rotate-array/","note":"Reverse all, reverse first k, reverse rest. O(1) space. k %= n first."},{"id":23,"title":"Longest Consecutive Sequence","num":128,"difficulty":"Medium","patterns":["Hash Set"],"url":"https://leetcode.com/problems/longest-consecutive-sequence/","note":"HashSet. Only start counting from sequence start (num-1 not in set). O(n)."},{"id":24,"title":"Range Sum Query – Immutable","num":303,"difficulty":"Easy","patterns":["Prefix Sum"],"url":"https://leetcode.com/problems/range-sum-query-immutable/","note":"Pure prefix sum. Build once, answer queries in O(1). The textbook example."},{"id":25,"title":"Contiguous Array","num":525,"difficulty":"Medium","patterns":["Prefix Sum","Hash Map"],"url":"https://leetcode.com/problems/contiguous-array/","note":"Replace 0 → -1. Prefix sum + HashMap for first occurrence. Longest subarray with sum 0."},{"id":26,"title":"Is Subsequence","num":392,"difficulty":"Easy","patterns":["Two Pointers"],"url":"https://leetcode.com/problems/is-subsequence/","note":"Two pointers on s and t. If match, advance s. Always advance t. Check s pointer reached end."}]},{"name":"Tier 3 — Interview Ready","color":"#5a9bd5","description":"Harder problems that frequently appear at top tech companies. These require combining multiple patterns or handling tricky edge cases.","problems":[{"id":27,"title":"Minimum Window Substring","num":76,"difficulty":"Hard","patterns":["Sliding Window","Hash Map"],"url":"https://leetcode.com/problems/minimum-window-substring/","note":"Variable window. Expand to valid, shrink to optimize. Track 'formed' vs 'required' count."},{"id":28,"title":"Trapping Rain Water","num":42,"difficulty":"Hard","patterns":["Two Pointers","Stack"],"url":"https://leetcode.com/problems/trapping-rain-water/","note":"Two-pointer: water at i = min(leftMax, rightMax) - height[i]. Move shorter side."},{"id":29,"title":"Sliding Window Maximum","num":239,"difficulty":"Hard","patterns":["Sliding Window","Monotonic Deque"],"url":"https://leetcode.com/problems/sliding-window-maximum/","note":"Monotonic decreasing ArrayDeque<Integer> of indices. Remove out-of-window and smaller elements."},{"id":30,"title":"4Sum","num":18,"difficulty":"Medium","patterns":["Two Pointers","Sort"],"url":"https://leetcode.com/problems/4sum/","note":"Extension of 3Sum. Fix two elements, two-pointer on rest. Handle long overflow."},{"id":31,"title":"Longest Substring with At Most K Distinct Chars","num":340,"difficulty":"Medium","patterns":["Sliding Window","Hash Map"],"url":"https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/","note":"Variable window. HashMap<Character, Integer> for freq. Shrink when map.size() > k."},{"id":32,"title":"Subarrays with K Different Integers","num":992,"difficulty":"Hard","patterns":["Sliding Window"],"url":"https://leetcode.com/problems/subarrays-with-k-different-integers/","note":"exactly(K) = atMost(K) - atMost(K-1). The key decomposition trick."},{"id":33,"title":"Minimum Operations to Reduce X to Zero","num":1658,"difficulty":"Medium","patterns":["Sliding Window","Prefix Sum"],"url":"https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/","note":"Flip it: find longest subarray with sum = totalSum - x. Variable sliding window."},{"id":34,"title":"Range Sum Query 2D – Immutable","num":304,"difficulty":"Medium","patterns":["Prefix Sum","2D"],"url":"https://leetcode.com/problems/range-sum-query-2d-immutable/","note":"2D prefix sum. Build with inclusion-exclusion. Query with inclusion-exclusion."},{"id":35,"title":"Corporate Flight Bookings","num":1109,"difficulty":"Medium","patterns":["Difference Array"],"url":"https://leetcode.com/problems/corporate-flight-bookings/","note":"Difference array. diff[first-1] += seats, diff[last] -= seats. Prefix sum to reconstruct."},{"id":36,"title":"Car Pooling","num":1094,"difficulty":"Medium","patterns":["Difference Array"],"url":"https://leetcode.com/problems/car-pooling/","note":"Difference array over locations. Add passengers at from, remove at to. Check capacity."},{"id":37,"title":"Permutation in String","num":567,"difficulty":"Medium","patterns":["Sliding Window","Frequency"],"url":"https://leetcode.com/problems/permutation-in-string/","note":"Fixed window of s1.length(). Same as find-all-anagrams but return boolean."},{"id":38,"title":"Continuous Subarray Sum","num":523,"difficulty":"Medium","patterns":["Prefix Sum","Hash Map"],"url":"https://leetcode.com/problems/continuous-subarray-sum/","note":"Store prefix % k → first index. If same remainder seen and length ≥ 2, return true."},{"id":39,"title":"Subarray Sums Divisible by K","num":974,"difficulty":"Medium","patterns":["Prefix Sum","Hash Map"],"url":"https://leetcode.com/problems/subarray-sums-divisible-by-k/","note":"Count prefix sums with same (prefix % k). Use ((prefix % k) + k) % k for negatives."}]},{"name":"Tier 4 — Advanced / Edge Cases","color":"#8a6bbf","description":"Challenging problems for those targeting FAANG-level preparation. These test deep understanding and creative pattern application.","problems":[{"id":40,"title":"Substring with Concatenation of All Words","num":30,"difficulty":"Hard","patterns":["Sliding Window","Hash Map"],"url":"https://leetcode.com/problems/substring-with-concatenation-of-all-words/","note":"Fixed window of total word length. Slide by word size. Multiple starting offsets."},{"id":41,"title":"Longest Valid Parentheses","num":32,"difficulty":"Hard","patterns":["Stack","DP"],"url":"https://leetcode.com/problems/longest-valid-parentheses/","note":"Stack stores indices. Or DP: dp[i] = length of valid substring ending at i."},{"id":42,"title":"First Missing Positive","num":41,"difficulty":"Hard","patterns":["Cyclic Sort"],"url":"https://leetcode.com/problems/first-missing-positive/","note":"Place each num at index num-1. Then scan for first mismatch. O(n) time, O(1) space."},{"id":43,"title":"Minimum Number of K Consecutive Bit Flips","num":995,"difficulty":"Hard","patterns":["Sliding Window","Greedy"],"url":"https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/","note":"Greedy left-to-right. Track flip state with difference array or queue."},{"id":44,"title":"Count of Range Sum","num":327,"difficulty":"Hard","patterns":["Prefix Sum","Merge Sort"],"url":"https://leetcode.com/problems/count-of-range-sum/","note":"Prefix sums + modified merge sort to count pairs where lower ≤ P[j]-P[i] ≤ upper."},{"id":45,"title":"Max Consecutive Ones III","num":1004,"difficulty":"Medium","patterns":["Sliding Window"],"url":"https://leetcode.com/problems/max-consecutive-ones-iii/","note":"Variable window. Track zero count. Shrink when zeros > k. Same structure as char replacement."},{"id":46,"title":"Fruit Into Baskets","num":904,"difficulty":"Medium","patterns":["Sliding Window","Hash Map"],"url":"https://leetcode.com/problems/fruit-into-baskets/","note":"Longest subarray with at most 2 distinct. Standard variable window + HashMap."},{"id":47,"title":"Maximum Points You Can Obtain from Cards","num":1423,"difficulty":"Medium","patterns":["Sliding Window","Prefix Sum"],"url":"https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/","note":"Flip: find min sum subarray of length n-k. Answer = totalSum - minWindowSum."},{"id":48,"title":"Shortest Unsorted Continuous Subarray","num":581,"difficulty":"Medium","patterns":["Two Pointers","Sort"],"url":"https://leetcode.com/problems/shortest-unsorted-continuous-subarray/","note":"Find left/right bounds where array deviates from sorted order. O(n) with two passes."},{"id":49,"title":"Next Permutation","num":31,"difficulty":"Medium","patterns":["Array Manipulation"],"url":"https://leetcode.com/problems/next-permutation/","note":"Find rightmost ascent, swap with smallest larger to its right, reverse suffix."},{"id":50,"title":"Zigzag Conversion","num":6,"difficulty":"Medium","patterns":["String Simulation"],"url":"https://leetcode.com/problems/zigzag-conversion/","note":"Simulate with StringBuilder[] rows. Direction flips at row 0 and numRows-1."}]}],"hashmap":[{"name":"Tier 1 — Must Know","color":"#d44a3a","description":"The absolute essentials. These problems define the core HashMap patterns and appear in almost every interview loop. Master all of these before moving on.","problems":[{"id":1,"title":"Two Sum","num":1,"difficulty":"Easy","patterns":["Two Sum","Hash Map"],"url":"https://leetcode.com/problems/two-sum/","note":"THE foundational problem. HashMap<Integer, Integer> stores value → index. Check complement = target - nums[i] before inserting."},{"id":2,"title":"Valid Anagram","num":242,"difficulty":"Easy","patterns":["Frequency Count"],"url":"https://leetcode.com/problems/valid-anagram/","note":"int[26] — increment for s, decrement for t, check all zeros. Or Arrays.equals() on sorted char arrays."},{"id":3,"title":"Contains Duplicate","num":217,"difficulty":"Easy","patterns":["Hash Set"],"url":"https://leetcode.com/problems/contains-duplicate/","note":"HashSet.add() returns false if element exists. One pass O(n). Alternative: sort and check adjacent."},{"id":4,"title":"Ransom Note","num":383,"difficulty":"Easy","patterns":["Frequency Count"],"url":"https://leetcode.com/problems/ransom-note/","note":"Build freq from magazine. For each char in ransomNote, decrement. If any count goes below 0, return false."},{"id":5,"title":"First Unique Character in a String","num":387,"difficulty":"Easy","patterns":["Frequency Count"],"url":"https://leetcode.com/problems/first-unique-character-in-a-string/","note":"int[26] frequency pass. Second pass: first char with count == 1. Two-pass O(n)."},{"id":6,"title":"Majority Element","num":169,"difficulty":"Easy","patterns":["Frequency Count","Voting"],"url":"https://leetcode.com/problems/majority-element/","note":"HashMap freq count works. Optimal: Boyer-Moore Voting — O(1) space. Maintain candidate + count."},{"id":7,"title":"Group Anagrams","num":49,"difficulty":"Medium","patterns":["Frequency Key","Hash Map"],"url":"https://leetcode.com/problems/group-anagrams/","note":"Sorted string as key OR frequency string '#2#1#0...' as key. computeIfAbsent(key, k -> new ArrayList<>())."},{"id":8,"title":"Subarray Sum Equals K","num":560,"difficulty":"Medium","patterns":["Prefix Sum","Hash Map"],"url":"https://leetcode.com/problems/subarray-sum-equals-k/","note":"Prefix sum + HashMap<Integer, Integer>. MUST init map.put(0, 1). count += map.get(prefix - k)."},{"id":9,"title":"Top K Frequent Elements","num":347,"difficulty":"Medium","patterns":["Frequency Count","Bucket Sort"],"url":"https://leetcode.com/problems/top-k-frequent-elements/","note":"Freq map → bucket sort (index = frequency) for O(n). Or PriorityQueue for O(n log k)."},{"id":10,"title":"Longest Consecutive Sequence","num":128,"difficulty":"Medium","patterns":["Hash Set"],"url":"https://leetcode.com/problems/longest-consecutive-sequence/","note":"HashSet. Only start counting from sequence starts (num - 1 not in set). O(n) amortized."},{"id":11,"title":"3Sum","num":15,"difficulty":"Medium","patterns":["Two Sum","Two Pointers"],"url":"https://leetcode.com/problems/3sum/","note":"Sort + fix one + two pointers. Skip duplicates at all three levels. O(n²). Builds directly on Two Sum."},{"id":12,"title":"Contiguous Array","num":525,"difficulty":"Medium","patterns":["Prefix Sum","Hash Map"],"url":"https://leetcode.com/problems/contiguous-array/","note":"Replace 0 → -1. Prefix sum + HashMap stores prefix → FIRST index. Find longest subarray with sum 0."}]},{"name":"Tier 2 — Core Practice","color":"#c49a2e","description":"Builds fluency with the Tier 1 patterns through tougher variations. Covers two-sum extensions, index tracking, design problems, and prefix sum combos.","problems":[{"id":13,"title":"Two Sum II – Input Array Is Sorted","num":167,"difficulty":"Easy","patterns":["Two Sum","Two Pointers"],"url":"https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/","note":"Sorted → two pointers from both ends, no hash map needed. Demonstrates when to NOT use HashMap."},{"id":14,"title":"Contains Duplicate II","num":219,"difficulty":"Easy","patterns":["Hash Map","Index Track"],"url":"https://leetcode.com/problems/contains-duplicate-ii/","note":"HashMap<Integer, Integer> stores num → last index. Check if distance ≤ k on each encounter."},{"id":15,"title":"Isomorphic Strings","num":205,"difficulty":"Easy","patterns":["Hash Map","Bijection"],"url":"https://leetcode.com/problems/isomorphic-strings/","note":"Two maps: s→t and t→s. Each char must consistently map to exactly one char in the other direction."},{"id":16,"title":"Word Pattern","num":290,"difficulty":"Easy","patterns":["Hash Map","Bijection"],"url":"https://leetcode.com/problems/word-pattern/","note":"Same as isomorphic strings but char → word. HashMap<Character, String> + HashMap<String, Character>."},{"id":17,"title":"Intersection of Two Arrays II","num":350,"difficulty":"Easy","patterns":["Frequency Count"],"url":"https://leetcode.com/problems/intersection-of-two-arrays-ii/","note":"Freq map of smaller array. Iterate larger, if freq > 0, add to result and decrement."},{"id":18,"title":"Sort Characters by Frequency","num":451,"difficulty":"Medium","patterns":["Frequency Count","Bucket Sort"],"url":"https://leetcode.com/problems/sort-characters-by-frequency/","note":"Freq map → bucket sort. Build result string from highest frequency bucket down using StringBuilder."},{"id":19,"title":"4Sum II","num":454,"difficulty":"Medium","patterns":["Two Sum","Hash Map"],"url":"https://leetcode.com/problems/4sum-ii/","note":"Split into A+B and C+D. HashMap on all a+b sums. For each c+d, count += map.get(-(c+d)). O(n²)."},{"id":20,"title":"3Sum Closest","num":16,"difficulty":"Medium","patterns":["Two Sum","Two Pointers"],"url":"https://leetcode.com/problems/3sum-closest/","note":"Sort + fix one + two pointers. Track closest with Math.abs(sum - target). Same frame as 3Sum."},{"id":21,"title":"Continuous Subarray Sum","num":523,"difficulty":"Medium","patterns":["Prefix Sum","Hash Map"],"url":"https://leetcode.com/problems/continuous-subarray-sum/","note":"Store (prefix % k) → first index. If same remainder seen and gap ≥ 2, return true. Handle k = 0 edge."},{"id":22,"title":"Subarray Sums Divisible by K","num":974,"difficulty":"Medium","patterns":["Prefix Sum","Hash Map"],"url":"https://leetcode.com/problems/subarray-sums-divisible-by-k/","note":"Count prefix sums with same (prefix % k). Normalize: ((prefix % k) + k) % k for negative numbers."},{"id":23,"title":"Number of Good Pairs","num":1512,"difficulty":"Easy","patterns":["Pair Count","Hash Map"],"url":"https://leetcode.com/problems/number-of-good-pairs/","note":"count += freq so far for each num. Or after counting: sum of k*(k-1)/2 for each frequency k."},{"id":24,"title":"K-diff Pairs in an Array","num":532,"difficulty":"Medium","patterns":["Pair Count","Hash Map"],"url":"https://leetcode.com/problems/k-diff-pairs-in-an-array/","note":"Freq map. If k == 0: count entries with freq ≥ 2. If k > 0: count entries where num + k exists."},{"id":25,"title":"Insert Delete GetRandom O(1)","num":380,"difficulty":"Medium","patterns":["Design","Hash Map"],"url":"https://leetcode.com/problems/insert-delete-getrandom-o1/","note":"HashMap<val, index> + ArrayList. Swap-with-last trick for O(1) remove. getRandom on list."}]},{"name":"Tier 3 — Interview Ready","color":"#4a8ed4","description":"Problems that appear at top tech companies. Requires combining patterns, handling edge cases, and recognizing subtle transformations.","problems":[{"id":26,"title":"LRU Cache","num":146,"difficulty":"Medium","patterns":["Design","Hash Map"],"url":"https://leetcode.com/problems/lru-cache/","note":"HashMap<Integer, Node> + doubly linked list. Move to head on get/put. Evict from tail. O(1) all ops."},{"id":27,"title":"4Sum","num":18,"difficulty":"Medium","patterns":["Two Sum","Two Pointers"],"url":"https://leetcode.com/problems/4sum/","note":"Fix two + two pointers. Skip duplicates at all four levels. Use (long) to avoid integer overflow."},{"id":28,"title":"Longest Substring Without Repeating Characters","num":3,"difficulty":"Medium","patterns":["Hash Map","Sliding Window"],"url":"https://leetcode.com/problems/longest-substring-without-repeating-characters/","note":"HashMap<Character, Integer> stores char → last index. Slide left to max(left, lastSeen + 1)."},{"id":29,"title":"Minimum Window Substring","num":76,"difficulty":"Hard","patterns":["Hash Map","Sliding Window"],"url":"https://leetcode.com/problems/minimum-window-substring/","note":"Freq map for t. Expand right, shrink left when valid. Track 'formed' vs 'required' unique char matches."},{"id":30,"title":"Two Sum III – Data Structure Design","num":170,"difficulty":"Easy","patterns":["Two Sum","Design"],"url":"https://leetcode.com/problems/two-sum-iii-data-structure-design/","note":"HashMap<Integer, Integer> for value counts. find(): iterate keys, check complement. Handle num == complement (count ≥ 2)."},{"id":31,"title":"Maximum Size Subarray Sum Equals K","num":325,"difficulty":"Medium","patterns":["Prefix Sum","Hash Map"],"url":"https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/","note":"Prefix sum + HashMap stores prefix → FIRST index (don't overwrite). Maximize j - map.get(prefix - k)."},{"id":32,"title":"Happy Number","num":202,"difficulty":"Easy","patterns":["Hash Set","Cycle Detect"],"url":"https://leetcode.com/problems/happy-number/","note":"HashSet tracks seen sums. If sum == 1 → happy. If seen before → cycle → not happy. Or Floyd's."},{"id":33,"title":"Encode and Decode TinyURL","num":535,"difficulty":"Medium","patterns":["Design","Hash Map"],"url":"https://leetcode.com/problems/encode-and-decode-tinyurl/","note":"Two HashMaps: url→code and code→url. Generate random 6-char code or use incrementing counter."},{"id":34,"title":"Count Number of Bad Pairs","num":2364,"difficulty":"Medium","patterns":["Pair Count","Hash Map"],"url":"https://leetcode.com/problems/count-number-of-bad-pairs/","note":"bad = total - good. Good: j - i == nums[j] - nums[i] → (nums[j] - j) == (nums[i] - i). HashMap on diff."},{"id":35,"title":"Group Shifted Strings","num":249,"difficulty":"Medium","patterns":["Frequency Key","Hash Map"],"url":"https://leetcode.com/problems/group-shifted-strings/","note":"Key = comma-separated char differences. Normalize with (diff + 26) % 26. computeIfAbsent."},{"id":36,"title":"Find All Anagrams in a String","num":438,"difficulty":"Medium","patterns":["Frequency Count","Sliding Window"],"url":"https://leetcode.com/problems/find-all-anagrams-in-a-string/","note":"Fixed window of p.length(). int[26] need vs have + match counter. HashMap/frequency crossover problem."},{"id":37,"title":"Top K Frequent Words","num":692,"difficulty":"Medium","patterns":["Frequency Count","Bucket Sort"],"url":"https://leetcode.com/problems/top-k-frequent-words/","note":"Freq map → PriorityQueue with comparator: by freq desc, then alphabetically. Or bucket sort + sort within."},{"id":38,"title":"Longest Palindrome","num":409,"difficulty":"Easy","patterns":["Frequency Count"],"url":"https://leetcode.com/problems/longest-palindrome/","note":"Count chars. Sum all even counts. For odds, add (count - 1). If any odd exists, +1 for center."}]},{"name":"Tier 4 — Advanced / FAANG","color":"#7a5bb5","description":"Challenging problems requiring deep HashMap mastery, creative key encoding, complex design, or combining multiple advanced patterns.","problems":[{"id":39,"title":"LFU Cache","num":460,"difficulty":"Hard","patterns":["Design","Hash Map"],"url":"https://leetcode.com/problems/lfu-cache/","note":"Three maps: key→val, key→freq, freq→LinkedHashSet<key>. Track minFreq. O(1) all operations."},{"id":40,"title":"Time Based Key-Value Store","num":981,"difficulty":"Medium","patterns":["Design","Hash Map"],"url":"https://leetcode.com/problems/time-based-key-value-store/","note":"HashMap<String, TreeMap<Integer, String>>. get(): floorEntry(timestamp). O(log n) per timestamp lookup."},{"id":41,"title":"Subarrays with K Different Integers","num":992,"difficulty":"Hard","patterns":["Hash Map","Sliding Window"],"url":"https://leetcode.com/problems/subarrays-with-k-different-integers/","note":"exactly(K) = atMost(K) - atMost(K-1). atMost uses HashMap<Integer, Integer> for freq in window."},{"id":42,"title":"Substring with Concatenation of All Words","num":30,"difficulty":"Hard","patterns":["Hash Map","Sliding Window"],"url":"https://leetcode.com/problems/substring-with-concatenation-of-all-words/","note":"HashMap<String, Integer> for word freq. Fixed window of total length. Slide by word size with multiple offsets."},{"id":43,"title":"Find Duplicate Subtrees","num":652,"difficulty":"Medium","patterns":["Frequency Key","Hash Map"],"url":"https://leetcode.com/problems/find-duplicate-subtrees/","note":"Serialize each subtree as string via post-order. HashMap<String, Integer> counts occurrences. Collect dups."},{"id":44,"title":"Brick Wall","num":554,"difficulty":"Medium","patterns":["Hash Map","Prefix Sum"],"url":"https://leetcode.com/problems/brick-wall/","note":"HashMap<Integer, Integer> tracks gap positions. Draw line at most frequent gap. Answer = rows - maxGaps."},{"id":45,"title":"Find Duplicate File in System","num":609,"difficulty":"Medium","patterns":["Frequency Key","Hash Map"],"url":"https://leetcode.com/problems/find-duplicate-file-in-system/","note":"Parse path + content. Key = content string. Group file paths by content. Return groups with size > 1."},{"id":46,"title":"Number of Atoms","num":726,"difficulty":"Hard","patterns":["Hash Map","Stack"],"url":"https://leetcode.com/problems/number-of-atoms/","note":"Stack<Map<String, Integer>>. Push new map at '('. Pop and multiply at ')'. TreeMap for sorted output."},{"id":47,"title":"Random Pick with Blacklist","num":710,"difficulty":"Hard","patterns":["Hash Map","Design"],"url":"https://leetcode.com/problems/random-pick-with-blacklist/","note":"Remap blacklisted numbers in [0, n-b) to non-blacklisted numbers in [n-b, n). HashMap for remapping."},{"id":48,"title":"Count of Smaller Numbers After Self","num":315,"difficulty":"Hard","patterns":["Hash Map","BIT/Merge Sort"],"url":"https://leetcode.com/problems/count-of-smaller-numbers-after-self/","note":"Coordinate compression via HashMap + BIT. Or modified merge sort counting inversions."},{"id":49,"title":"Max Points on a Line","num":149,"difficulty":"Hard","patterns":["Hash Map","Geometry"],"url":"https://leetcode.com/problems/max-points-on-a-line/","note":"For each point, HashMap of slope → count. Slope as 'dy/dx' with GCD normalization. Handle vertical lines."},{"id":50,"title":"Longest Duplicate Substring","num":1044,"difficulty":"Hard","patterns":["Hash Map","Binary Search"],"url":"https://leetcode.com/problems/longest-duplicate-substring/","note":"Binary search on length + Rabin-Karp rolling hash. HashMap/HashSet stores hash values to detect duplicates."}]}],"stacks-queues":[{"name":"Tier 1 — Must Know","color":"#d44a3a","description":"The absolute essentials. These problems define the core stack, queue, monotonic stack, and BFS patterns. Master all of these before moving on.","problems":[{"id":1,"title":"Valid Parentheses","num":20,"difficulty":"Easy","patterns":["Stack","Matching"],"url":"https://leetcode.com/problems/valid-parentheses/","note":"Push opening brackets. On closing, check stack.peek() matches. Return stack.isEmpty() at end. THE foundational stack problem."},{"id":2,"title":"Min Stack","num":155,"difficulty":"Medium","patterns":["Stack","Design"],"url":"https://leetcode.com/problems/min-stack/","note":"Two stacks: main + minStack. Push to minStack when val ≤ current min. getMin() peeks minStack. O(1) all ops."},{"id":3,"title":"Daily Temperatures","num":739,"difficulty":"Medium","patterns":["Monotonic Stack"],"url":"https://leetcode.com/problems/daily-temperatures/","note":"THE canonical monotonic decreasing stack. Stack stores indices. Pop when current temp > stack.peek() temp. result[popped] = i - popped."},{"id":4,"title":"Next Greater Element I","num":496,"difficulty":"Easy","patterns":["Monotonic Stack","Hash Map"],"url":"https://leetcode.com/problems/next-greater-element-i/","note":"Monotonic decreasing stack on nums2. When popping, map popped → current as its next greater. Query map for nums1."},{"id":5,"title":"Number of Islands","num":200,"difficulty":"Medium","patterns":["BFS","Grid"],"url":"https://leetcode.com/problems/number-of-islands/","note":"BFS from each unvisited '1'. Mark visited immediately when enqueuing (not when dequeuing). Count connected components. THE BFS grid template."},{"id":6,"title":"Binary Tree Level Order Traversal","num":102,"difficulty":"Medium","patterns":["BFS","Tree"],"url":"https://leetcode.com/problems/binary-tree-level-order-traversal/","note":"Queue + level loop: int size = queue.size(), process exactly size nodes per level. Enqueue left/right children."},{"id":7,"title":"Evaluate Reverse Polish Notation","num":150,"difficulty":"Medium","patterns":["Stack","Expression"],"url":"https://leetcode.com/problems/evaluate-reverse-polish-notation/","note":"Stack of integers. Numbers → push. Operators → pop two, compute, push result. b = pop first, a = pop second: a op b."},{"id":8,"title":"Rotting Oranges","num":994,"difficulty":"Medium","patterns":["BFS","Multi-Source"],"url":"https://leetcode.com/problems/rotting-oranges/","note":"Multi-source BFS: enqueue ALL rotten oranges first. Track minutes per level. After BFS, check if any fresh remain → return -1."},{"id":9,"title":"Implement Queue using Stacks","num":232,"difficulty":"Easy","patterns":["Stack","Design"],"url":"https://leetcode.com/problems/implement-queue-using-stacks/","note":"Two stacks: input + output. push → input. pop/peek → if output empty, drain input to output. Amortized O(1)."},{"id":10,"title":"Implement Stack using Queues","num":225,"difficulty":"Easy","patterns":["Queue","Design"],"url":"https://leetcode.com/problems/implement-stack-using-queues/","note":"One queue. push(x): add x, then rotate queue.size()-1 elements to back. pop/top from front. O(n) push, O(1) pop."},{"id":11,"title":"Next Greater Element II","num":503,"difficulty":"Medium","patterns":["Monotonic Stack"],"url":"https://leetcode.com/problems/next-greater-element-ii/","note":"Circular array: iterate i from 0 to 2*n-1, use i % n. Same monotonic decreasing stack. Only assign results for i < n."},{"id":12,"title":"01 Matrix","num":542,"difficulty":"Medium","patterns":["BFS","Multi-Source"],"url":"https://leetcode.com/problems/01-matrix/","note":"Multi-source BFS from ALL 0-cells. Set 1-cells to MAX. BFS outward, updating distance = parent + 1. Think 'reverse' — expand from targets."}]},{"name":"Tier 2 — Core Practice","color":"#c49a2e","description":"Builds fluency with Tier 1 patterns through tougher variations. Stack-based parsing, monotonic stack extensions, BFS on implicit graphs, and design problems.","problems":[{"id":13,"title":"Online Stock Span","num":901,"difficulty":"Medium","patterns":["Monotonic Stack"],"url":"https://leetcode.com/problems/online-stock-span/","note":"Monotonic decreasing stack stores [price, span]. Pop while stack.peek().price ≤ current. Accumulate span from popped entries."},{"id":14,"title":"Largest Rectangle in Histogram","num":84,"difficulty":"Hard","patterns":["Monotonic Stack"],"url":"https://leetcode.com/problems/largest-rectangle-in-histogram/","note":"Monotonic increasing stack of indices. On pop, width = i - stack.peek() - 1 (or i if stack empty). Area = height[popped] * width. Append 0 sentinel."},{"id":15,"title":"Minimum Remove to Make Valid Parentheses","num":1249,"difficulty":"Medium","patterns":["Stack","Matching"],"url":"https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/","note":"Stack stores indices of '('. On ')', pop if stack non-empty, else mark index for removal. After loop, mark remaining stack indices. Build result skipping marked."},{"id":16,"title":"Basic Calculator II","num":227,"difficulty":"Medium","patterns":["Stack","Expression"],"url":"https://leetcode.com/problems/basic-calculator-ii/","note":"Stack + track prevOp. On number complete: if prevOp is +/- push ±num, if */÷ pop, compute, push result. Sum stack at end."},{"id":17,"title":"Decode String","num":394,"difficulty":"Medium","patterns":["Stack","Nested"],"url":"https://leetcode.com/problems/decode-string/","note":"Two stacks: counts + strings. On '[': push current count and current string, reset. On ']': pop and repeat. Handles nesting."},{"id":18,"title":"Open the Lock","num":752,"difficulty":"Medium","patterns":["BFS","Implicit Graph"],"url":"https://leetcode.com/problems/open-the-lock/","note":"BFS on state space. Each state = 4-digit string. 8 neighbors per state (±1 each digit). HashSet for deadends + visited. Classic implicit graph BFS."},{"id":19,"title":"Shortest Path in Binary Matrix","num":1091,"difficulty":"Medium","patterns":["BFS","Grid"],"url":"https://leetcode.com/problems/shortest-path-in-binary-matrix/","note":"BFS with 8 directions. Start (0,0) → end (n-1,n-1). Standard BFS = shortest path in unweighted graph. Track distance per level."},{"id":20,"title":"Word Ladder","num":127,"difficulty":"Hard","patterns":["BFS","Implicit Graph"],"url":"https://leetcode.com/problems/word-ladder/","note":"BFS on word graph. Neighbors: change each char a-z. Use wildcard patterns (h*t → hot, hat) for O(M²×N) preprocessing. Return level count."},{"id":21,"title":"Asteroid Collision","num":735,"difficulty":"Medium","patterns":["Stack","Simulation"],"url":"https://leetcode.com/problems/asteroid-collision/","note":"Stack simulation. Only collide when top > 0 and current < 0. Loop: pop if top < |current|, both die if equal, current dies if top > |current|."},{"id":22,"title":"Remove All Adjacent Duplicates in String II","num":1209,"difficulty":"Medium","patterns":["Stack","Matching"],"url":"https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/","note":"Stack of [char, count]. If top.char == current, increment count. If count == k, pop. Build result from stack."},{"id":23,"title":"Surrounded Regions","num":130,"difficulty":"Medium","patterns":["BFS","Grid"],"url":"https://leetcode.com/problems/surrounded-regions/","note":"BFS/DFS from border 'O' cells — mark as safe. Then flip all unmarked 'O' to 'X'. Reverse thinking: find what NOT to capture."},{"id":24,"title":"Walls and Gates","num":286,"difficulty":"Medium","patterns":["BFS","Multi-Source"],"url":"https://leetcode.com/problems/walls-and-gates/","note":"Multi-source BFS from all gates (0-cells). Fill INF rooms with distance. Same pattern as 01 Matrix — expand from targets."}]},{"name":"Tier 3 — Interview Ready","color":"#4a8ed4","description":"Problems that appear at top tech companies. Requires combining patterns, handling edge cases, and recognizing subtle transformations of core stack/BFS ideas.","problems":[{"id":25,"title":"Maximal Rectangle","num":85,"difficulty":"Hard","patterns":["Monotonic Stack","DP"],"url":"https://leetcode.com/problems/maximal-rectangle/","note":"Build histogram heights per row. Apply LC 84 (Largest Rectangle in Histogram) to each row. O(rows × cols). Unlocked by mastering #84."},{"id":26,"title":"Trapping Rain Water","num":42,"difficulty":"Hard","patterns":["Monotonic Stack","Two Pointers"],"url":"https://leetcode.com/problems/trapping-rain-water/","note":"Monotonic decreasing stack: on pop, trapped = (min(left, right) - height[popped]) × width. Or two-pointer O(1) space approach."},{"id":27,"title":"Basic Calculator","num":224,"difficulty":"Hard","patterns":["Stack","Expression"],"url":"https://leetcode.com/problems/basic-calculator/","note":"Stack stores sign context. On '(': push current result and sign, reset. On ')': pop sign and prev result. Handles +, -, ()."},{"id":28,"title":"Sliding Window Maximum","num":239,"difficulty":"Hard","patterns":["Monotonic Deque"],"url":"https://leetcode.com/problems/sliding-window-maximum/","note":"Monotonic decreasing deque of indices. Remove from front if out of window. Remove from back while ≤ current. Front = max."},{"id":29,"title":"Remove K Digits","num":402,"difficulty":"Medium","patterns":["Monotonic Stack","Greedy"],"url":"https://leetcode.com/problems/remove-k-digits/","note":"Monotonic increasing stack. Pop while top > current and k > 0. After loop, trim remaining k from end. Strip leading zeros."},{"id":30,"title":"Car Fleet","num":853,"difficulty":"Medium","patterns":["Monotonic Stack","Sort"],"url":"https://leetcode.com/problems/car-fleet/","note":"Sort by position desc. Calculate time to target. Stack: push if time > top (new fleet). Cars behind that arrive earlier merge. Count = stack.size()."},{"id":31,"title":"As Far from Land as Possible","num":1162,"difficulty":"Medium","patterns":["BFS","Multi-Source"],"url":"https://leetcode.com/problems/as-far-from-land-as-possible/","note":"Multi-source BFS from all land cells. Last cell reached by BFS has max distance. Same multi-source template as Rotting Oranges."},{"id":32,"title":"Simplify Path","num":71,"difficulty":"Medium","patterns":["Stack","Parsing"],"url":"https://leetcode.com/problems/simplify-path/","note":"Split by '/'. Stack: ignore '.', pop on '..', push valid directory names. Join with '/' prefix."},{"id":33,"title":"Shortest Bridge","num":934,"difficulty":"Medium","patterns":["BFS","Grid"],"url":"https://leetcode.com/problems/shortest-bridge/","note":"DFS/BFS to find and mark first island. BFS expand from entire first island boundary. First '1' of second island hit = shortest bridge."},{"id":34,"title":"Pacific Atlantic Water Flow","num":417,"difficulty":"Medium","patterns":["BFS","Grid"],"url":"https://leetcode.com/problems/pacific-atlantic-water-flow/","note":"Two BFS from each ocean's border. Flow uphill (reverse logic). Intersection of both reachable sets is the answer."},{"id":35,"title":"Minimum Cost Tree From Leaf Values","num":1130,"difficulty":"Medium","patterns":["Monotonic Stack","Greedy"],"url":"https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/","note":"Monotonic decreasing stack. When popping, cost += popped × min(stack.peek(), current). Greedily remove smallest leaves first."},{"id":36,"title":"Next Greater Node in Linked List","num":1019,"difficulty":"Medium","patterns":["Monotonic Stack"],"url":"https://leetcode.com/problems/next-greater-node-in-linked-list/","note":"Convert linked list to array (or use index). Apply standard next greater element monotonic stack pattern on the array."}]},{"name":"Tier 4 — Advanced / FAANG","color":"#7a5bb5","description":"Challenging problems requiring deep mastery — monotonic deques on prefix sums, multi-step BFS, complex simulations, and creative stack applications.","problems":[{"id":37,"title":"Shortest Subarray with Sum at Least K","num":862,"difficulty":"Hard","patterns":["Monotonic Deque","Prefix Sum"],"url":"https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/","note":"Prefix sums + monotonic increasing deque. Remove from front while prefix[i] - prefix[front] ≥ K (track min length). Remove from back while prefix[i] ≤ prefix[back]."},{"id":38,"title":"Largest Rectangle (Maximal Square variant)","num":221,"difficulty":"Medium","patterns":["Stack","DP"],"url":"https://leetcode.com/problems/maximal-square/","note":"DP approach: dp[i][j] = min(left, top, diag) + 1. Related to histogram stacking but DP is more natural here. Track global max side."},{"id":39,"title":"Number of Visible People in a Queue","num":1944,"difficulty":"Hard","patterns":["Monotonic Stack"],"url":"https://leetcode.com/problems/number-of-visible-people-in-a-queue/","note":"Iterate right to left. Monotonic decreasing stack. Pop while top < current (each popped person is visible to current). If stack non-empty, +1 for blocked view."},{"id":40,"title":"Sum of Subarray Minimums","num":907,"difficulty":"Medium","patterns":["Monotonic Stack"],"url":"https://leetcode.com/problems/sum-of-subarray-minimums/","note":"For each element, find left/right boundaries where it's the min. Contribution = arr[i] × left × right. Monotonic increasing stack for both passes."},{"id":41,"title":"Bus Routes","num":815,"difficulty":"Hard","patterns":["BFS","Implicit Graph"],"url":"https://leetcode.com/problems/bus-routes/","note":"BFS on routes (not stops). Map stop → routes. Enqueue all routes at source stop. Neighbors = routes sharing a stop. Min buses = levels."},{"id":42,"title":"Shortest Path Visiting All Nodes","num":847,"difficulty":"Hard","patterns":["BFS","Bitmask"],"url":"https://leetcode.com/problems/shortest-path-visiting-all-nodes/","note":"BFS with state = (node, visited_bitmask). Start BFS from all nodes. Goal: bitmask == (1 << n) - 1. Handles revisiting nodes."},{"id":43,"title":"Minimum Number of Refueling Stops","num":871,"difficulty":"Hard","patterns":["Stack","Greedy"],"url":"https://leetcode.com/problems/minimum-number-of-refueling-stops/","note":"Max-heap (PriorityQueue) of passed station fuels. When stuck, greedily refuel from largest passed station. Count refuels."},{"id":44,"title":"132 Pattern","num":456,"difficulty":"Medium","patterns":["Monotonic Stack"],"url":"https://leetcode.com/problems/132-pattern/","note":"Iterate right to left. Monotonic decreasing stack. Track 'third' (max popped value). If nums[i] < third, found 132. third = second largest."},{"id":45,"title":"Maximum Frequency Stack","num":895,"difficulty":"Hard","patterns":["Stack","Design"],"url":"https://leetcode.com/problems/maximum-frequency-stack/","note":"HashMap<Integer, Integer> freq + HashMap<Integer, Stack> groupByFreq. push: increment freq, push to group. pop: pop from maxFreq group, decrement."},{"id":46,"title":"Jump Game III","num":1306,"difficulty":"Medium","patterns":["BFS","Implicit Graph"],"url":"https://leetcode.com/problems/jump-game-iii/","note":"BFS from start index. Neighbors = i ± arr[i]. Goal: reach any index with value 0. Standard implicit graph BFS with visited set."},{"id":47,"title":"Minimum Obstacle Removal to Reach Corner","num":2290,"difficulty":"Hard","patterns":["BFS","0-1 BFS"],"url":"https://leetcode.com/problems/minimum-obstacle-removal-to-reach-corner/","note":"0-1 BFS using Deque. Empty cell = cost 0 → addFirst. Obstacle = cost 1 → addLast. Shortest path with binary weights."},{"id":48,"title":"Sum of Subarray Ranges","num":2104,"difficulty":"Medium","patterns":["Monotonic Stack"],"url":"https://leetcode.com/problems/sum-of-subarray-ranges/","note":"Sum of max contributions - sum of min contributions. Use monotonic stack twice: increasing for mins, decreasing for maxs. Extends LC 907."},{"id":49,"title":"Longest Valid Parentheses","num":32,"difficulty":"Hard","patterns":["Stack","Matching"],"url":"https://leetcode.com/problems/longest-valid-parentheses/","note":"Stack stores indices. Push -1 as base. On ')': pop, if empty push i as new base, else length = i - stack.peek(). Track max."},{"id":50,"title":"Cut Off Trees for Golf Event","num":675,"difficulty":"Hard","patterns":["BFS","Grid"],"url":"https://leetcode.com/problems/cut-off-trees-for-golf-event/","note":"Sort trees by height. BFS between consecutive trees for shortest path. Sum all distances. If any BFS fails, return -1."}]}],"linked-lists":[{"name":"Tier 1 — Must Know","color":"#d44a3a","description":"The absolute essentials. These problems define the core linked list patterns — reversal, fast/slow pointers, dummy heads, and merge. Master all of these first.","problems":[{"id":1,"title":"Reverse Linked List","num":206,"difficulty":"Easy","patterns":["Reversal","Pointer Manipulation"],"url":"https://leetcode.com/problems/reverse-linked-list/","note":"THE foundational problem. Iterative: prev/curr/next trio. Recursive: reverse rest, then point next.next back. O(n) time, O(1) space iterative."},{"id":2,"title":"Merge Two Sorted Lists","num":21,"difficulty":"Easy","patterns":["Merge","Dummy Head"],"url":"https://leetcode.com/problems/merge-two-sorted-lists/","note":"Dummy head technique. Compare heads, attach smaller, advance that pointer. Append remaining. O(n+m)."},{"id":3,"title":"Linked List Cycle","num":141,"difficulty":"Easy","patterns":["Fast & Slow"],"url":"https://leetcode.com/problems/linked-list-cycle/","note":"Floyd's: slow moves 1 step, fast moves 2. If they meet → cycle. If fast reaches null → no cycle. O(n) time, O(1) space."},{"id":4,"title":"Linked List Cycle II","num":142,"difficulty":"Medium","patterns":["Fast & Slow","Math"],"url":"https://leetcode.com/problems/linked-list-cycle-ii/","note":"After detection, reset one pointer to head. Both move 1 step — they meet at cycle start. Mathematical proof: a = c where a = head-to-start, c = meet-to-start."},{"id":5,"title":"Middle of the Linked List","num":876,"difficulty":"Easy","patterns":["Fast & Slow"],"url":"https://leetcode.com/problems/middle-of-the-linked-list/","note":"Slow moves 1, fast moves 2. When fast reaches end, slow is at middle. For even length, returns second middle."},{"id":6,"title":"Remove Nth Node From End of List","num":19,"difficulty":"Medium","patterns":["Fast & Slow","Dummy Head"],"url":"https://leetcode.com/problems/remove-nth-node-from-end-of-list/","note":"Two-pointer gap: advance fast n steps ahead. Move both until fast reaches end. Slow is at (n+1)th from end. Dummy head handles edge case of removing head."},{"id":7,"title":"Palindrome Linked List","num":234,"difficulty":"Easy","patterns":["Fast & Slow","Reversal"],"url":"https://leetcode.com/problems/palindrome-linked-list/","note":"Find middle (fast/slow), reverse second half, compare both halves. O(n) time, O(1) space. Optionally restore list."},{"id":8,"title":"Intersection of Two Linked Lists","num":160,"difficulty":"Easy","patterns":["Two Pointers","Math"],"url":"https://leetcode.com/problems/intersection-of-two-linked-lists/","note":"Two pointers: when one reaches end, redirect to other list's head. They meet at intersection (or both null). Total steps equalize path lengths."},{"id":9,"title":"Remove Duplicates from Sorted List","num":83,"difficulty":"Easy","patterns":["Pointer Manipulation"],"url":"https://leetcode.com/problems/remove-duplicates-from-sorted-list/","note":"If curr.val == curr.next.val, skip next node (curr.next = curr.next.next). Else advance. Sorted → duplicates are adjacent."},{"id":10,"title":"Add Two Numbers","num":2,"difficulty":"Medium","patterns":["Dummy Head","Math"],"url":"https://leetcode.com/problems/add-two-numbers/","note":"Digits stored in reverse → add digit by digit with carry. Dummy head for result. carry = sum / 10, digit = sum % 10. Don't forget final carry."}]},{"name":"Tier 2 — Core Practice","color":"#c49a2e","description":"Builds fluency with Tier 1 patterns through harder variations. Covers partial reversal, swapping, reordering, and common interview twists on the fundamentals.","problems":[{"id":11,"title":"Reverse Linked List II","num":92,"difficulty":"Medium","patterns":["Reversal","Pointer Manipulation"],"url":"https://leetcode.com/problems/reverse-linked-list-ii/","note":"Reverse sublist from position left to right. Track the node before left (prev) and the node at left (tail of reversed). Reconnect after reversal."},{"id":12,"title":"Odd Even Linked List","num":328,"difficulty":"Medium","patterns":["Pointer Manipulation","Reorder"],"url":"https://leetcode.com/problems/odd-even-linked-list/","note":"Two pointers: odd and even. Interleave by skipping. Save evenHead. Connect odd tail → evenHead. O(n) time, O(1) space."},{"id":13,"title":"Swap Nodes in Pairs","num":24,"difficulty":"Medium","patterns":["Pointer Manipulation","Dummy Head"],"url":"https://leetcode.com/problems/swap-nodes-in-pairs/","note":"Dummy head. For each pair: rewire prev→second, first→second.next, second→first. Advance prev by 2. Or recursive: swap first two, recurse on rest."},{"id":14,"title":"Delete Node in a Linked List","num":237,"difficulty":"Medium","patterns":["Pointer Manipulation"],"url":"https://leetcode.com/problems/delete-node-in-a-linked-list/","note":"Trick question: no access to previous. Copy next node's value into current, then skip next. node.val = node.next.val; node.next = node.next.next."},{"id":15,"title":"Remove Linked List Elements","num":203,"difficulty":"Easy","patterns":["Dummy Head","Pointer Manipulation"],"url":"https://leetcode.com/problems/remove-linked-list-elements/","note":"Dummy head handles removing head node. Traverse: if next.val == val, skip it. Else advance. Clean single-pass O(n)."},{"id":16,"title":"Sort List","num":148,"difficulty":"Medium","patterns":["Merge Sort","Fast & Slow"],"url":"https://leetcode.com/problems/sort-list/","note":"Merge sort on linked list. Find middle (fast/slow), split, recursively sort both halves, merge. O(n log n) time, O(log n) stack space."},{"id":17,"title":"Reorder List","num":143,"difficulty":"Medium","patterns":["Fast & Slow","Reversal","Merge"],"url":"https://leetcode.com/problems/reorder-list/","note":"Three steps: 1) Find middle, 2) Reverse second half, 3) Interleave merge both halves. Combines three core patterns. O(n) time, O(1) space."},{"id":18,"title":"Rotate List","num":61,"difficulty":"Medium","patterns":["Pointer Manipulation","Math"],"url":"https://leetcode.com/problems/rotate-list/","note":"Find length, k %= length. Make circular (connect tail to head). Advance (length - k) from head, break. New head = break point."},{"id":19,"title":"Remove Duplicates from Sorted List II","num":82,"difficulty":"Medium","patterns":["Dummy Head","Pointer Manipulation"],"url":"https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/","note":"Dummy head. If curr.next and curr.next.next have same val → skip ALL duplicates. Else advance. Removes all nodes with duplicate values."},{"id":20,"title":"Partition List","num":86,"difficulty":"Medium","patterns":["Dummy Head","Pointer Manipulation"],"url":"https://leetcode.com/problems/partition-list/","note":"Two dummy heads: 'less' and 'greater' lists. Partition by value x. Connect less tail → greater head. Set greater tail → null. O(n)."},{"id":21,"title":"Add Two Numbers II","num":445,"difficulty":"Medium","patterns":["Reversal","Stack","Math"],"url":"https://leetcode.com/problems/add-two-numbers-ii/","note":"Digits in forward order. Either reverse both lists first (then same as #2), or use two stacks to process from least significant digit."},{"id":22,"title":"Copy List with Random Pointer","num":138,"difficulty":"Medium","patterns":["Hash Map","Pointer Manipulation"],"url":"https://leetcode.com/problems/copy-list-with-random-pointer/","note":"HashMap<Node, Node> maps original → copy. Two passes: create nodes, then wire next/random. Or O(1) space: interleave copies, wire random, separate."}]},{"name":"Tier 3 — Interview Ready","color":"#4a8ed4","description":"Problems that appear at top tech companies. Requires combining patterns, handling complex pointer manipulation, and recognizing when linked list techniques apply.","problems":[{"id":23,"title":"Merge K Sorted Lists","num":23,"difficulty":"Hard","patterns":["Merge","Heap"],"url":"https://leetcode.com/problems/merge-k-sorted-lists/","note":"Min-heap of list heads. Poll min, advance that list, re-offer. O(N log k). Or divide-and-conquer merge pairs: O(N log k) same complexity."},{"id":24,"title":"Reverse Nodes in k-Group","num":25,"difficulty":"Hard","patterns":["Reversal","Pointer Manipulation"],"url":"https://leetcode.com/problems/reverse-nodes-in-k-group/","note":"Count k nodes ahead. If enough, reverse the group, connect prev→new head, old head (now tail)→next group. Repeat. O(n) time, O(1) space."},{"id":25,"title":"LRU Cache","num":146,"difficulty":"Medium","patterns":["Design","Doubly Linked List"],"url":"https://leetcode.com/problems/lru-cache/","note":"HashMap<key, Node> + doubly linked list. Move to head on access. Evict from tail. All operations O(1). THE classic design problem."},{"id":26,"title":"Flatten a Multilevel Doubly Linked List","num":430,"difficulty":"Medium","patterns":["Pointer Manipulation","DFS"],"url":"https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/","note":"DFS iterative with stack. Or: when child found, find child's tail, splice child list into main list, clear child pointer. Continue."},{"id":27,"title":"Swapping Nodes in a Linked List","num":1721,"difficulty":"Medium","patterns":["Fast & Slow","Two Pointers"],"url":"https://leetcode.com/problems/swapping-nodes-in-a-linked-list/","note":"Find kth from start (advance k steps). Then two pointers to find kth from end. Swap values (not nodes). O(n)."},{"id":28,"title":"Split Linked List in Parts","num":725,"difficulty":"Medium","patterns":["Math","Pointer Manipulation"],"url":"https://leetcode.com/problems/split-linked-list-in-parts/","note":"length / k = base size, length % k = parts that get +1. Distribute greedily. Cut connections between parts."},{"id":29,"title":"Insert into a Sorted Circular Linked List","num":708,"difficulty":"Medium","patterns":["Pointer Manipulation","Edge Cases"],"url":"https://leetcode.com/problems/insert-into-a-sorted-circular-linked-list/","note":"Three cases: 1) Normal insert between prev ≤ val ≤ curr, 2) Insert at max/min boundary, 3) All values equal. Handle empty list."},{"id":30,"title":"Linked List in Binary Tree","num":1367,"difficulty":"Medium","patterns":["DFS","Pattern Matching"],"url":"https://leetcode.com/problems/linked-list-in-binary-tree/","note":"For each tree node, try matching from that node as root. DFS on tree + DFS for matching. O(n × m) where n=tree, m=list."},{"id":31,"title":"Design Linked List","num":707,"difficulty":"Medium","patterns":["Design","Pointer Manipulation"],"url":"https://leetcode.com/problems/design-linked-list/","note":"Implement singly or doubly linked list from scratch. Dummy head simplifies all operations. Track size for O(1) length check."},{"id":32,"title":"Next Greater Node In Linked List","num":1019,"difficulty":"Medium","patterns":["Monotonic Stack","Linked List"],"url":"https://leetcode.com/problems/next-greater-node-in-linked-list/","note":"Convert to array, then monotonic stack for next greater. Or process with stack of (index, value) pairs directly."},{"id":33,"title":"Design Browser History","num":1472,"difficulty":"Medium","patterns":["Design","Doubly Linked List"],"url":"https://leetcode.com/problems/design-browser-history/","note":"Doubly linked list. visit() clears forward history (set curr.next = new node). back()/forward() traverse with step limits."}]},{"name":"Tier 4 — Advanced / FAANG","color":"#7a5bb5","description":"Challenging problems requiring deep linked list mastery, complex multi-step pointer manipulation, or creative combinations with other data structures.","problems":[{"id":34,"title":"LFU Cache","num":460,"difficulty":"Hard","patterns":["Design","Doubly Linked List"],"url":"https://leetcode.com/problems/lfu-cache/","note":"HashMap<key, Node> + HashMap<freq, DoublyLinkedList>. Track minFreq. On access: move node to freq+1 list. O(1) all ops."},{"id":35,"title":"Reverse Nodes in Even Length Groups","num":2074,"difficulty":"Medium","patterns":["Reversal","Pointer Manipulation"],"url":"https://leetcode.com/problems/reverse-nodes-in-even-length-groups/","note":"Groups of increasing size (1,2,3,...). Count actual group size (may be shorter at end). Reverse if even count. Tricky pointer management."},{"id":36,"title":"Merge In Between Linked Lists","num":1669,"difficulty":"Medium","patterns":["Pointer Manipulation"],"url":"https://leetcode.com/problems/merge-in-between-linked-lists/","note":"Find node at position (a-1) and node at position (b+1). Point (a-1).next → list2 head. Find list2 tail, point it → (b+1). O(n+m)."},{"id":37,"title":"Remove Zero Sum Consecutive Nodes","num":1171,"difficulty":"Medium","patterns":["Prefix Sum","Hash Map"],"url":"https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/","note":"Prefix sum + HashMap<prefixSum, node>. If prefix sum repeats, remove all nodes between the two occurrences. Two-pass with dummy head."},{"id":38,"title":"All O'one Data Structure","num":432,"difficulty":"Hard","patterns":["Design","Doubly Linked List"],"url":"https://leetcode.com/problems/all-oone-data-structure/","note":"HashMap<key, Node> + doubly linked list of freq buckets. Each bucket holds a set of keys. inc/dec move keys between adjacent buckets. O(1) all ops."},{"id":39,"title":"Design Skiplist","num":1206,"difficulty":"Hard","patterns":["Design","Probabilistic"],"url":"https://leetcode.com/problems/design-skiplist/","note":"Multi-level linked list. Random level assignment (coin flip). search/add/erase in O(log n) expected. Track predecessors at each level."},{"id":40,"title":"Linked List Random Node","num":382,"difficulty":"Medium","patterns":["Reservoir Sampling","Math"],"url":"https://leetcode.com/problems/linked-list-random-node/","note":"Reservoir sampling: for i-th node, replace with probability 1/i. Uniform distribution without knowing length. O(n) per call, O(1) space."},{"id":41,"title":"Plus One Linked List","num":369,"difficulty":"Medium","patterns":["Reversal","Math"],"url":"https://leetcode.com/problems/plus-one-linked-list/","note":"Find rightmost non-9 node. Increment it. Set all nodes after it to 0. If all 9s, prepend new head with 1. Or reverse, add, reverse back."},{"id":42,"title":"Maximum Twin Sum of a Linked List","num":2130,"difficulty":"Medium","patterns":["Fast & Slow","Reversal"],"url":"https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/","note":"Find middle, reverse second half, iterate both halves summing twins. Track max twin sum. Same 3-step pattern as reorder list."},{"id":43,"title":"Delete N Nodes After M Nodes","num":1474,"difficulty":"Easy","patterns":["Pointer Manipulation"],"url":"https://leetcode.com/problems/delete-n-nodes-after-m-nodes-of-a-linked-list/","note":"Keep m nodes (advance m times), delete n nodes (skip n times), repeat. Two-phase loop with counters. O(total length)."},{"id":44,"title":"Convert Binary Search Tree to Sorted Doubly Linked List","num":426,"difficulty":"Medium","patterns":["DFS","Pointer Manipulation"],"url":"https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/","note":"Inorder traversal. Track prev and head. Connect prev.right → curr, curr.left → prev. Finally connect head ↔ tail for circular."},{"id":45,"title":"Design a Text Editor","num":2296,"difficulty":"Hard","patterns":["Design","Doubly Linked List"],"url":"https://leetcode.com/problems/design-a-text-editor/","note":"Doubly linked list with cursor pointer. Insert/delete at cursor position in O(1). Or two-stack approach (left stack + right stack)."}]}],"trees":[{"name":"Tier 1 — Must Know","color":"#d44a3a","description":"The absolute essentials. These problems define the core tree traversal patterns, recursion fundamentals, and BST operations. Master all of these before moving on.","problems":[{"id":1,"title":"Binary Tree Inorder Traversal","num":94,"difficulty":"Easy","patterns":["DFS","Recursion"],"url":"https://leetcode.com/problems/binary-tree-inorder-traversal/","note":"Left → Root → Right. Recursive: inorder(left), add(root), inorder(right). Iterative: stack + go left until null, pop, go right."},{"id":2,"title":"Binary Tree Preorder Traversal","num":144,"difficulty":"Easy","patterns":["DFS","Recursion"],"url":"https://leetcode.com/problems/binary-tree-preorder-traversal/","note":"Root → Left → Right. Recursive is trivial. Iterative: push root, pop and add, push RIGHT then LEFT (stack reverses order)."},{"id":3,"title":"Binary Tree Postorder Traversal","num":145,"difficulty":"Easy","patterns":["DFS","Recursion"],"url":"https://leetcode.com/problems/binary-tree-postorder-traversal/","note":"Left → Right → Root. Iterative: two stacks, or reverse of (Root → Right → Left). Trickiest of the three iteratively."},{"id":4,"title":"Binary Tree Level Order Traversal","num":102,"difficulty":"Medium","patterns":["BFS","Tree"],"url":"https://leetcode.com/problems/binary-tree-level-order-traversal/","note":"Queue + level loop. int size = queue.size() at level start, process exactly size nodes. THE BFS tree template."},{"id":5,"title":"Maximum Depth of Binary Tree","num":104,"difficulty":"Easy","patterns":["DFS","Recursion"],"url":"https://leetcode.com/problems/maximum-depth-of-binary-tree/","note":"return 1 + Math.max(maxDepth(left), maxDepth(right)). Base case: null → 0. Classic recursion pattern."},{"id":6,"title":"Invert Binary Tree","num":226,"difficulty":"Easy","patterns":["DFS","Recursion"],"url":"https://leetcode.com/problems/invert-binary-tree/","note":"Swap left and right children, recurse on both. Can be done preorder or postorder. The famous Homebrew interview question."},{"id":7,"title":"Same Tree","num":100,"difficulty":"Easy","patterns":["DFS","Recursion"],"url":"https://leetcode.com/problems/same-tree/","note":"Both null → true. One null → false. p.val != q.val → false. Recurse on both children with AND."},{"id":8,"title":"Symmetric Tree","num":101,"difficulty":"Easy","patterns":["DFS","Recursion"],"url":"https://leetcode.com/problems/symmetric-tree/","note":"isMirror(left, right): both null → true, one null → false, vals equal AND isMirror(l.left, r.right) AND isMirror(l.right, r.left)."},{"id":9,"title":"Validate Binary Search Tree","num":98,"difficulty":"Medium","patterns":["DFS","BST"],"url":"https://leetcode.com/problems/validate-binary-search-tree/","note":"Pass min/max bounds: isValid(node, min, max). Or inorder traversal must be strictly increasing. Use Long.MIN/MAX for initial bounds."},{"id":10,"title":"Lowest Common Ancestor of a Binary Tree","num":236,"difficulty":"Medium","patterns":["DFS","Recursion"],"url":"https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/","note":"If node == p or q, return node. Recurse left and right. If both non-null, node is LCA. Else return the non-null one."},{"id":11,"title":"Search in a Binary Search Tree","num":700,"difficulty":"Easy","patterns":["BST","Recursion"],"url":"https://leetcode.com/problems/search-in-a-binary-search-tree/","note":"If val < root.val, go left. If val > root.val, go right. O(log n) for balanced, O(n) worst case."},{"id":12,"title":"Insert into a Binary Search Tree","num":701,"difficulty":"Medium","patterns":["BST","Recursion"],"url":"https://leetcode.com/problems/insert-into-a-binary-search-tree/","note":"Find null position using BST property. Return new TreeNode(val) at null. Recursive: root.left = insert(root.left, val)."}]},{"name":"Tier 2 — Core Practice","color":"#c49a2e","description":"Builds fluency with Tier 1 patterns through tougher variations. Path sums, tree construction, more traversal variants, and intermediate BST operations.","problems":[{"id":13,"title":"Path Sum","num":112,"difficulty":"Easy","patterns":["DFS","Recursion"],"url":"https://leetcode.com/problems/path-sum/","note":"Subtract node.val from target as you go. At leaf, check if remaining == 0. Return left OR right."},{"id":14,"title":"Path Sum II","num":113,"difficulty":"Medium","patterns":["DFS","Backtracking"],"url":"https://leetcode.com/problems/path-sum-ii/","note":"Backtracking: add node to path, recurse, remove node after. Collect path copy when leaf with sum == 0."},{"id":15,"title":"Binary Tree Right Side View","num":199,"difficulty":"Medium","patterns":["BFS","DFS"],"url":"https://leetcode.com/problems/binary-tree-right-side-view/","note":"BFS: last node of each level. Or DFS right-first: if depth == result.size(), add node (first node at that depth from right)."},{"id":16,"title":"Binary Tree Zigzag Level Order","num":103,"difficulty":"Medium","patterns":["BFS","Tree"],"url":"https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/","note":"Standard BFS with level list. Alternate: add to front or back using addFirst/addLast on LinkedList. Or reverse every other level."},{"id":17,"title":"Construct Binary Tree from Preorder and Inorder","num":105,"difficulty":"Medium","patterns":["DFS","Recursion"],"url":"https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/","note":"Preorder[0] = root. Find root in inorder → left subtree indices and right subtree indices. HashMap for O(1) index lookup."},{"id":18,"title":"Construct Binary Tree from Inorder and Postorder","num":106,"difficulty":"Medium","patterns":["DFS","Recursion"],"url":"https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/","note":"Postorder[last] = root. Similar to #105 but build right subtree first (postorder visits right before left going backwards)."},{"id":19,"title":"Flatten Binary Tree to Linked List","num":114,"difficulty":"Medium","patterns":["DFS","Recursion"],"url":"https://leetcode.com/problems/flatten-binary-tree-to-linked-list/","note":"Preorder-style. For each node: save right, flatten left, move left to right, find end of flattened left, attach saved right."},{"id":20,"title":"Populating Next Right Pointers in Each Node","num":116,"difficulty":"Medium","patterns":["BFS","Tree"],"url":"https://leetcode.com/problems/populating-next-right-pointers-in-each-node/","note":"Perfect tree: use established next pointers. leftmost.left.next = leftmost.right. leftmost.right.next = leftmost.next?.left. O(1) space."},{"id":21,"title":"Kth Smallest Element in a BST","num":230,"difficulty":"Medium","patterns":["BST","DFS"],"url":"https://leetcode.com/problems/kth-smallest-element-in-a-bst/","note":"Inorder traversal gives sorted order. Count nodes, return when count == k. Iterative with stack is cleaner for early termination."},{"id":22,"title":"Delete Node in a BST","num":450,"difficulty":"Medium","patterns":["BST","Recursion"],"url":"https://leetcode.com/problems/delete-node-in-a-bst/","note":"Three cases: leaf (just delete), one child (replace with child), two children (replace with inorder successor/predecessor, then delete that)."},{"id":23,"title":"Lowest Common Ancestor of a BST","num":235,"difficulty":"Medium","patterns":["BST","Recursion"],"url":"https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/","note":"Exploit BST property: if both < root, go left. If both > root, go right. Otherwise root is LCA. O(log n) for balanced."},{"id":24,"title":"Convert Sorted Array to Binary Search Tree","num":108,"difficulty":"Easy","patterns":["BST","Recursion"],"url":"https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/","note":"Pick middle as root for balance. Recurse on left half and right half. Classic divide and conquer on sorted input."},{"id":25,"title":"Diameter of Binary Tree","num":543,"difficulty":"Easy","patterns":["DFS","Recursion"],"url":"https://leetcode.com/problems/diameter-of-binary-tree/","note":"Diameter through node = leftHeight + rightHeight. Track global max. Return 1 + max(left, right) for height calculation."}]},{"name":"Tier 3 — Interview Ready","color":"#4a8ed4","description":"Problems that appear at top tech companies. Requires combining patterns, handling edge cases, and recognizing when to use iterative vs recursive approaches.","problems":[{"id":26,"title":"Binary Tree Maximum Path Sum","num":124,"difficulty":"Hard","patterns":["DFS","Recursion"],"url":"https://leetcode.com/problems/binary-tree-maximum-path-sum/","note":"At each node: maxPath = node.val + max(0, left) + max(0, right). Return node.val + max(0, max(left, right)) for parent chain. Global max."},{"id":27,"title":"Serialize and Deserialize Binary Tree","num":297,"difficulty":"Hard","patterns":["DFS","BFS"],"url":"https://leetcode.com/problems/serialize-and-deserialize-binary-tree/","note":"Preorder with 'null' markers. Serialize: root,left,right. Deserialize: consume values with queue/index, build recursively."},{"id":28,"title":"Binary Tree Level Order Traversal II","num":107,"difficulty":"Medium","patterns":["BFS","Tree"],"url":"https://leetcode.com/problems/binary-tree-level-order-traversal-ii/","note":"Standard level order, then Collections.reverse(result). Or addFirst to LinkedList instead of add."},{"id":29,"title":"Sum Root to Leaf Numbers","num":129,"difficulty":"Medium","patterns":["DFS","Recursion"],"url":"https://leetcode.com/problems/sum-root-to-leaf-numbers/","note":"Pass currentNum * 10 + node.val down. At leaf, return the number. Sum left and right returns. Elegant prefix propagation."},{"id":30,"title":"Path Sum III","num":437,"difficulty":"Medium","patterns":["DFS","Prefix Sum"],"url":"https://leetcode.com/problems/path-sum-iii/","note":"Prefix sum + HashMap in tree! map.get(prefixSum - target) counts valid paths ending here. Backtrack: remove current prefix after recursing."},{"id":31,"title":"House Robber III","num":337,"difficulty":"Medium","patterns":["DFS","DP"],"url":"https://leetcode.com/problems/house-robber-iii/","note":"Return [robThis, skipThis] from each node. robThis = node.val + left[1] + right[1]. skipThis = max(left) + max(right)."},{"id":32,"title":"Count Good Nodes in Binary Tree","num":1448,"difficulty":"Medium","patterns":["DFS","Recursion"],"url":"https://leetcode.com/problems/count-good-nodes-in-binary-tree/","note":"Pass maxSoFar down the path. If node.val >= maxSoFar, it's good. Update max and recurse. Count good nodes."},{"id":33,"title":"All Nodes Distance K in Binary Tree","num":863,"difficulty":"Medium","patterns":["DFS","BFS"],"url":"https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/","note":"Build parent pointers with DFS. Then BFS from target node, treating tree as graph (can go to parent). Stop at distance K."},{"id":34,"title":"Binary Tree Cameras","num":968,"difficulty":"Hard","patterns":["DFS","Greedy"],"url":"https://leetcode.com/problems/binary-tree-cameras/","note":"Post-order greedy. States: 0=needs camera, 1=has camera, 2=covered. Place cameras at parents of uncovered nodes."},{"id":35,"title":"Recover Binary Search Tree","num":99,"difficulty":"Medium","patterns":["BST","DFS"],"url":"https://leetcode.com/problems/recover-binary-search-tree/","note":"Inorder should be sorted. Find two swapped nodes: first violation (prev > curr → first = prev), last violation (second = curr). Swap values."},{"id":36,"title":"Trim a Binary Search Tree","num":669,"difficulty":"Medium","patterns":["BST","Recursion"],"url":"https://leetcode.com/problems/trim-a-binary-search-tree/","note":"If val < low, return trim(right). If val > high, return trim(left). Else trim both children and return node."},{"id":37,"title":"Balanced Binary Tree","num":110,"difficulty":"Easy","patterns":["DFS","Recursion"],"url":"https://leetcode.com/problems/balanced-binary-tree/","note":"Height function returns -1 if unbalanced. At each node: if |leftH - rightH| > 1, return -1. Else return 1 + max. O(n) single pass."},{"id":38,"title":"Subtree of Another Tree","num":572,"difficulty":"Easy","patterns":["DFS","Recursion"],"url":"https://leetcode.com/problems/subtree-of-another-tree/","note":"At each node, check isSameTree(node, subRoot). If not, recurse on left and right with OR. O(m*n) naive, O(m+n) with hashing."}]},{"name":"Tier 4 — Advanced / FAANG","color":"#7a5bb5","description":"Challenging problems requiring deep mastery — complex tree DP, advanced BST operations, serialization edge cases, and creative traversal combinations.","problems":[{"id":39,"title":"Vertical Order Traversal of a Binary Tree","num":987,"difficulty":"Hard","patterns":["BFS","DFS"],"url":"https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/","note":"Track (col, row, val) for each node. Sort by col, then row, then val. TreeMap<col, PriorityQueue> or just collect and sort."},{"id":40,"title":"Binary Tree Longest Consecutive Sequence","num":298,"difficulty":"Medium","patterns":["DFS","Recursion"],"url":"https://leetcode.com/problems/binary-tree-longest-consecutive-sequence/","note":"Pass current length down. If child.val == parent.val + 1, increment. Else reset to 1. Track global max."},{"id":41,"title":"Count Complete Tree Nodes","num":222,"difficulty":"Medium","patterns":["DFS","Binary Search"],"url":"https://leetcode.com/problems/count-complete-tree-nodes/","note":"If leftHeight == rightHeight, it's perfect: return (1 << height) - 1. Else recurse: 1 + count(left) + count(right). O(log²n)."},{"id":42,"title":"Find Duplicate Subtrees","num":652,"difficulty":"Medium","patterns":["DFS","Hash Map"],"url":"https://leetcode.com/problems/find-duplicate-subtrees/","note":"Serialize each subtree post-order: 'left,right,val'. HashMap<String, Integer> counts. When count hits 2, add root to result."},{"id":43,"title":"Distribute Coins in Binary Tree","num":979,"difficulty":"Medium","patterns":["DFS","Recursion"],"url":"https://leetcode.com/problems/distribute-coins-in-binary-tree/","note":"Post-order: each node returns excess coins (positive) or deficit (negative). Moves += |leftExcess| + |rightExcess|. Bubble up net."},{"id":44,"title":"Smallest String Starting From Leaf","num":988,"difficulty":"Medium","patterns":["DFS","Recursion"],"url":"https://leetcode.com/problems/smallest-string-starting-from-leaf/","note":"Build string leaf-to-root (prepend or reverse at end). Compare at leaves. Careful: must compare full strings, not just prefixes."},{"id":45,"title":"Maximum Width of Binary Tree","num":662,"difficulty":"Medium","patterns":["BFS","Tree"],"url":"https://leetcode.com/problems/maximum-width-of-binary-tree/","note":"BFS with position indexing: root=0, left=2*i, right=2*i+1. Width = rightmost - leftmost + 1 per level. Handle overflow by offsetting."},{"id":46,"title":"Binary Search Tree Iterator","num":173,"difficulty":"Medium","patterns":["BST","Design"],"url":"https://leetcode.com/problems/binary-search-tree-iterator/","note":"Controlled inorder with stack. pushAllLeft() helper. next(): pop, pushAllLeft(node.right). O(1) average, O(h) space."},{"id":47,"title":"Unique Binary Search Trees","num":96,"difficulty":"Medium","patterns":["BST","DP"],"url":"https://leetcode.com/problems/unique-binary-search-trees/","note":"Catalan number. dp[n] = sum of dp[i-1] * dp[n-i] for i=1..n. dp[0] = dp[1] = 1. Each i as root, multiply left × right combos."},{"id":48,"title":"Unique Binary Search Trees II","num":95,"difficulty":"Medium","patterns":["BST","Recursion"],"url":"https://leetcode.com/problems/unique-binary-search-trees-ii/","note":"Generate all trees. For each root i: leftTrees = generate(start, i-1), rightTrees = generate(i+1, end). Combine all pairs."},{"id":49,"title":"Binary Tree Pruning","num":814,"difficulty":"Medium","patterns":["DFS","Recursion"],"url":"https://leetcode.com/problems/binary-tree-pruning/","note":"Post-order: prune children first, then check if node is leaf with val 0. Return null if so. Return node otherwise."},{"id":50,"title":"Check Completeness of a Binary Tree","num":958,"difficulty":"Medium","patterns":["BFS","Tree"],"url":"https://leetcode.com/problems/check-completeness-of-a-binary-tree/","note":"BFS level order. Once a null is seen, all subsequent nodes must also be null. Flag when first null encountered."}]}],"graphs":[{"name":"Tier 1 — Must Know","color":"#e85d4a","description":"Solve these first. They cover foundational graph traversal, connected components, and basic Union-Find. These patterns appear constantly in interviews.","problems":[{"id":1,"title":"Number of Islands","num":200,"difficulty":"Medium","patterns":["BFS","DFS","Grid"],"url":"https://leetcode.com/problems/number-of-islands/","note":"THE classic graph problem. BFS or DFS from each unvisited '1'. Mark visited. Count connected components."},{"id":2,"title":"Flood Fill","num":733,"difficulty":"Easy","patterns":["BFS","DFS","Grid"],"url":"https://leetcode.com/problems/flood-fill/","note":"DFS/BFS from starting pixel. Only visit same-color neighbors. Simple connected component fill."},{"id":3,"title":"Max Area of Island","num":695,"difficulty":"Medium","patterns":["DFS","Grid"],"url":"https://leetcode.com/problems/max-area-of-island/","note":"DFS from each '1'. Return size of component. Track max across all components."},{"id":4,"title":"Clone Graph","num":133,"difficulty":"Medium","patterns":["BFS","DFS","Hash Map"],"url":"https://leetcode.com/problems/clone-graph/","note":"HashMap<Node, ClonedNode>. DFS/BFS — if neighbor already cloned, reuse. Otherwise create + recurse."},{"id":5,"title":"Rotting Oranges","num":994,"difficulty":"Medium","patterns":["BFS","Multi-Source"],"url":"https://leetcode.com/problems/rotting-oranges/","note":"Multi-source BFS from all rotten oranges. Each level = 1 minute. Check if any fresh remain at end."},{"id":6,"title":"01 Matrix","num":542,"difficulty":"Medium","patterns":["BFS","Multi-Source"],"url":"https://leetcode.com/problems/01-matrix/","note":"Multi-source BFS from all 0s simultaneously. Expand outward to fill distances to nearest 0 for each 1."},{"id":7,"title":"Course Schedule","num":207,"difficulty":"Medium","patterns":["Topological Sort","BFS","Cycle Detection"],"url":"https://leetcode.com/problems/course-schedule/","note":"Kahn's algorithm (BFS): track in-degrees, enqueue 0-degree nodes. If processed != numCourses → cycle."},{"id":8,"title":"Course Schedule II","num":210,"difficulty":"Medium","patterns":["Topological Sort","BFS"],"url":"https://leetcode.com/problems/course-schedule-ii/","note":"Same as Course Schedule but return the ordering. Collect nodes as you dequeue in Kahn's."},{"id":9,"title":"Number of Provinces","num":547,"difficulty":"Medium","patterns":["Union-Find","DFS"],"url":"https://leetcode.com/problems/number-of-provinces/","note":"Adjacency matrix → Union-Find or DFS. Count connected components. Union-Find: count = n - merges."},{"id":10,"title":"Surrounded Regions","num":130,"difficulty":"Medium","patterns":["DFS","BFS","Grid"],"url":"https://leetcode.com/problems/surrounded-regions/","note":"DFS/BFS from border 'O's to mark safe. Then flip all unmarked 'O' → 'X'. Reverse thinking."},{"id":11,"title":"Pacific Atlantic Water Flow","num":417,"difficulty":"Medium","patterns":["DFS","BFS","Grid"],"url":"https://leetcode.com/problems/pacific-atlantic-water-flow/","note":"BFS/DFS from each ocean's border inward (reverse flow). Answer = intersection of both reachable sets."},{"id":12,"title":"Is Graph Bipartite?","num":785,"difficulty":"Medium","patterns":["BFS","DFS","Graph Coloring"],"url":"https://leetcode.com/problems/is-graph-bipartite/","note":"BFS/DFS with 2-coloring. Assign color, if neighbor same color → not bipartite. Check all components."}]},{"name":"Tier 2 — Core Practice","color":"#d49a3e","description":"These build on Tier 1 with harder graph modeling, multi-step BFS, implicit graphs, and Union-Find with rank/compression. Covers common interview variations.","problems":[{"id":13,"title":"Word Ladder","num":127,"difficulty":"Hard","patterns":["BFS","Implicit Graph"],"url":"https://leetcode.com/problems/word-ladder/","note":"BFS on word graph. Each word is a node. Edges = 1 char difference. Use wildcard pattern for neighbors."},{"id":14,"title":"Open the Lock","num":752,"difficulty":"Medium","patterns":["BFS","Implicit Graph"],"url":"https://leetcode.com/problems/open-the-lock/","note":"BFS from '0000'. 8 neighbors per state (±1 each digit). HashSet for deadends + visited."},{"id":15,"title":"Shortest Path in Binary Matrix","num":1091,"difficulty":"Medium","patterns":["BFS","Grid"],"url":"https://leetcode.com/problems/shortest-path-in-binary-matrix/","note":"BFS from (0,0) to (n-1,n-1). 8-directional. Level = distance. Return steps + 1."},{"id":16,"title":"All Paths From Source to Target","num":797,"difficulty":"Medium","patterns":["DFS","Backtracking"],"url":"https://leetcode.com/problems/all-paths-from-source-to-target/","note":"DFS/backtracking on DAG. No visited needed (DAG = no cycles). Collect paths reaching node n-1."},{"id":17,"title":"Keys and Rooms","num":841,"difficulty":"Medium","patterns":["DFS","BFS"],"url":"https://leetcode.com/problems/keys-and-rooms/","note":"DFS/BFS from room 0. Collect keys → unlock rooms. Return visited.size() == n."},{"id":18,"title":"Redundant Connection","num":684,"difficulty":"Medium","patterns":["Union-Find","Cycle Detection"],"url":"https://leetcode.com/problems/redundant-connection/","note":"Union-Find. Process edges in order. First edge where find(u) == find(v) creates cycle → return it."},{"id":19,"title":"Graph Valid Tree","num":261,"difficulty":"Medium","patterns":["Union-Find","BFS"],"url":"https://leetcode.com/problems/graph-valid-tree/","note":"Tree = connected + no cycle + edges == n-1. Union-Find: if any union fails → cycle. Check components == 1."},{"id":20,"title":"Number of Connected Components","num":323,"difficulty":"Medium","patterns":["Union-Find","DFS"],"url":"https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/","note":"Union-Find: start with n components, each union decrements by 1. Or DFS counting traversal starts."},{"id":21,"title":"Minimum Height Trees","num":310,"difficulty":"Medium","patterns":["Topological Sort","BFS"],"url":"https://leetcode.com/problems/minimum-height-trees/","note":"Peel leaves layer by layer (reverse topological). Last 1-2 remaining nodes are the roots. Like Kahn's from leaves."},{"id":22,"title":"Walls and Gates","num":286,"difficulty":"Medium","patterns":["BFS","Multi-Source","Grid"],"url":"https://leetcode.com/problems/walls-and-gates/","note":"Multi-source BFS from all gates. Fill distances outward. Same pattern as 01 Matrix."},{"id":23,"title":"Shortest Bridge","num":934,"difficulty":"Medium","patterns":["DFS","BFS","Grid"],"url":"https://leetcode.com/problems/shortest-bridge/","note":"DFS to find first island, add all cells to queue. BFS outward from that island to reach second island."},{"id":24,"title":"Evaluate Division","num":399,"difficulty":"Medium","patterns":["BFS","DFS","Weighted Graph"],"url":"https://leetcode.com/problems/evaluate-division/","note":"Build weighted directed graph. a/b=2 → edge a→b weight 2, b→a weight 0.5. BFS/DFS to find path and multiply weights."}]},{"name":"Tier 3 — Interview Ready","color":"#5a9bd5","description":"Harder problems frequently seen at top tech companies. Require combining patterns, advanced state BFS, or creative graph modeling.","problems":[{"id":25,"title":"Word Ladder II","num":126,"difficulty":"Hard","patterns":["BFS","DFS","Backtracking"],"url":"https://leetcode.com/problems/word-ladder-ii/","note":"BFS to build shortest-path DAG (level by level). Then DFS/backtrack on DAG to collect all shortest paths."},{"id":26,"title":"Alien Dictionary","num":269,"difficulty":"Hard","patterns":["Topological Sort","BFS"],"url":"https://leetcode.com/problems/alien-dictionary/","note":"Compare adjacent words to extract char ordering edges. Topological sort (Kahn's). Watch for invalid inputs."},{"id":27,"title":"Network Delay Time","num":743,"difficulty":"Medium","patterns":["BFS","Dijkstra","Weighted Graph"],"url":"https://leetcode.com/problems/network-delay-time/","note":"Dijkstra's from source. PriorityQueue<int[]> by distance. Return max of all shortest distances, or -1."},{"id":28,"title":"Cheapest Flights Within K Stops","num":787,"difficulty":"Medium","patterns":["BFS","Dijkstra","DP"],"url":"https://leetcode.com/problems/cheapest-flights-within-k-stops/","note":"Modified Bellman-Ford (K+1 iterations) or BFS with level limit. Can't use pure Dijkstra due to K constraint."},{"id":29,"title":"Accounts Merge","num":721,"difficulty":"Medium","patterns":["Union-Find","DFS","Hash Map"],"url":"https://leetcode.com/problems/accounts-merge/","note":"Union-Find: union all emails in same account. Map email→parent. Group by root, sort, prepend name."},{"id":30,"title":"Longest Increasing Path in a Matrix","num":329,"difficulty":"Hard","patterns":["DFS","Memoization","Topological Sort"],"url":"https://leetcode.com/problems/longest-increasing-path-in-a-matrix/","note":"DFS + memo from each cell. No visited needed — strictly increasing = no cycles (implicit DAG). Or topological sort."},{"id":31,"title":"Course Schedule IV","num":1462,"difficulty":"Medium","patterns":["Topological Sort","BFS","Reachability"],"url":"https://leetcode.com/problems/course-schedule-iv/","note":"Topological order + propagate reachability sets. Or Floyd-Warshall for transitive closure. Answer queries from matrix."},{"id":32,"title":"Snakes and Ladders","num":909,"difficulty":"Medium","patterns":["BFS","Implicit Graph"],"url":"https://leetcode.com/problems/snakes-and-ladders/","note":"BFS on board positions 1..n². Map position to (row,col) with boustrophedon. Handle snakes/ladders as redirects."},{"id":33,"title":"Minimum Knight Moves","num":1197,"difficulty":"Medium","patterns":["BFS","Bidirectional BFS"],"url":"https://leetcode.com/problems/minimum-knight-moves/","note":"BFS with 8 knight moves. Bidirectional BFS for optimization. Work in positive quadrant due to symmetry."},{"id":34,"title":"Parallel Courses","num":1136,"difficulty":"Medium","patterns":["Topological Sort","BFS"],"url":"https://leetcode.com/problems/parallel-courses/","note":"Kahn's topological sort counting levels. Answer = number of BFS levels. If cycle detected, return -1."},{"id":35,"title":"Possible Bipartition","num":886,"difficulty":"Medium","patterns":["BFS","DFS","Graph Coloring"],"url":"https://leetcode.com/problems/possible-bipartition/","note":"Same as Is Graph Bipartite. Build dislike graph → 2-color with BFS/DFS. If conflict → impossible."},{"id":36,"title":"Swim in Rising Water","num":778,"difficulty":"Hard","patterns":["BFS","Binary Search","Union-Find"],"url":"https://leetcode.com/problems/swim-in-rising-water/","note":"Binary search on answer t + BFS to check reachability. Or Dijkstra-like: PQ by max elevation on path."}]},{"name":"Tier 4 — Advanced / FAANG","color":"#8a6bbf","description":"Challenging problems for those targeting FAANG-level preparation. These test deep understanding of advanced BFS states, complex Union-Find, and creative graph modeling.","problems":[{"id":37,"title":"Word Search II","num":212,"difficulty":"Hard","patterns":["DFS","Trie","Backtracking"],"url":"https://leetcode.com/problems/word-search-ii/","note":"Build Trie from words. DFS grid with Trie traversal. Prune branches when no prefix matches. Remove found words."},{"id":38,"title":"Shortest Path to Get All Keys","num":864,"difficulty":"Hard","patterns":["BFS","Bitmask State"],"url":"https://leetcode.com/problems/shortest-path-to-get-all-keys/","note":"BFS with state = (row, col, keysBitmask). Visited is 3D. Doors passable only with matching key bit."},{"id":39,"title":"Bus Routes","num":815,"difficulty":"Hard","patterns":["BFS","Implicit Graph"],"url":"https://leetcode.com/problems/bus-routes/","note":"BFS on routes (not stops). Map stop→routes. Start from all routes containing source. Level = bus changes."},{"id":40,"title":"Reconstruct Itinerary","num":332,"difficulty":"Hard","patterns":["DFS","Eulerian Path"],"url":"https://leetcode.com/problems/reconstruct-itinerary/","note":"Hierholzer's algorithm. PriorityQueue for lexical order. DFS post-order → reverse = Eulerian path."},{"id":41,"title":"Critical Connections in a Network","num":1192,"difficulty":"Hard","patterns":["DFS","Tarjan's Bridge"],"url":"https://leetcode.com/problems/critical-connections-in-a-network/","note":"Tarjan's bridge-finding. Track discovery time + low-link. Edge (u,v) is bridge if low[v] > disc[u]."},{"id":42,"title":"Making A Large Island","num":827,"difficulty":"Hard","patterns":["DFS","Union-Find","Grid"],"url":"https://leetcode.com/problems/making-a-large-island/","note":"DFS to label + measure each island. For each 0, sum unique neighboring island sizes + 1. Track by island id."},{"id":43,"title":"Sliding Puzzle","num":773,"difficulty":"Hard","patterns":["BFS","State Space"],"url":"https://leetcode.com/problems/sliding-puzzle/","note":"BFS on board state (serialize as string). Generate neighbors by swapping 0 with adjacent tiles. Target = '123450'."},{"id":44,"title":"Minimum Cost to Connect All Points","num":1584,"difficulty":"Medium","patterns":["Union-Find","MST","Prim's"],"url":"https://leetcode.com/problems/minimum-cost-to-connect-all-points/","note":"Kruskal's: sort all edges by Manhattan distance, Union-Find to add edges. Or Prim's with PQ."},{"id":45,"title":"Sequence Reconstruction","num":444,"difficulty":"Medium","patterns":["Topological Sort","BFS"],"url":"https://leetcode.com/problems/sequence-reconstruction/","note":"Kahn's topological sort. Valid if queue never has >1 element (unique ordering) and result matches."},{"id":46,"title":"Graph Connectivity With Threshold","num":1627,"difficulty":"Hard","patterns":["Union-Find","Math"],"url":"https://leetcode.com/problems/graph-connectivity-with-threshold/","note":"For each factor > threshold, union all its multiples. Enumerate factors, not pairs. O(n log n) unions."},{"id":47,"title":"Shortest Path Visiting All Nodes","num":847,"difficulty":"Hard","patterns":["BFS","Bitmask State"],"url":"https://leetcode.com/problems/shortest-path-visiting-all-nodes/","note":"BFS with state = (node, visitedBitmask). Start from all nodes simultaneously. Target mask = (1<<n)-1."},{"id":48,"title":"Number of Islands II","num":305,"difficulty":"Hard","patterns":["Union-Find","Grid"],"url":"https://leetcode.com/problems/number-of-islands-ii/","note":"Online Union-Find. For each new land, start as new island then union with 4 neighbors if they're land."},{"id":49,"title":"The Maze II","num":505,"difficulty":"Medium","patterns":["BFS","Dijkstra","Grid"],"url":"https://leetcode.com/problems/the-maze-ii/","note":"Ball rolls until wall. Dijkstra with PQ: state = position, weight = roll distance. Not standard BFS — variable edge weights."},{"id":50,"title":"Find Eventual Safe States","num":802,"difficulty":"Medium","patterns":["Topological Sort","DFS","Cycle Detection"],"url":"https://leetcode.com/problems/find-eventual-safe-states/","note":"Reverse graph + Kahn's from terminal nodes. Or DFS with 3-color: safe = reaches only terminal nodes (no cycles)."}]}],"heaps":[{"name":"Tier 1 — Must Know","color":"#e85d4a","description":"Solve these first. They cover the foundational heap patterns — top-K, basic priority queues, and stream processing. These appear constantly in interviews.","problems":[{"id":1,"title":"Kth Largest Element in an Array","num":215,"difficulty":"Medium","patterns":["Top-K","Min Heap"],"url":"https://leetcode.com/problems/kth-largest-element-in-an-array/","note":"Min-heap of size k. Poll when size > k. Top = kth largest. O(n log k). Or quickselect O(n) avg."},{"id":2,"title":"Top K Frequent Elements","num":347,"difficulty":"Medium","patterns":["Top-K","Frequency","Min Heap"],"url":"https://leetcode.com/problems/top-k-frequent-elements/","note":"Freq map → min-heap of size k by frequency. Or bucket sort (index = freq) for O(n). Classic top-K."},{"id":3,"title":"Merge K Sorted Lists","num":23,"difficulty":"Hard","patterns":["Merge K","Min Heap"],"url":"https://leetcode.com/problems/merge-k-sorted-lists/","note":"PriorityQueue<ListNode> by val. Poll min, add to result, push node.next. O(N log k) total."},{"id":4,"title":"Last Stone Weight","num":1046,"difficulty":"Easy","patterns":["Max Heap","Simulation"],"url":"https://leetcode.com/problems/last-stone-weight/","note":"Max-heap (PQ with Collections.reverseOrder()). Poll two, push diff if > 0. Repeat until ≤ 1 left."},{"id":5,"title":"Kth Largest Element in a Stream","num":703,"difficulty":"Easy","patterns":["Top-K","Min Heap","Design"],"url":"https://leetcode.com/problems/kth-largest-element-in-a-stream/","note":"Maintain min-heap of size k. add(): offer, if size > k poll. peek() = kth largest. O(log k) per add."},{"id":6,"title":"K Closest Points to Origin","num":973,"difficulty":"Medium","patterns":["Top-K","Max Heap"],"url":"https://leetcode.com/problems/k-closest-points-to-origin/","note":"Max-heap of size k by distance. If size > k, poll farthest. Or min-heap poll k times. Skip sqrt — compare x²+y²."},{"id":7,"title":"Sort an Array","num":912,"difficulty":"Medium","patterns":["Heap Sort","Min Heap"],"url":"https://leetcode.com/problems/sort-an-array/","note":"Heap sort: build max-heap, extract max n times. Or just PQ.offer all → PQ.poll all. O(n log n)."},{"id":8,"title":"Find Median from Data Stream","num":295,"difficulty":"Hard","patterns":["Two Heaps","Design"],"url":"https://leetcode.com/problems/find-median-from-data-stream/","note":"Max-heap (left half) + min-heap (right half). Balance sizes. Median = top of larger or avg of both tops."},{"id":9,"title":"Task Scheduler","num":621,"difficulty":"Medium","patterns":["Scheduling","Max Heap","Greedy"],"url":"https://leetcode.com/problems/task-scheduler/","note":"Max-heap by freq. Each round: poll up to n+1 tasks, decrement freq, re-add if > 0. Count idle slots."},{"id":10,"title":"Reorganize String","num":767,"difficulty":"Medium","patterns":["Scheduling","Max Heap","Greedy"],"url":"https://leetcode.com/problems/reorganize-string/","note":"Max-heap by freq. Alternate: poll top, append, hold aside, poll next, append, push both back. If maxFreq > (n+1)/2 → impossible."}]},{"name":"Tier 2 — Core Practice","color":"#d49a3e","description":"These build on Tier 1 with merge-K variations, sliding window heaps, lazy deletion, and two-heap extensions. Solidifies understanding of PQ mechanics.","problems":[{"id":11,"title":"Kth Smallest Element in a Sorted Matrix","num":378,"difficulty":"Medium","patterns":["Merge K","Min Heap"],"url":"https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/","note":"Min-heap with (val, row, col). Start with first col. Poll min → push right neighbor. Poll k times. Or binary search."},{"id":12,"title":"Top K Frequent Words","num":692,"difficulty":"Medium","patterns":["Top-K","Frequency","Min Heap"],"url":"https://leetcode.com/problems/top-k-frequent-words/","note":"Freq map → min-heap of size k: compare by freq asc, then lexicographic desc (reverse for min-heap). Reverse result."},{"id":13,"title":"Ugly Number II","num":264,"difficulty":"Medium","patterns":["Min Heap","Generation"],"url":"https://leetcode.com/problems/ugly-number-ii/","note":"Min-heap + HashSet for dedup. Poll min, multiply by 2,3,5, add new if unseen. Poll n times. Or 3-pointer DP."},{"id":14,"title":"Sort Characters By Frequency","num":451,"difficulty":"Medium","patterns":["Frequency","Max Heap"],"url":"https://leetcode.com/problems/sort-characters-by-frequency/","note":"Freq map → max-heap by frequency. Poll and repeat char freq times into StringBuilder. Or bucket sort O(n)."},{"id":15,"title":"Furthest Building You Can Reach","num":1642,"difficulty":"Medium","patterns":["Min Heap","Greedy"],"url":"https://leetcode.com/problems/furthest-building-you-can-reach/","note":"Min-heap of climbs where ladders used. If heap.size > ladders, poll smallest and spend bricks. Greedy: ladders for biggest climbs."},{"id":16,"title":"Minimum Cost to Connect Sticks","num":1167,"difficulty":"Medium","patterns":["Min Heap","Greedy"],"url":"https://leetcode.com/problems/minimum-cost-to-connect-sticks/","note":"Min-heap. Always combine two smallest. Cost += sum of two. Push combined back. Huffman encoding pattern."},{"id":17,"title":"Sliding Window Median","num":480,"difficulty":"Hard","patterns":["Two Heaps","Sliding Window"],"url":"https://leetcode.com/problems/sliding-window-median/","note":"Two heaps + lazy deletion with HashMap for removed counts. Rebalance after add/remove. Clean tops before reading median."},{"id":18,"title":"Meeting Rooms II","num":253,"difficulty":"Medium","patterns":["Min Heap","Interval Scheduling"],"url":"https://leetcode.com/problems/meeting-rooms-ii/","note":"Sort by start. Min-heap of end times. If earliest end ≤ current start, poll (reuse room). Always offer current end. heap.size = rooms."},{"id":19,"title":"Car Pooling","num":1094,"difficulty":"Medium","patterns":["Min Heap","Interval Scheduling"],"url":"https://leetcode.com/problems/car-pooling/","note":"Sort by pickup. Min-heap of (dropoff, passengers). Before each pickup, poll all expired trips. Track current load vs capacity."},{"id":20,"title":"Single-Threaded CPU","num":1834,"difficulty":"Medium","patterns":["Min Heap","Scheduling","Simulation"],"url":"https://leetcode.com/problems/single-threaded-cpu/","note":"Sort by enqueue time. Min-heap by (processingTime, index). Advance time, enqueue available, poll shortest. Tie-break by index."},{"id":21,"title":"Seat Reservation Manager","num":1845,"difficulty":"Medium","patterns":["Min Heap","Design"],"url":"https://leetcode.com/problems/seat-reservation-manager/","note":"Min-heap initialized with 1..n. reserve() = poll(). unreserve(seat) = offer(seat). Smallest always at top."},{"id":22,"title":"Find K Pairs with Smallest Sums","num":373,"difficulty":"Medium","patterns":["Merge K","Min Heap"],"url":"https://leetcode.com/problems/find-k-pairs-with-smallest-sums/","note":"Min-heap of (sum, i, j). Start with (nums1[i]+nums2[0], i, 0) for all i. Poll → push (i, j+1). Like merge K sorted lists."}]},{"name":"Tier 3 — Interview Ready","color":"#5a9bd5","description":"Harder problems frequently seen at top tech companies. Require combining heap with other patterns, advanced scheduling, or creative priority modeling.","problems":[{"id":23,"title":"IPO","num":502,"difficulty":"Hard","patterns":["Two Heaps","Greedy"],"url":"https://leetcode.com/problems/ipo/","note":"Min-heap by capital required, max-heap by profit. Unlock affordable projects → pick most profitable. Repeat k times."},{"id":24,"title":"Smallest Range Covering Elements from K Lists","num":632,"difficulty":"Hard","patterns":["Merge K","Min Heap","Sliding Window"],"url":"https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/","note":"Min-heap of (val, list, idx). Track global max. Range = [heap.peek(), max]. Poll min → advance that list → update max."},{"id":25,"title":"Employee Free Time","num":759,"difficulty":"Hard","patterns":["Merge K","Min Heap","Interval"],"url":"https://leetcode.com/problems/employee-free-time/","note":"Merge K sorted interval lists via min-heap. Track previous end. Gap = next start > prev end. Collect gaps."},{"id":26,"title":"Merge K Sorted Arrays","num":0,"difficulty":"Medium","patterns":["Merge K","Min Heap"],"url":"https://leetcode.com/problems/merge-k-sorted-lists/","note":"Same pattern as Merge K Sorted Lists but with arrays. Min-heap of (val, arrayIdx, elementIdx). Poll → push next from same array."},{"id":27,"title":"Maximum Performance of a Team","num":1383,"difficulty":"Hard","patterns":["Min Heap","Greedy","Sort"],"url":"https://leetcode.com/problems/maximum-performance-of-a-team/","note":"Sort by efficiency desc. Min-heap of speeds, size k. For each engineer: add speed, if > k poll min. Track sum × currentEff."},{"id":28,"title":"Process Tasks Using Servers","num":1882,"difficulty":"Medium","patterns":["Two Heaps","Scheduling","Simulation"],"url":"https://leetcode.com/problems/process-tasks-using-servers/","note":"Available min-heap by (weight, index). Busy min-heap by (freeTime, weight, index). At each time, move freed → available, assign tasks."},{"id":29,"title":"Minimum Number of Refueling Stops","num":871,"difficulty":"Hard","patterns":["Max Heap","Greedy"],"url":"https://leetcode.com/problems/minimum-number-of-refueling-stops/","note":"Max-heap of fuel at passed stations. When stuck (fuel < 0), greedily refuel from largest passed station. Count refuels."},{"id":30,"title":"Course Schedule III","num":630,"difficulty":"Hard","patterns":["Max Heap","Greedy","Scheduling"],"url":"https://leetcode.com/problems/course-schedule-iii/","note":"Sort by deadline. Max-heap of durations taken. For each course: take it. If total > deadline, drop longest (poll). heap.size = answer."},{"id":31,"title":"Minimum Cost to Hire K Workers","num":857,"difficulty":"Hard","patterns":["Max Heap","Greedy","Sort"],"url":"https://leetcode.com/problems/minimum-cost-to-hire-k-workers/","note":"Sort by wage/quality ratio. Max-heap of qualities. Slide: add quality, if > k poll max. cost = ratio × totalQuality."},{"id":32,"title":"Trapping Rain Water II","num":407,"difficulty":"Hard","patterns":["Min Heap","BFS","Grid"],"url":"https://leetcode.com/problems/trapping-rain-water-ii/","note":"Min-heap of border cells. Process lowest first. Neighbor lower? Water += diff. Push max(neighbor, current) height."},{"id":33,"title":"The Skyline Problem","num":218,"difficulty":"Hard","patterns":["Max Heap","Sweep Line"],"url":"https://leetcode.com/problems/the-skyline-problem/","note":"Events: (x, -height) for start, (x, height) for end. Max-heap (TreeMap for lazy delete). Key point when max height changes."},{"id":34,"title":"Minimum Interval to Include Each Query","num":1851,"difficulty":"Hard","patterns":["Min Heap","Sort","Sweep Line"],"url":"https://leetcode.com/problems/minimum-interval-to-include-each-query/","note":"Sort intervals by start, queries by value. Min-heap by interval size. Add overlapping intervals, remove expired, peek min."}]},{"name":"Tier 4 — Advanced / FAANG","color":"#8a6bbf","description":"Challenging problems for those targeting FAANG-level preparation. These test deep understanding of priority queue mechanics, complex simulations, and creative modeling.","problems":[{"id":35,"title":"Find Median from Data Stream (Follow-up)","num":295,"difficulty":"Hard","patterns":["Two Heaps","Multiset"],"url":"https://leetcode.com/problems/find-median-from-data-stream/","note":"Follow-up: handle duplicates efficiently. TreeMap<Integer, Integer> for freq-aware two halves. Or with removals via lazy delete."},{"id":36,"title":"Smallest Number in Infinite Set","num":2336,"difficulty":"Medium","patterns":["Min Heap","Design"],"url":"https://leetcode.com/problems/smallest-number-in-infinite-set/","note":"Min-heap + HashSet for added-back numbers. Track threshold counter for numbers never removed. O(log n) per op."},{"id":37,"title":"Total Cost to Hire K Workers","num":2462,"difficulty":"Medium","patterns":["Two Heaps","Greedy"],"url":"https://leetcode.com/problems/total-cost-to-hire-k-workers/","note":"Two min-heaps: front candidates and back candidates. Each round pick cheaper. Expand window as elements consumed."},{"id":38,"title":"Maximum Subsequence Score","num":2542,"difficulty":"Medium","patterns":["Min Heap","Greedy","Sort"],"url":"https://leetcode.com/problems/maximum-subsequence-score/","note":"Sort by nums2 desc (multiplier). Min-heap of nums1 values, size k. Score = sum(heap) × nums2[i]. Same pattern as Maximum Performance."},{"id":39,"title":"Stock Price Fluctuation","num":2034,"difficulty":"Medium","patterns":["Two Heaps","Design","Hash Map"],"url":"https://leetcode.com/problems/stock-price-fluctuation/","note":"HashMap<timestamp, price>. Max-heap and min-heap. Lazy deletion: if top's price ≠ map value, stale → pop."},{"id":40,"title":"Design Twitter","num":355,"difficulty":"Medium","patterns":["Merge K","Max Heap","Design"],"url":"https://leetcode.com/problems/design-twitter/","note":"Each user has tweet list. getNewsFeed: merge K sorted (by time) tweet lists from followees via max-heap. Top 10."},{"id":41,"title":"K Closest Points to Origin (Follow-up)","num":973,"difficulty":"Medium","patterns":["Top-K","Quickselect"],"url":"https://leetcode.com/problems/k-closest-points-to-origin/","note":"Follow-up: quickselect for O(n) average. Partition by distance. Recurse on correct half. Same idea as Kth Largest."},{"id":42,"title":"Constrained Subsequence Sum","num":1425,"difficulty":"Hard","patterns":["Max Heap","DP","Monotonic Deque"],"url":"https://leetcode.com/problems/constrained-subsequence-sum/","note":"dp[i] = nums[i] + max(0, max dp[j] for j in [i-k, i-1]). Max-heap or monotonic deque for sliding max. O(n log n) or O(n)."},{"id":43,"title":"Rearrange String k Distance Apart","num":358,"difficulty":"Hard","patterns":["Scheduling","Max Heap","Queue"],"url":"https://leetcode.com/problems/rearrange-string-k-distance-apart/","note":"Max-heap by freq + cooldown queue. Poll max, append, push to queue. When queue.size >= k, re-add front to heap."},{"id":44,"title":"Minimum Deviation in Array","num":1675,"difficulty":"Hard","patterns":["Min Heap","Greedy"],"url":"https://leetcode.com/problems/minimum-deviation-in-array/","note":"Normalize: double all odds. Max-heap. Deviation = max - min. Repeatedly halve max (if even). Stop when max is odd."},{"id":45,"title":"Super Ugly Number","num":313,"difficulty":"Medium","patterns":["Min Heap","Generation"],"url":"https://leetcode.com/problems/super-ugly-number/","note":"Extension of Ugly Number II. Min-heap with (val, primeIdx, uglyIdx). Or k-pointer approach. Dedup on poll."},{"id":46,"title":"Find the Kth Smallest Sum of a Matrix","num":1439,"difficulty":"Hard","patterns":["Merge K","Min Heap"],"url":"https://leetcode.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/","note":"Merge two rows at a time: min-heap of top-k sums between two sorted arrays. Repeat for each row. Binary search alternative."},{"id":47,"title":"Maximal Score After Applying K Operations","num":2530,"difficulty":"Medium","patterns":["Max Heap","Greedy"],"url":"https://leetcode.com/problems/maximal-score-after-applying-k-operations/","note":"Max-heap. K times: poll max, add to score, push ceil(val/3) back. Greedy always picks largest."},{"id":48,"title":"Closest Binary Search Tree Value II","num":272,"difficulty":"Hard","patterns":["Top-K","Min Heap","BST"],"url":"https://leetcode.com/problems/closest-binary-search-tree-value-ii/","note":"Max-heap of size k by distance from target. Inorder traverse BST, offer each, poll when > k. Or two-stack approach O(log n + k)."},{"id":49,"title":"Minimum Operations to Halve Array Sum","num":2208,"difficulty":"Medium","patterns":["Max Heap","Greedy"],"url":"https://leetcode.com/problems/minimum-operations-to-halve-array-sum/","note":"Max-heap (use doubles). Greedily halve the largest element. Track running reduction. Stop when ≥ half of original sum."},{"id":50,"title":"Dinner Plate Stacks","num":1172,"difficulty":"Hard","patterns":["Min Heap","Design"],"url":"https://leetcode.com/problems/dinner-plate-stacks/","note":"ArrayList<Stack> + min-heap of indices with available capacity. push: use leftmost available. pop: rightmost non-empty. popAtStack: direct."}]}],"dp":[{"name":"Tier 1 — 1D DP Foundations","color":"#e85d4a","description":"Master these first. Every DP problem builds on these patterns — understanding state, recurrence, and base cases. If you can solve these cleanly, you understand DP.","problems":[{"id":1,"title":"Climbing Stairs","num":70,"difficulty":"Easy","patterns":["Fibonacci","1D DP"],"url":"https://leetcode.com/problems/climbing-stairs/","note":"dp[i] = dp[i-1] + dp[i-2]. THE intro to DP. Optimize to O(1) space with two variables."},{"id":2,"title":"Min Cost Climbing Stairs","num":746,"difficulty":"Easy","patterns":["1D DP"],"url":"https://leetcode.com/problems/min-cost-climbing-stairs/","note":"dp[i] = cost[i] + Math.min(dp[i-1], dp[i-2]). Builds directly on Climbing Stairs with a cost array."},{"id":3,"title":"House Robber","num":198,"difficulty":"Medium","patterns":["1D DP","Decision"],"url":"https://leetcode.com/problems/house-robber/","note":"dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]). Classic take-or-skip pattern. Foundation for many DP problems."},{"id":4,"title":"House Robber II","num":213,"difficulty":"Medium","patterns":["1D DP","Circular"],"url":"https://leetcode.com/problems/house-robber-ii/","note":"Circular constraint: run House Robber twice — nums[0..n-2] and nums[1..n-1]. Take the max."},{"id":5,"title":"Maximum Subarray (Kadane's)","num":53,"difficulty":"Medium","patterns":["1D DP","Greedy"],"url":"https://leetcode.com/problems/maximum-subarray/","note":"dp[i] = Math.max(nums[i], dp[i-1] + nums[i]). Extend or restart. The most important subarray DP."},{"id":6,"title":"Decode Ways","num":91,"difficulty":"Medium","patterns":["1D DP","String"],"url":"https://leetcode.com/problems/decode-ways/","note":"dp[i] depends on single digit (1-9) and two digits (10-26). Watch for '0' edge cases — it's where most fail."},{"id":7,"title":"Coin Change","num":322,"difficulty":"Medium","patterns":["1D DP","Unbounded Knapsack"],"url":"https://leetcode.com/problems/coin-change/","note":"dp[amount] = min coins. For each coin, dp[i] = Math.min(dp[i], dp[i-coin] + 1). Init dp to amount+1 (impossible)."},{"id":8,"title":"Coin Change II","num":518,"difficulty":"Medium","patterns":["1D DP","Unbounded Knapsack"],"url":"https://leetcode.com/problems/coin-change-ii/","note":"Count combinations (not permutations). Outer loop = coins, inner loop = amounts. dp[0] = 1."},{"id":9,"title":"Longest Increasing Subsequence","num":300,"difficulty":"Medium","patterns":["1D DP","Binary Search"],"url":"https://leetcode.com/problems/longest-increasing-subsequence/","note":"O(n²): dp[i] = max length ending at i. O(n log n): maintain tails array + binary search. Know both."},{"id":10,"title":"Word Break","num":139,"difficulty":"Medium","patterns":["1D DP","String"],"url":"https://leetcode.com/problems/word-break/","note":"dp[i] = can s[0..i] be segmented? For each j < i, dp[i] = dp[j] && wordDict.contains(s[j..i]). Use HashSet."},{"id":11,"title":"Jump Game","num":55,"difficulty":"Medium","patterns":["1D DP","Greedy"],"url":"https://leetcode.com/problems/jump-game/","note":"Track maxReach. At each i, if i > maxReach → false. Update maxReach = Math.max(maxReach, i + nums[i]). Greedy is cleaner than DP."},{"id":12,"title":"Jump Game II","num":45,"difficulty":"Medium","patterns":["1D DP","Greedy","BFS"],"url":"https://leetcode.com/problems/jump-game-ii/","note":"BFS-style greedy: track current end and farthest. When i hits end, increment jumps and set end = farthest."}]},{"name":"Tier 2 — 1D DP Extended + Knapsack","color":"#d49a3e","description":"Builds on Tier 1 with subsequence problems, partition problems, and the 0/1 knapsack pattern. These are bread-and-butter interview DP.","problems":[{"id":13,"title":"Partition Equal Subset Sum","num":416,"difficulty":"Medium","patterns":["0/1 Knapsack","1D DP"],"url":"https://leetcode.com/problems/partition-equal-subset-sum/","note":"0/1 Knapsack: can we reach sum/2? boolean dp[sum/2+1]. Iterate backwards to avoid reuse. THE knapsack intro."},{"id":14,"title":"Target Sum","num":494,"difficulty":"Medium","patterns":["0/1 Knapsack","1D DP"],"url":"https://leetcode.com/problems/target-sum/","note":"Transform: find subset with sum = (total + target) / 2. Reduces to subset sum count. dp[j] += dp[j - num]."},{"id":15,"title":"Perfect Squares","num":279,"difficulty":"Medium","patterns":["Unbounded Knapsack","BFS"],"url":"https://leetcode.com/problems/perfect-squares/","note":"dp[i] = min squares summing to i. For each j² ≤ i: dp[i] = min(dp[i], dp[i-j²] + 1). BFS also works."},{"id":16,"title":"Combination Sum IV","num":377,"difficulty":"Medium","patterns":["1D DP","Permutation"],"url":"https://leetcode.com/problems/combination-sum-iv/","note":"Count permutations (order matters). Outer loop = target, inner loop = nums. Contrast with Coin Change II."},{"id":17,"title":"Longest Palindromic Substring","num":5,"difficulty":"Medium","patterns":["1D DP","Expand Around Center"],"url":"https://leetcode.com/problems/longest-palindromic-substring/","note":"Expand from center: O(n²). Try each i as center (odd) and each i,i+1 (even). DP also works but expansion is cleaner."},{"id":18,"title":"Palindromic Substrings","num":647,"difficulty":"Medium","patterns":["1D DP","Expand Around Center"],"url":"https://leetcode.com/problems/palindromic-substrings/","note":"Same expand-from-center as #5, but count all palindromes instead of tracking longest. O(n²)."},{"id":19,"title":"Maximum Product Subarray","num":152,"difficulty":"Medium","patterns":["1D DP"],"url":"https://leetcode.com/problems/maximum-product-subarray/","note":"Track both maxSoFar and minSoFar (negatives flip). At each step, swap if nums[i] < 0. Tricky edge cases."},{"id":20,"title":"Longest Common Subsequence (1D view)","num":1143,"difficulty":"Medium","patterns":["1D DP","Two Sequence"],"url":"https://leetcode.com/problems/longest-common-subsequence/","note":"Classic 2D but can optimize to 1D array. dp[j] = LCS of text1[0..i] and text2[0..j]. Save prev to handle diagonal."},{"id":21,"title":"Ugly Number II","num":264,"difficulty":"Medium","patterns":["1D DP","Three Pointers"],"url":"https://leetcode.com/problems/ugly-number-ii/","note":"Three pointers for factors 2, 3, 5. dp[i] = min(dp[p2]*2, dp[p3]*3, dp[p5]*5). Advance matching pointers."},{"id":22,"title":"Integer Break","num":343,"difficulty":"Medium","patterns":["1D DP","Math"],"url":"https://leetcode.com/problems/integer-break/","note":"dp[i] = max product. For j from 1: dp[i] = max(j*(i-j), j*dp[i-j]). Greedy: break into 3s is optimal."},{"id":23,"title":"Number of Longest Increasing Subsequence","num":673,"difficulty":"Medium","patterns":["1D DP","LIS"],"url":"https://leetcode.com/problems/number-of-longest-increasing-subsequence/","note":"Track both length[] and count[] arrays. If same length found, add to count. Builds on LIS pattern."},{"id":24,"title":"Delete and Earn","num":740,"difficulty":"Medium","patterns":["1D DP","House Robber"],"url":"https://leetcode.com/problems/delete-and-earn/","note":"Reduce to House Robber: group by value, sum points. Can't take adjacent values. dp[i] = max(dp[i-1], dp[i-2] + earn[i])."}]},{"name":"Tier 3 — 2D DP Core","color":"#5a9bd5","description":"Two-dimensional state problems: grids, two-string comparisons, and interval DP. These require thinking about state transitions in two dimensions.","problems":[{"id":25,"title":"Unique Paths","num":62,"difficulty":"Medium","patterns":["2D Grid","2D DP"],"url":"https://leetcode.com/problems/unique-paths/","note":"dp[i][j] = dp[i-1][j] + dp[i][j-1]. THE intro to 2D grid DP. Can optimize to 1D array. Also solvable with combinatorics."},{"id":26,"title":"Unique Paths II","num":63,"difficulty":"Medium","patterns":["2D Grid","2D DP"],"url":"https://leetcode.com/problems/unique-paths-ii/","note":"Same as Unique Paths but obstacles set dp[i][j] = 0. Be careful with first row/col initialization when obstacles present."},{"id":27,"title":"Minimum Path Sum","num":64,"difficulty":"Medium","patterns":["2D Grid","2D DP"],"url":"https://leetcode.com/problems/minimum-path-sum/","note":"dp[i][j] = grid[i][j] + Math.min(dp[i-1][j], dp[i][j-1]). Standard grid DP with min cost."},{"id":28,"title":"Triangle","num":120,"difficulty":"Medium","patterns":["2D DP","Bottom-Up"],"url":"https://leetcode.com/problems/triangle/","note":"Bottom-up is elegant: dp[j] = triangle[i][j] + Math.min(dp[j], dp[j+1]). O(n) space. Start from bottom row."},{"id":29,"title":"Maximal Square","num":221,"difficulty":"Medium","patterns":["2D Grid","2D DP"],"url":"https://leetcode.com/problems/maximal-square/","note":"dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 if cell is '1'. Track side length, not area."},{"id":30,"title":"Edit Distance","num":72,"difficulty":"Medium","patterns":["Two Sequence","2D DP"],"url":"https://leetcode.com/problems/edit-distance/","note":"dp[i][j] = min edits for word1[0..i] → word2[0..j]. Three operations: insert, delete, replace. Classic 2D sequence DP."},{"id":31,"title":"Longest Common Subsequence","num":1143,"difficulty":"Medium","patterns":["Two Sequence","2D DP"],"url":"https://leetcode.com/problems/longest-common-subsequence/","note":"If match: dp[i][j] = dp[i-1][j-1] + 1. Else: max(dp[i-1][j], dp[i][j-1]). The canonical two-sequence DP."},{"id":32,"title":"Interleaving String","num":97,"difficulty":"Medium","patterns":["Two Sequence","2D DP"],"url":"https://leetcode.com/problems/interleaving-string/","note":"dp[i][j] = can s1[0..i] and s2[0..j] form s3[0..i+j]? Check if current char matches from s1 or s2."},{"id":33,"title":"Distinct Subsequences","num":115,"difficulty":"Hard","patterns":["Two Sequence","2D DP"],"url":"https://leetcode.com/problems/distinct-subsequences/","note":"dp[i][j] = ways to form t[0..j] from s[0..i]. If match: dp[i-1][j-1] + dp[i-1][j]. Else: dp[i-1][j]."},{"id":34,"title":"Longest Palindromic Subsequence","num":516,"difficulty":"Medium","patterns":["Interval DP","2D DP"],"url":"https://leetcode.com/problems/longest-palindromic-subsequence/","note":"dp[i][j] = LPS in s[i..j]. If s[i]==s[j]: dp[i+1][j-1]+2. Else: max(dp[i+1][j], dp[i][j-1]). Fill diagonally."},{"id":35,"title":"Palindrome Partitioning II","num":132,"difficulty":"Hard","patterns":["Interval DP","1D DP"],"url":"https://leetcode.com/problems/palindrome-partitioning-ii/","note":"dp[i] = min cuts for s[0..i]. Precompute palindrome table. For each palindrome s[j..i], dp[i] = min(dp[j-1] + 1)."},{"id":36,"title":"Regular Expression Matching","num":10,"difficulty":"Hard","patterns":["Two Sequence","2D DP"],"url":"https://leetcode.com/problems/regular-expression-matching/","note":"dp[i][j] = does s[0..i] match p[0..j]? Handle '.' and '*'. '*' can match zero (dp[i][j-2]) or more (dp[i-1][j])."},{"id":37,"title":"Wildcard Matching","num":44,"difficulty":"Hard","patterns":["Two Sequence","2D DP"],"url":"https://leetcode.com/problems/wildcard-matching/","note":"Similar to regex but simpler. '?' matches one, '*' matches any sequence. dp[i][j] with careful '*' handling."}]},{"name":"Tier 4 — 2D DP Extended + Intervals","color":"#8a6bbf","description":"More complex 2D state problems including stock trading series, matrix chain patterns, and multi-state DP. Key FAANG interview problems.","problems":[{"id":38,"title":"Best Time to Buy and Sell Stock with Cooldown","num":309,"difficulty":"Medium","patterns":["State Machine","Multi-State DP"],"url":"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/","note":"Three states: held, sold, rest. Transitions: held = max(held, rest-price), sold = held+price, rest = max(rest, sold)."},{"id":39,"title":"Best Time to Buy and Sell Stock with Transaction Fee","num":714,"difficulty":"Medium","patterns":["State Machine","Multi-State DP"],"url":"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/","note":"Two states: cash (not holding) and hold. cash = max(cash, hold+price-fee), hold = max(hold, cash-price)."},{"id":40,"title":"Best Time to Buy and Sell Stock III","num":123,"difficulty":"Hard","patterns":["Multi-State DP","Stock"],"url":"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/","note":"At most 2 transactions. Track buy1, sell1, buy2, sell2. One pass: buy1=min(price), sell1=max(sell1, price-buy1), etc."},{"id":41,"title":"Best Time to Buy and Sell Stock IV","num":188,"difficulty":"Hard","patterns":["Multi-State DP","Stock"],"url":"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/","note":"Generalize Stock III to k transactions. dp[k][i] = max profit with k transactions up to day i. When k ≥ n/2, unlimited."},{"id":42,"title":"Minimum Cost to Cut a Stick","num":1547,"difficulty":"Hard","patterns":["Interval DP","2D DP"],"url":"https://leetcode.com/problems/minimum-cost-to-cut-a-stick/","note":"dp[i][j] = min cost to make all cuts between cuts[i] and cuts[j]. Try each cut point k in between. O(n³)."},{"id":43,"title":"Burst Balloons","num":312,"difficulty":"Hard","patterns":["Interval DP","2D DP"],"url":"https://leetcode.com/problems/burst-balloons/","note":"Think reverse: which balloon to burst LAST in range. dp[i][j] = max coins from balloons between i and j. O(n³)."},{"id":44,"title":"Minimum Score Triangulation of Polygon","num":1039,"difficulty":"Medium","patterns":["Interval DP","2D DP"],"url":"https://leetcode.com/problems/minimum-score-triangulation-of-polygon/","note":"dp[i][j] = min score for polygon from vertex i to j. Try each k as triangle vertex. Classic interval DP."},{"id":45,"title":"Stone Game","num":877,"difficulty":"Medium","patterns":["Interval DP","Game Theory"],"url":"https://leetcode.com/problems/stone-game/","note":"dp[i][j] = max score diff for player choosing from piles[i..j]. Minimax. (Math proof: first player always wins.)"},{"id":46,"title":"Ones and Zeroes","num":474,"difficulty":"Medium","patterns":["2D Knapsack","2D DP"],"url":"https://leetcode.com/problems/ones-and-zeroes/","note":"0/1 knapsack with two constraints (m zeros, n ones). dp[i][j] = max subsets with i zeros and j ones. Iterate backwards."},{"id":47,"title":"Last Stone Weight II","num":1049,"difficulty":"Medium","patterns":["0/1 Knapsack","2D DP"],"url":"https://leetcode.com/problems/last-stone-weight-ii/","note":"Reduce to: partition into two groups, minimize |sum1 - sum2|. Same as Partition Equal Subset Sum variant."},{"id":48,"title":"Dungeon Game","num":174,"difficulty":"Hard","patterns":["2D Grid","2D DP"],"url":"https://leetcode.com/problems/dungeon-game/","note":"Work BACKWARDS from bottom-right. dp[i][j] = min HP needed at (i,j). dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j])."},{"id":49,"title":"Maximal Rectangle","num":85,"difficulty":"Hard","patterns":["2D DP","Stack"],"url":"https://leetcode.com/problems/maximal-rectangle/","note":"Build histogram heights row by row. Apply Largest Rectangle in Histogram (monotonic stack) per row. O(mn)."}]},{"name":"Tier 5 — Advanced DP","color":"#569473","description":"Bitmask DP, digit DP, DP on trees, and other advanced patterns. Target these for Google/Meta-level interviews or competitive programming.","problems":[{"id":50,"title":"Partition to K Equal Sum Subsets","num":698,"difficulty":"Medium","patterns":["Bitmask DP","Backtracking"],"url":"https://leetcode.com/problems/partition-to-k-equal-sum-subsets/","note":"Bitmask DP: dp[mask] = can the selected elements be partitioned? Or backtracking with pruning. Bitmask is cleaner."},{"id":51,"title":"Shortest Path Visiting All Nodes","num":847,"difficulty":"Hard","patterns":["Bitmask DP","BFS"],"url":"https://leetcode.com/problems/shortest-path-visiting-all-nodes/","note":"BFS with state = (node, visited_mask). dp[mask][node] = min steps. Start BFS from all nodes simultaneously."},{"id":52,"title":"Minimum Cost to Connect Two Groups of Points","num":1595,"difficulty":"Hard","patterns":["Bitmask DP","2D DP"],"url":"https://leetcode.com/problems/minimum-cost-to-connect-two-groups-of-points/","note":"dp[i][mask] = min cost connecting first i points in group1, with mask of connected points in group2."},{"id":53,"title":"Profitable Schemes","num":879,"difficulty":"Hard","patterns":["Multi-Dimensional DP","Knapsack"],"url":"https://leetcode.com/problems/profitable-schemes/","note":"3D knapsack: dp[i][j][k] = schemes using i crimes, j members, k profit. Reduce to 2D with rolling array."},{"id":54,"title":"House Robber III","num":337,"difficulty":"Medium","patterns":["Tree DP","DFS"],"url":"https://leetcode.com/problems/house-robber-iii/","note":"DFS returns [rob_this, skip_this]. rob = val + left.skip + right.skip. skip = max(left) + max(right). Post-order."},{"id":55,"title":"Binary Trees With Factors","num":823,"difficulty":"Medium","patterns":["Tree DP","Hash Map"],"url":"https://leetcode.com/problems/binary-trees-with-factors/","note":"Sort array. dp[val] = number of trees rooted at val. For each pair (a, b) where a*b = val: dp[val] += dp[a]*dp[b]."},{"id":56,"title":"Minimum Cost Tree From Leaf Values","num":1130,"difficulty":"Medium","patterns":["Interval DP","Stack"],"url":"https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/","note":"Interval DP: dp[i][j] = min cost for leaves[i..j]. Greedy with monotonic stack is O(n). Pop smallest neighbor."},{"id":57,"title":"Longest Arithmetic Subsequence","num":1027,"difficulty":"Medium","patterns":["DP + HashMap"],"url":"https://leetcode.com/problems/longest-arithmetic-subsequence/","note":"dp[i] = HashMap<diff, length>. For each j < i: diff = nums[i]-nums[j], dp[i][diff] = dp[j].getOrDefault(diff,1)+1."},{"id":58,"title":"Frog Jump","num":403,"difficulty":"Hard","patterns":["DP + HashMap"],"url":"https://leetcode.com/problems/frog-jump/","note":"dp[stone] = Set of jump sizes that reached it. For each size k, try k-1, k, k+1 to next stones. Use HashMap."},{"id":59,"title":"Strange Printer","num":664,"difficulty":"Hard","patterns":["Interval DP"],"url":"https://leetcode.com/problems/strange-printer/","note":"dp[i][j] = min turns to print s[i..j]. If s[i]==s[k], merge intervals. dp[i][j] = min(dp[i][k] + dp[k+1][j] - 1)."},{"id":60,"title":"Number of Ways to Rearrange Sticks","num":1866,"difficulty":"Hard","patterns":["Combinatorics DP"],"url":"https://leetcode.com/problems/number-of-ways-to-rearrange-sticks-with-k-sticks-visible/","note":"dp[n][k] = ways. Tallest visible: dp[n-1][k-1]. Not visible: (n-1)*dp[n-1][k]. Stirling numbers connection."},{"id":61,"title":"Super Egg Drop","num":887,"difficulty":"Hard","patterns":["Binary Search","2D DP"],"url":"https://leetcode.com/problems/super-egg-drop/","note":"dp[k][m] = max floors testable with k eggs, m moves. dp[k][m] = dp[k-1][m-1] + dp[k][m-1] + 1. O(kn) optimal."}]}],"tries":[{"name":"Tier 1 — Trie Foundations","color":"#e85d4a","description":"Build the Trie from scratch and solve the classic prefix problems. If you can implement a Trie and use it for word search, you have the core down.","problems":[{"id":1,"title":"Implement Trie (Prefix Tree)","num":208,"difficulty":"Medium","patterns":["Trie","Design"],"url":"https://leetcode.com/problems/implement-trie-prefix-tree/","note":"TrieNode has children[26] + isEnd. insert/search/startsWith all walk the tree. THE foundation — implement this from memory."},{"id":2,"title":"Design Add and Search Words Data Structure","num":211,"difficulty":"Medium","patterns":["Trie","DFS"],"url":"https://leetcode.com/problems/design-add-and-search-words-data-structure/","note":"Trie + DFS for '.' wildcard. When '.', recurse on ALL children. Backtracking on the trie structure."},{"id":3,"title":"Word Search II","num":212,"difficulty":"Hard","patterns":["Trie","Backtracking"],"url":"https://leetcode.com/problems/word-search-ii/","note":"Build trie from words, DFS on grid with trie pruning. Remove found words (prune trie) to avoid TLE. THE trie interview problem."},{"id":4,"title":"Longest Common Prefix","num":14,"difficulty":"Easy","patterns":["Trie","String"],"url":"https://leetcode.com/problems/longest-common-prefix/","note":"Trie approach: insert all, walk until branch or end. Simpler: vertical scan char-by-char. Know both methods."},{"id":5,"title":"Replace Words","num":648,"difficulty":"Medium","patterns":["Trie","String"],"url":"https://leetcode.com/problems/replace-words/","note":"Build trie from dictionary roots. For each word, walk trie — if isEnd reached, replace with root. Classic prefix replacement."},{"id":6,"title":"Map Sum Pairs","num":677,"difficulty":"Medium","patterns":["Trie","Design"],"url":"https://leetcode.com/problems/map-sum-pairs/","note":"Trie where each node stores prefix sum. On insert, update delta along path. sum() walks to prefix node and returns val."},{"id":7,"title":"Search Suggestions System","num":1268,"difficulty":"Medium","patterns":["Trie","DFS"],"url":"https://leetcode.com/problems/search-suggestions-system/","note":"Trie + DFS to collect top 3 lexicographic matches per prefix. Or sort + binary search. Trie is the intended approach."}]},{"name":"Tier 2 — Trie Applications + Bit Trie","color":"#d49a3e","description":"Harder trie applications: XOR problems with bit tries, stream matching, and trie-powered optimizations. These separate trie users from trie masters.","problems":[{"id":8,"title":"Maximum XOR of Two Numbers in an Array","num":421,"difficulty":"Medium","patterns":["Bit Trie","Bitwise"],"url":"https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/","note":"Binary trie (0/1 children). Insert all nums. For each num, greedily take opposite bit. O(32n). THE bit trie problem."},{"id":9,"title":"Stream of Characters","num":1032,"difficulty":"Hard","patterns":["Trie","Design"],"url":"https://leetcode.com/problems/stream-of-characters/","note":"Reverse trie: insert words backwards. On query, check suffixes of stream against reversed trie. Elegant inversion."},{"id":10,"title":"Palindrome Pairs","num":336,"difficulty":"Hard","patterns":["Trie","Palindrome"],"url":"https://leetcode.com/problems/palindrome-pairs/","note":"Build trie of reversed words. For each word, check: (1) longer reversed prefix in trie, (2) shorter reversed word + palindrome suffix. Tricky edge cases."},{"id":11,"title":"Word Search","num":79,"difficulty":"Medium","patterns":["Backtracking","Grid"],"url":"https://leetcode.com/problems/word-search/","note":"DFS backtracking on grid. Mark visited, check bounds + match. Prerequisite for Word Search II. No trie needed for single word."},{"id":12,"title":"Implement Magic Dictionary","num":676,"difficulty":"Medium","patterns":["Trie","DFS"],"url":"https://leetcode.com/problems/implement-magic-dictionary/","note":"Trie + DFS with exactly-one-mismatch counter. At each node, try changing exactly one character. Track changes made."},{"id":13,"title":"Concatenated Words","num":472,"difficulty":"Hard","patterns":["Trie","DP"],"url":"https://leetcode.com/problems/concatenated-words/","note":"Trie + DP/DFS: for each word, check if it can be decomposed into 2+ words in trie. Sort by length first."},{"id":14,"title":"Maximum XOR With an Element From Array","num":1707,"difficulty":"Hard","patterns":["Bit Trie","Offline"],"url":"https://leetcode.com/problems/maximum-xor-with-an-element-from-array/","note":"Sort queries by limit. Add elements ≤ limit to bit trie. Answer each query greedily. Offline processing key."}]},{"name":"Tier 3 — Union-Find (Disjoint Sets)","color":"#5a9bd5","description":"Union-Find is the go-to for connectivity, component counting, and dynamic graph problems. Path compression + union by rank gives near O(1) operations.","problems":[{"id":15,"title":"Number of Provinces","num":547,"difficulty":"Medium","patterns":["Union-Find","DFS"],"url":"https://leetcode.com/problems/number-of-provinces/","note":"Count connected components. Union-Find or DFS/BFS both work. UF: components = n - (number of successful unions)."},{"id":16,"title":"Redundant Connection","num":684,"difficulty":"Medium","patterns":["Union-Find","Cycle"],"url":"https://leetcode.com/problems/redundant-connection/","note":"Process edges in order. If find(u) == find(v), this edge creates cycle → return it. Classic UF cycle detection."},{"id":17,"title":"Accounts Merge","num":721,"difficulty":"Medium","patterns":["Union-Find","Hash Map"],"url":"https://leetcode.com/problems/accounts-merge/","note":"Union emails that share an account. Map email → first email in account. Group by root, sort, attach name. UF + HashMap."},{"id":18,"title":"Number of Connected Components in Undirected Graph","num":323,"difficulty":"Medium","patterns":["Union-Find","DFS"],"url":"https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/","note":"Start with n components. Each successful union decrements count. Or DFS counting connected components."},{"id":19,"title":"Graph Valid Tree","num":261,"difficulty":"Medium","patterns":["Union-Find","Cycle"],"url":"https://leetcode.com/problems/graph-valid-tree/","note":"Tree = connected + no cycles. UF: if any union fails (same root), cycle exists. Also check edges == n-1."},{"id":20,"title":"Surrounded Regions","num":130,"difficulty":"Medium","patterns":["Union-Find","DFS"],"url":"https://leetcode.com/problems/surrounded-regions/","note":"Union border 'O's with dummy node. Any 'O' not connected to dummy gets flipped. Or DFS from borders."},{"id":21,"title":"Satisfiability of Equality Equations","num":990,"difficulty":"Medium","patterns":["Union-Find"],"url":"https://leetcode.com/problems/satisfiability-of-equality-equations/","note":"First pass: union all '==' pairs. Second pass: check all '!=' pairs aren't in same set. Two-pass UF."},{"id":22,"title":"Longest Consecutive Sequence","num":128,"difficulty":"Medium","patterns":["Union-Find","Hash Set"],"url":"https://leetcode.com/problems/longest-consecutive-sequence/","note":"UF approach: union num with num+1 if exists. Track component sizes. HashSet approach is simpler for this one."},{"id":23,"title":"Number of Islands","num":200,"difficulty":"Medium","patterns":["Union-Find","DFS"],"url":"https://leetcode.com/problems/number-of-islands/","note":"UF: union adjacent '1' cells. Count remaining roots. DFS/BFS is more intuitive but UF extends to streaming."},{"id":24,"title":"Redundant Connection II","num":685,"difficulty":"Hard","patterns":["Union-Find","Directed"],"url":"https://leetcode.com/problems/redundant-connection-ii/","note":"Directed graph: check for node with 2 parents + cycle. Three cases. Much harder than Redundant Connection I."},{"id":25,"title":"Number of Operations to Make Network Connected","num":1319,"difficulty":"Medium","patterns":["Union-Find"],"url":"https://leetcode.com/problems/number-of-operations-to-make-network-connected/","note":"Need n-1 edges minimum. Count components with UF. Extra edges = total - (n - components). If enough extras, answer = components - 1."}]},{"name":"Tier 4 — Segment Trees, BIT & Range Queries","color":"#8a6bbf","description":"When you need range queries + point updates in O(log n). Segment trees and Binary Indexed Trees are the workhorses. FAANG-level and competitive programming.","problems":[{"id":26,"title":"Range Sum Query — Mutable","num":307,"difficulty":"Medium","patterns":["BIT","Segment Tree"],"url":"https://leetcode.com/problems/range-sum-query-mutable/","note":"BIT (Fenwick Tree): update O(log n), query O(log n). Or segment tree. THE intro to range query structures."},{"id":27,"title":"Count of Smaller Numbers After Self","num":315,"difficulty":"Hard","patterns":["BIT","Merge Sort"],"url":"https://leetcode.com/problems/count-of-smaller-numbers-after-self/","note":"Coordinate compress + BIT. Process right-to-left, query count < current, then update. Or merge sort with index tracking."},{"id":28,"title":"Count of Range Sum","num":327,"difficulty":"Hard","patterns":["BIT","Merge Sort"],"url":"https://leetcode.com/problems/count-of-range-sum/","note":"Prefix sums + merge sort counting valid pairs. Or BIT with coordinate compression on prefix sums."},{"id":29,"title":"My Calendar I","num":729,"difficulty":"Medium","patterns":["Segment Tree","TreeMap"],"url":"https://leetcode.com/problems/my-calendar-i/","note":"TreeMap: floorKey/ceilingKey to check overlap. Or segment tree with lazy propagation for interval booking."},{"id":30,"title":"My Calendar III","num":732,"difficulty":"Hard","patterns":["Segment Tree","Sweep Line"],"url":"https://leetcode.com/problems/my-calendar-iii/","note":"Segment tree with lazy propagation for range add + range max. Or sweep line with TreeMap for simpler approach."},{"id":31,"title":"Reverse Pairs","num":493,"difficulty":"Hard","patterns":["BIT","Merge Sort"],"url":"https://leetcode.com/problems/reverse-pairs/","note":"Modified merge sort: count pairs where nums[i] > 2*nums[j] during merge. Or BIT with coordinate compression."},{"id":32,"title":"The Skyline Problem","num":218,"difficulty":"Hard","patterns":["Segment Tree","Sweep Line","Heap"],"url":"https://leetcode.com/problems/the-skyline-problem/","note":"Sweep line + max-heap (TreeMap for lazy deletion). Process events left-to-right, track max height changes."},{"id":33,"title":"Longest Increasing Subsequence II","num":2407,"difficulty":"Hard","patterns":["Segment Tree","DP"],"url":"https://leetcode.com/problems/longest-increasing-subsequence-ii/","note":"Segment tree for range max query on dp values. dp[v] = 1 + maxQuery(v-k, v-1). Update segment tree after each element."},{"id":34,"title":"Range Module","num":715,"difficulty":"Hard","patterns":["Segment Tree","TreeMap"],"url":"https://leetcode.com/problems/range-module/","note":"Segment tree with lazy propagation. Or TreeMap of intervals with merge/split logic. Complex but clean with TreeMap."}]},{"name":"Tier 5 — Greedy, Math & Specialized","color":"#569473","description":"Advanced greedy strategies, number theory, geometry, and patterns that don't fit neatly elsewhere. These round out a complete preparation.","problems":[{"id":35,"title":"Task Scheduler","num":621,"difficulty":"Medium","patterns":["Greedy","Math"],"url":"https://leetcode.com/problems/task-scheduler/","note":"Math: (maxFreq - 1) * (n + 1) + countOfMax. Or simulate with max-heap. The greedy insight is about idle slots."},{"id":36,"title":"Non-overlapping Intervals","num":435,"difficulty":"Medium","patterns":["Greedy","Sort"],"url":"https://leetcode.com/problems/non-overlapping-intervals/","note":"Sort by end time. Greedily keep interval with earliest end. Classic activity selection. Remove = total - kept."},{"id":37,"title":"Merge Intervals","num":56,"difficulty":"Medium","patterns":["Greedy","Sort"],"url":"https://leetcode.com/problems/merge-intervals/","note":"Sort by start. If overlap, merge by extending end. result.get(last)[1] = Math.max(end, current end). One pass after sort."},{"id":38,"title":"Meeting Rooms II","num":253,"difficulty":"Medium","patterns":["Greedy","Heap","Sweep Line"],"url":"https://leetcode.com/problems/meeting-rooms-ii/","note":"Min-heap of end times. Sort by start. If start ≥ heap.peek(), reuse room (poll). Else add new. Heap size = rooms."},{"id":39,"title":"Gas Station","num":134,"difficulty":"Medium","patterns":["Greedy"],"url":"https://leetcode.com/problems/gas-station/","note":"If total gas ≥ total cost, solution exists. Track running surplus — when it goes negative, restart from next station."},{"id":40,"title":"Candy","num":135,"difficulty":"Hard","patterns":["Greedy"],"url":"https://leetcode.com/problems/candy/","note":"Two passes: left-to-right (ascending), right-to-left (descending). Take max of both passes. Each child gets max of both constraints."},{"id":41,"title":"Minimum Number of Arrows to Burst Balloons","num":452,"difficulty":"Medium","patterns":["Greedy","Sort"],"url":"https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/","note":"Sort by end. Shoot at each end point. Skip balloons that overlap with current arrow. Same as activity selection."},{"id":42,"title":"Count Primes","num":204,"difficulty":"Medium","patterns":["Math","Sieve"],"url":"https://leetcode.com/problems/count-primes/","note":"Sieve of Eratosthenes. boolean[n], mark composites. Start from i*i. Count remaining trues. O(n log log n)."},{"id":43,"title":"Pow(x, n)","num":50,"difficulty":"Medium","patterns":["Math","Binary Exponentiation"],"url":"https://leetcode.com/problems/powx-n/","note":"Fast power: if n even, x^n = (x^(n/2))². If odd, multiply by x. Handle n = Integer.MIN_VALUE edge case."},{"id":44,"title":"Sqrt(x)","num":69,"difficulty":"Easy","patterns":["Math","Binary Search"],"url":"https://leetcode.com/problems/sqrtx/","note":"Binary search on [0, x]. If mid*mid <= x, move left up. Use long to avoid overflow. Or Newton's method."},{"id":45,"title":"Largest Rectangle in Histogram","num":84,"difficulty":"Hard","patterns":["Monotonic Stack"],"url":"https://leetcode.com/problems/largest-rectangle-in-histogram/","note":"Monotonic increasing stack of indices. On pop, width = i - stack.peek() - 1. THE monotonic stack problem."},{"id":46,"title":"Median of Two Sorted Arrays","num":4,"difficulty":"Hard","patterns":["Binary Search","Math"],"url":"https://leetcode.com/problems/median-of-two-sorted-arrays/","note":"Binary search on shorter array. Partition both so left halves ≤ right halves. O(log min(m,n)). Extremely tricky."},{"id":47,"title":"Kth Largest Element in an Array","num":215,"difficulty":"Medium","patterns":["Quickselect","Heap"],"url":"https://leetcode.com/problems/kth-largest-element-in-an-array/","note":"Quickselect: avg O(n). Partition, recurse on correct half. Or min-heap of size k for O(n log k). Know both."}]}]};
const GUIDES = {"arrays-strings":{"sections":["Two Pointers","Sliding Window","Prefix Sums","Pattern Recognition","Formulas & Tips","Revision Cards"],"patterns":[{"name":"TWO_POINTERS","overview":"Two pointers is a technique where you maintain two index references that move through the data structure — typically an array or string — to solve problems in O(n) that would otherwise take O(n²).","variants":[{"name":"Opposite Ends","description":"One pointer starts at the beginning, the other at the end. They move toward each other.","when":"Sorted arrays, palindromes, pair sums, container problems.","template":"public static void oppositeEnds(int[] arr, int target) {\n    int left = 0, right = arr.length - 1;\n    while (left < right) {\n        int sum = arr[left] + arr[right];\n        if (sum < target) {\n            left++;            // need bigger sum\n        } else if (sum > target) {\n            right--;           // need smaller sum\n        } else {\n            // found it\n            break;\n        }\n    }\n}","problems":[{"name":"Two Sum II (sorted)","hint":"If sum < target, move left++. If sum > target, move right--."},{"name":"Valid Palindrome","hint":"Compare s.charAt(left) vs s.charAt(right), skip non-alphanumeric with Character.isLetterOrDigit()."},{"name":"Container With Most Water","hint":"Area = Math.min(h[l], h[r]) × (r - l). Move the shorter side inward."},{"name":"3Sum","hint":"Arrays.sort(). Fix one element, two-pointer on the rest. Skip duplicates."}]},{"name":"Same Direction (Fast & Slow)","description":"Both pointers start at the beginning. The fast pointer explores ahead while the slow pointer marks a position.","when":"Removing duplicates in-place, partitioning, linked list cycle detection.","template":"public static int sameDirection(int[] arr) {\n    int slow = 0;\n    for (int fast = 0; fast < arr.length; fast++) {\n        if (/* arr[fast] meets condition */) {\n            arr[slow] = arr[fast];\n            slow++;\n        }\n    }\n    return slow; // new length\n}","problems":[{"name":"Remove Duplicates from Sorted Array","hint":"slow tracks unique position. If arr[fast] != arr[slow], copy and advance slow."},{"name":"Move Zeroes","hint":"slow tracks next non-zero position. Swap arr[slow] and arr[fast] when fast finds non-zero."},{"name":"Remove Element","hint":"Same as move zeroes but skip target value."},{"name":"Sort Colors (Dutch National Flag)","hint":"Three pointers: low, mid, high. Swap 0s left, 2s right."}]},{"name":"Merge Pattern","description":"Two pointers on two different sorted arrays/lists, advancing the smaller one.","when":"Merging sorted arrays, intersection, comparing sequences.","template":"public static int[] merge(int[] arr1, int[] arr2) {\n    int i = 0, j = 0, k = 0;\n    int[] result = new int[arr1.length + arr2.length];\n\n    while (i < arr1.length && j < arr2.length) {\n        if (arr1[i] <= arr2[j]) result[k++] = arr1[i++];\n        else                     result[k++] = arr2[j++];\n    }\n    // append remaining\n    while (i < arr1.length) result[k++] = arr1[i++];\n    while (j < arr2.length) result[k++] = arr2[j++];\n    return result;\n}","problems":[{"name":"Merge Sorted Array","hint":"Merge from the end to avoid extra space. Start filling from index m + n - 1."},{"name":"Intersection of Two Arrays II","hint":"Sort both, advance smaller pointer. If equal, add to result, advance both."},{"name":"Is Subsequence","hint":"Pointer on s and t. If match, advance s pointer. Always advance t."}]}]},{"name":"SLIDING_WINDOW","overview":"Sliding window maintains a contiguous subarray/substring window that expands and shrinks to find optimal results. It reduces brute-force O(n·k) or O(n²) down to O(n).","variants":[{"name":"Fixed-Size Window","description":"Window size k is known. Slide it across, updating the result as elements enter and leave.","when":"Maximum/minimum/average of all subarrays of size k.","template":"public static int fixedWindow(int[] arr, int k) {\n    int windowSum = 0, maxSum = Integer.MIN_VALUE;\n    for (int i = 0; i < arr.length; i++) {\n        windowSum += arr[i];              // add incoming\n        if (i >= k) {\n            windowSum -= arr[i - k];      // remove outgoing\n        }\n        if (i >= k - 1) {\n            maxSum = Math.max(maxSum, windowSum);\n        }\n    }\n    return maxSum;\n}","problems":[{"name":"Max Sum Subarray of Size K","hint":"Maintain running sum, subtract leftmost as window slides."},{"name":"Find All Anagrams in a String","hint":"Fixed window of length p. Use frequency array int[26], compare counts."},{"name":"Sliding Window Maximum","hint":"Use a monotonic ArrayDeque<Integer> to track max indices in window."}]},{"name":"Variable-Size Window (Expand/Shrink)","description":"Window size is dynamic. Expand right to include more, shrink left when constraint is violated.","when":"Longest/shortest subarray with a condition, at most K distinct, minimum size subarray sum.","template":"public static int variableWindow(int[] arr, int target) {\n    int left = 0, result = 0;\n    // windowState = initial state (e.g., int sum = 0)\n\n    for (int right = 0; right < arr.length; right++) {\n        // EXPAND: add arr[right] to window state\n\n        while (/* window violates constraint */) {\n            // SHRINK: remove arr[left] from window state\n            left++;\n        }\n\n        // UPDATE: result = Math.max/min(result, right - left + 1)\n        result = Math.max(result, right - left + 1);\n    }\n    return result;\n}","problems":[{"name":"Longest Substring Without Repeating Characters","hint":"HashSet<Character> or int[128] tracks chars in window. Shrink left until no duplicate."},{"name":"Minimum Size Subarray Sum","hint":"Expand until sum >= target, then shrink to minimize length."},{"name":"Longest Substring with At Most K Distinct Characters","hint":"HashMap<Character, Integer> tracks char frequency. Shrink when map.size() > K."},{"name":"Minimum Window Substring","hint":"Expand to include all chars of t. Shrink to minimize. Track 'formed' count."}]},{"name":"String Frequency Window","description":"Specialized for string matching — use a frequency array (size 26 or 128) to compare window contents.","when":"Anagram finding, permutation in string, character frequency matching.","template":"public static List<Integer> freqWindow(String s, String p) {\n    int[] need = new int[26], have = new int[26];\n    for (char c : p.toCharArray()) need[c - 'a']++;\n\n    int left = 0, matches = 0;\n    int uniqueNeeded = 0;\n    for (int n : need) if (n > 0) uniqueNeeded++;\n\n    List<Integer> result = new ArrayList<>();\n\n    for (int right = 0; right < s.length(); right++) {\n        int rIdx = s.charAt(right) - 'a';\n        have[rIdx]++;\n        if (have[rIdx] == need[rIdx]) matches++;\n\n        if (right - left + 1 > p.length()) {\n            int lIdx = s.charAt(left) - 'a';\n            if (have[lIdx] == need[lIdx]) matches--;\n            have[lIdx]--;\n            left++;\n        }\n\n        if (matches == uniqueNeeded) {\n            result.add(left);\n        }\n    }\n    return result;\n}","problems":[{"name":"Find All Anagrams","hint":"Fixed window of p.length(). Track how many unique char frequencies match."},{"name":"Permutation in String","hint":"Same as anagrams but return true/false."}]}]},{"name":"PREFIX_SUMS","overview":"Prefix sums precompute cumulative sums so that any subarray sum can be answered in O(1). The prefix array stores prefix[i] = sum of elements from index 0 to i-1.","variants":[{"name":"1D Prefix Sum","description":"Cumulative sum for range queries on a flat array.","when":"","template":"","problems":[{"name":"Range Sum Query","hint":"Precompute prefix. Answer queries as prefix[r+1] - prefix[l]."},{"name":"Subarray Sum Equals K","hint":"prefix[j] - prefix[i] = k → for each j, check if (prefix[j] - k) exists in a HashMap."},{"name":"Contiguous Array (0s and 1s)","hint":"Replace 0 with -1. Use prefix sum + HashMap for first occurrence."},{"name":"Product of Array Except Self","hint":"Left prefix product × right suffix product. No division needed."}]},{"name":"2D Prefix Sum","description":"Cumulative sum over a matrix. Enables O(1) submatrix sum queries.","when":"","template":"","problems":[{"name":"Range Sum Query 2D","hint":"Build 2D prefix. Use inclusion-exclusion for rectangular regions."},{"name":"Matrix Block Sum","hint":"2D prefix sum, query centered around each cell with Math.min/max for bounds."}]},{"name":"Prefix Sum + Hash Map","description":"The most powerful combo: use a HashMap to store previously seen prefix sums for O(n) subarray problems.","when":"","template":"public static int subarraySumK(int[] arr, int k) {\n    Map<Integer, Integer> map = new HashMap<>();\n    map.put(0, 1);  // prefix 0 seen once\n    int prefix = 0, count = 0;\n\n    for (int num : arr) {\n        prefix += num;\n        // If (prefix - k) was a previous prefix sum,\n        // there's a subarray summing to k\n        if (map.containsKey(prefix - k)) {\n            count += map.get(prefix - k);\n        }\n        map.put(prefix, map.getOrDefault(prefix, 0) + 1);\n    }\n    return count;\n}","problems":[{"name":"Subarray Sum Equals K","hint":"HashMap of prefix frequencies. For each prefix, check if (prefix - k) exists."},{"name":"Continuous Subarray Sum (multiple of k)","hint":"Store prefix % k → first index. If same remainder seen, length ≥ 2 means valid."},{"name":"Subarray Sums Divisible by K","hint":"Count prefix sums with same (prefix % k). Handle negative remainders with ((prefix % k) + k) % k."}]},{"name":"Difference Array","description":"The inverse of prefix sums. Apply range updates in O(1) each, then reconstruct with one prefix sum pass.","when":"","template":"// Range update: add val to arr[l..r]\ndiff[l] += val;\nif (r + 1 < diff.length) diff[r + 1] -= val;\n\n// Reconstruct after all updates\nfor (int i = 1; i < diff.length; i++) {\n    diff[i] += diff[i - 1];\n}","problems":[{"name":"Corporate Flight Bookings","hint":"Difference array. For booking [l, r, seats], diff[l] += seats, diff[r+1] -= seats."},{"name":"Car Pooling","hint":"Difference array over time. Add passengers at start, remove at end."}]}]}]},"hashmap":{"sections":["Frequency Counting","Two Sum Variants","Advanced Patterns","Pattern Recognition","Formulas & Tips","Revision Cards"],"patterns":[{"name":"FREQUENCY_COUNTING","overview":"Frequency counting uses a HashMap (or int[] for bounded sets like lowercase letters) to tally element occurrences. It transforms comparison-heavy O(n²) problems into single-pass O(n) solutions by converting 'does this exist?' or 'how many times?' into O(1) lookups.","variants":[{"name":"Basic Frequency Map","description":"Count occurrences of each element. The foundation of almost every hash map technique.","when":"Anagrams, duplicates, majority element, character matching, mode finding.","template":"// Generic frequency counting\nMap<Character, Integer> freq = new HashMap<>();\nfor (char c : s.toCharArray()) {\n    freq.merge(c, 1, Integer::sum);\n    // or: freq.put(c, freq.getOrDefault(c, 0) + 1);\n}\n\n// int[26] for lowercase letters (faster)\nint[] freq = new int[26];\nfor (char c : s.toCharArray()) {\n    freq[c - 'a']++;\n}","problems":[{"name":"Valid Anagram (#242)","hint":"Increment for s, decrement for t. Check all zeros. Or sort both and compare."},{"name":"First Unique Character (#387)","hint":"Build frequency map. Second pass: return first char with freq == 1."},{"name":"Contains Duplicate (#217)","hint":"HashSet.add() returns false if already present. One-liner: return set.size() != arr.length."},{"name":"Majority Element (#169)","hint":"HashMap freq count, or Boyer-Moore voting: maintain candidate + count."}]},{"name":"Frequency Comparison","description":"Compare two frequency maps — either directly or by incrementing one and decrementing the other.","when":"Anagram checks, permutation verification, ransom note, matching character sets.","template":"// Single-map technique: increment for s, decrement for t\npublic static boolean isAnagram(String s, String t) {\n    if (s.length() != t.length()) return false;\n    int[] count = new int[26];\n    for (int i = 0; i < s.length(); i++) {\n        count[s.charAt(i) - 'a']++;\n        count[t.charAt(i) - 'a']--;\n    }\n    for (int c : count) {\n        if (c != 0) return false;\n    }\n    return true;\n}","problems":[{"name":"Ransom Note (#383)","hint":"Build freq from magazine. For each char in ransomNote, decrement. If any goes negative, return false."},{"name":"Find All Anagrams (#438)","hint":"Sliding window of p.length(). int[26] + match counter. Already covered in Sliding Window — it's a crossover."},{"name":"Isomorphic Strings (#205)","hint":"Two maps: s→t and t→s. Each char in s must always map to the same char in t, and vice versa."},{"name":"Word Pattern (#290)","hint":"Same as isomorphic strings but with words. HashMap<Character, String> and HashMap<String, Character>."}]},{"name":"Frequency as Grouping Key","description":"Use a derived key from frequency data to group elements. The key can be a sorted string, a frequency signature, or a canonical form.","when":"Group anagrams, group shifted strings, find duplicates by structure.","template":"// Group Anagrams: sorted string as key\npublic static List<List<String>> groupAnagrams(String[] strs) {\n    Map<String, List<String>> map = new HashMap<>();\n    for (String s : strs) {\n        char[] chars = s.toCharArray();\n        Arrays.sort(chars);\n        String key = new String(chars);\n        map.computeIfAbsent(key, k -> new ArrayList<>()).add(s);\n    }\n    return new ArrayList<>(map.values());\n}\n\n// Alternative: frequency signature as key (avoids sorting)\n// key = \"#2#1#0#0#...\" where each number is count of a,b,c,...","problems":[{"name":"Group Anagrams (#49)","hint":"Sorted string key: O(n·k·log k). Frequency key: O(n·k). Both use HashMap<String, List<String>>."},{"name":"Group Shifted Strings (#249)","hint":"Normalize by shifting first char to 'a'. Key = difference sequence. Handle negative with +26 % 26."},{"name":"Find Duplicate File in System (#609)","hint":"Extract content between ( and ). Key = content, value = list of file paths."}]},{"name":"Top-K / Bucket Sort by Frequency","description":"After counting frequencies, find the K most/least frequent elements. Use a heap or bucket sort.","when":"Top K frequent elements, sort by frequency, K most common words.","template":"// Bucket sort approach: O(n) — better than heap O(n log k)\npublic static int[] topKFrequent(int[] nums, int k) {\n    Map<Integer, Integer> freq = new HashMap<>();\n    for (int n : nums) freq.merge(n, 1, Integer::sum);\n\n    // Bucket: index = frequency, value = list of nums with that freq\n    List<Integer>[] buckets = new List[nums.length + 1];\n    for (var entry : freq.entrySet()) {\n        int f = entry.getValue();\n        if (buckets[f] == null) buckets[f] = new ArrayList<>();\n        buckets[f].add(entry.getKey());\n    }\n\n    int[] result = new int[k];\n    int idx = 0;\n    for (int i = buckets.length - 1; i >= 0 && idx < k; i--) {\n        if (buckets[i] != null) {\n            for (int num : buckets[i]) {\n                if (idx < k) result[idx++] = num;\n            }\n        }\n    }\n    return result;\n}","problems":[{"name":"Top K Frequent Elements (#347)","hint":"Bucket sort O(n) or PriorityQueue O(n log k). Bucket index = frequency."},{"name":"Sort Characters by Frequency (#451)","hint":"Frequency map → bucket sort → build string from highest frequency bucket down."},{"name":"Top K Frequent Words (#692)","hint":"Same as top-K but break ties alphabetically. PriorityQueue with custom comparator."}]}]},{"name":"TWO_SUM_VARIANTS","overview":"Two Sum is the most fundamental HashMap pattern: for each element, check if its complement exists. This idea extends to dozens of variations — different data structures, multiple sums, continuous subarrays, and more.","variants":[{"name":"Classic Two Sum","description":"Given an array, find two elements that sum to a target. HashMap stores value → index for O(1) complement lookup.","when":"Find a pair with a specific sum. Unsorted array, need indices.","template":"public static int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        int complement = target - nums[i];\n        if (map.containsKey(complement)) {\n            return new int[] { map.get(complement), i };\n        }\n        map.put(nums[i], i);\n    }\n    return new int[] {}; // no solution\n}","problems":[{"name":"Two Sum (#1)","hint":"One pass. For each num, check if (target - num) is in the map. Store num → index."},{"name":"Two Sum II – Sorted (#167)","hint":"Sorted → use two pointers instead. No hash map needed. O(1) space."},{"name":"Two Sum III – Data Structure (#170)","hint":"Design class with add() and find(). HashMap<Integer, Integer> for counts. Handle num == complement edge case."},{"name":"Two Sum IV – BST (#653)","hint":"BFS/DFS the tree + HashSet. For each node, check if (k - node.val) exists in set."}]},{"name":"K-Sum Extensions","description":"Extend two-sum to 3Sum, 4Sum, and beyond. Reduce K-Sum to (K-1)-Sum recursively, with two-sum as base case.","when":"Find triplets, quadruplets summing to target. Usually requires sorting + two pointers.","template":"// 3Sum = sort + fix one + two pointer\npublic static List<List<Integer>> threeSum(int[] nums) {\n    Arrays.sort(nums);\n    List<List<Integer>> result = new ArrayList<>();\n\n    for (int i = 0; i < nums.length - 2; i++) {\n        if (i > 0 && nums[i] == nums[i - 1]) continue; // skip dup\n\n        int left = i + 1, right = nums.length - 1;\n        while (left < right) {\n            int sum = nums[i] + nums[left] + nums[right];\n            if (sum < 0) left++;\n            else if (sum > 0) right--;\n            else {\n                result.add(List.of(nums[i], nums[left], nums[right]));\n                left++;\n                right--;\n                while (left < right && nums[left] == nums[left - 1]) left++;\n            }\n        }\n    }\n    return result;\n}\n\n// 4Sum II (different arrays) — pure HashMap\n// Count a+b frequencies, check if -(c+d) exists\npublic static int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int a : A)\n        for (int b : B)\n            map.merge(a + b, 1, Integer::sum);\n\n    int count = 0;\n    for (int c : C)\n        for (int d : D)\n            count += map.getOrDefault(-(c + d), 0);\n    return count;\n}","problems":[{"name":"3Sum (#15)","hint":"Sort + fix one + two pointers. Skip duplicates at all three levels. O(n²)."},{"name":"3Sum Closest (#16)","hint":"Same structure as 3Sum. Track closest sum with Math.abs(sum - target)."},{"name":"4Sum (#18)","hint":"Fix two + two pointers. Or recursive K-Sum. Use (long) to avoid overflow."},{"name":"4Sum II (#454)","hint":"Split into two halves: A+B and C+D. HashMap on first half. O(n²) time and space."}]},{"name":"Complement / Pair Counting","description":"Count pairs satisfying a condition, or check if a complement exists. The map stores elements you've seen so far.","when":"Count good pairs, check pair divisibility, find symmetric pairs.","template":"// Count pairs where nums[i] == nums[j] and i < j\npublic static int numGoodPairs(int[] nums) {\n    Map<Integer, Integer> freq = new HashMap<>();\n    int count = 0;\n    for (int num : nums) {\n        // Every previous occurrence can form a pair with current\n        count += freq.getOrDefault(num, 0);\n        freq.merge(num, 1, Integer::sum);\n    }\n    return count;\n}\n// Math insight: if a value appears k times, pairs = k*(k-1)/2","problems":[{"name":"Number of Good Pairs (#1512)","hint":"For each num, count += freq so far. Each previous same-value element forms a pair."},{"name":"Count Number of Bad Pairs (#2364)","hint":"Bad = total - good. Good pairs where j - i == nums[j] - nums[i] → nums[i] - i == nums[j] - j. HashMap on (num - index)."},{"name":"K-diff Pairs (#532)","hint":"HashMap<Integer, Integer> for frequency. If k == 0, count nums with freq ≥ 2. If k > 0, check if num + k exists."},{"name":"Count Pairs With XOR in a Range (#1803)","hint":"Advanced: Trie-based. But brute force uses HashMap/counting for small ranges."}]},{"name":"Subarray Sum with HashMap","description":"Use prefix sum + HashMap to find subarrays with a target sum. This is the bridge between HashMap and prefix sum techniques.","when":"Number/existence of subarrays with sum = k, divisible by k, equal to zero.","template":"// Subarray sum equals K (prefix sum + HashMap)\npublic static int subarraySum(int[] nums, int k) {\n    Map<Integer, Integer> prefixCount = new HashMap<>();\n    prefixCount.put(0, 1);  // CRITICAL initialization\n    int prefix = 0, count = 0;\n\n    for (int num : nums) {\n        prefix += num;\n        // If (prefix - k) seen before, those subarrays sum to k\n        count += prefixCount.getOrDefault(prefix - k, 0);\n        prefixCount.merge(prefix, 1, Integer::sum);\n    }\n    return count;\n}","problems":[{"name":"Subarray Sum Equals K (#560)","hint":"Prefix sum + HashMap. map.put(0, 1) for subarrays starting at index 0. Count prefix - k."},{"name":"Contiguous Array (#525)","hint":"Replace 0 → -1. Now find longest subarray with sum 0. HashMap stores prefix → first index."},{"name":"Continuous Subarray Sum (#523)","hint":"Store (prefix % k) → first index. If same remainder seen and gap ≥ 2, return true."},{"name":"Subarray Sums Divisible by K (#974)","hint":"Count prefix sums with same (prefix % k). Normalize: ((prefix % k) + k) % k."}]}]},{"name":"ADVANCED_PATTERNS","overview":"Beyond frequency counting and two-sum, HashMaps enable powerful patterns: caching/memoization, index tracking for 'first/last occurrence', design problems, and transforming complex conditions into hashable keys.","variants":[{"name":"Index Tracking (First / Last Seen)","description":"Store the index where an element was first or last seen. Enables distance-based and range-based lookups.","when":"Contains duplicate within K distance, longest subarray, shortest word distance.","template":"// Contains Duplicate II: same value within k distance\npublic static boolean containsNearbyDuplicate(int[] nums, int k) {\n    Map<Integer, Integer> lastSeen = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        if (lastSeen.containsKey(nums[i])\n            && i - lastSeen.get(nums[i]) <= k) {\n            return true;\n        }\n        lastSeen.put(nums[i], i);  // update to latest index\n    }\n    return false;\n}","problems":[{"name":"Contains Duplicate II (#219)","hint":"HashMap<Integer, Integer> stores num → last index. Check if distance ≤ k."},{"name":"Shortest Word Distance (#243)","hint":"Track last indices of both words. Update min distance at each occurrence."},{"name":"Maximum Size Subarray Sum Equals K (#325)","hint":"HashMap<Integer, Integer> stores prefix → FIRST index. Maximize j - map.get(prefix - k)."},{"name":"Contiguous Array (#525)","hint":"Same: store prefix → first index. Return max(j - firstIndex) where prefix sums match."}]},{"name":"Encoding / Canonical Key","description":"Transform complex data into a hashable key. The key encodes the essential structural property you're grouping by.","when":"Group shifted strings, find duplicate subtrees, encode board states.","template":"// Group Shifted Strings: encode shift differences\npublic static List<List<String>> groupStrings(String[] strings) {\n    Map<String, List<String>> map = new HashMap<>();\n    for (String s : strings) {\n        StringBuilder key = new StringBuilder();\n        for (int i = 1; i < s.length(); i++) {\n            int diff = (s.charAt(i) - s.charAt(i - 1) + 26) % 26;\n            key.append(diff).append(\",\");\n        }\n        map.computeIfAbsent(key.toString(), k -> new ArrayList<>()).add(s);\n    }\n    return new ArrayList<>(map.values());\n}","problems":[{"name":"Group Shifted Strings (#249)","hint":"Key = comma-separated difference sequence. +26 % 26 handles wrap-around."},{"name":"Find Duplicate Subtrees (#652)","hint":"Serialize each subtree as a string. HashMap<String, Integer> counts occurrences."},{"name":"Encode and Decode TinyURL (#535)","hint":"HashMap<String, String> for code → url. Generate random short code or use incrementing counter."}]},{"name":"Design Problems (HashMap as Core)","description":"Many design-class problems use HashMap as their backbone: LRU cache, random access, frequency tracking.","when":"Implement a data structure that needs O(1) access, insert, delete, or frequency operations.","template":"// Insert Delete GetRandom O(1)\nclass RandomizedSet {\n    Map<Integer, Integer> valToIdx = new HashMap<>();\n    List<Integer> list = new ArrayList<>();\n    Random rand = new Random();\n\n    public boolean insert(int val) {\n        if (valToIdx.containsKey(val)) return false;\n        valToIdx.put(val, list.size());\n        list.add(val);\n        return true;\n    }\n\n    public boolean remove(int val) {\n        if (!valToIdx.containsKey(val)) return false;\n        int idx = valToIdx.get(val);\n        int last = list.get(list.size() - 1);\n        list.set(idx, last);\n        valToIdx.put(last, idx);\n        list.remove(list.size() - 1);\n        valToIdx.remove(val);\n        return true;\n    }\n\n    public int getRandom() {\n        return list.get(rand.nextInt(list.size()));\n    }\n}","problems":[{"name":"Insert Delete GetRandom O(1) (#380)","hint":"HashMap<val, index> + ArrayList. Swap-to-end trick for O(1) delete."},{"name":"LRU Cache (#146)","hint":"HashMap<key, Node> + doubly linked list. Move to head on access, evict from tail."},{"name":"LFU Cache (#460)","hint":"Three maps: key→val, key→freq, freq→LinkedHashSet. Track minFreq."},{"name":"Time Based Key-Value Store (#981)","hint":"HashMap<String, TreeMap<Integer, String>>. TreeMap.floorEntry(timestamp) for binary search."}]},{"name":"HashSet for Existence Checks","description":"When you only need to check 'have I seen this before?' without counting, HashSet is cleaner and sufficient.","when":"Cycle detection, happy number, intersection, unique elements.","template":"// Longest Consecutive Sequence: O(n)\npublic static int longestConsecutive(int[] nums) {\n    Set<Integer> set = new HashSet<>();\n    for (int n : nums) set.add(n);\n\n    int maxLen = 0;\n    for (int num : set) {\n        // Only start counting from sequence START\n        if (!set.contains(num - 1)) {\n            int len = 1;\n            while (set.contains(num + len)) len++;\n            maxLen = Math.max(maxLen, len);\n        }\n    }\n    return maxLen;\n}","problems":[{"name":"Longest Consecutive Sequence (#128)","hint":"HashSet. Only start counting when num-1 NOT in set (it's a sequence start). O(n)."},{"name":"Happy Number (#202)","hint":"HashSet tracks seen sums. If cycle detected (sum already seen), not happy."},{"name":"Intersection of Two Arrays (#349)","hint":"HashSet from arr1. Iterate arr2, check membership. Or sort + two pointers."},{"name":"Single Number (#136)","hint":"XOR all elements. HashSet works but XOR is O(1) space."}]}]}]},"stacks-queues":{"sections":["Stack Fundamentals","Monotonic Stack","BFS Fundamentals","Advanced Patterns","Pattern Recognition","Formulas & Tips","Revision Cards"],"patterns":[{"name":"STACK_FUNDAMENTALS","overview":"A stack is a LIFO (Last In, First Out) data structure. In Java, use Deque<> (ArrayDeque) — NOT the legacy Stack class. Stacks naturally model any problem involving nesting, matching, undo/redo, or 'most recent' queries. If you're tracking something that can be 'opened' and 'closed', think stack.","variants":[{"name":"Bracket Matching / Validation","description":"The classic stack application. Push opening brackets, pop on closing brackets and check if they match. If the stack is empty at the end, the input is valid.","when":"Parentheses validation, HTML tag matching, nested structure verification.","template":"public static boolean isValid(String s) {\n    Deque<Character> stack = new ArrayDeque<>();\n    Map<Character, Character> pairs = Map.of(')', '(', ']', '[', '}', '{');\n\n    for (char c : s.toCharArray()) {\n        if (pairs.containsValue(c)) {\n            stack.push(c);           // opening bracket\n        } else {\n            if (stack.isEmpty() || stack.pop() != pairs.get(c)) {\n                return false;        // mismatch or extra closing\n            }\n        }\n    }\n    return stack.isEmpty();          // no unclosed brackets\n}","problems":[{"name":"Valid Parentheses (#20)","hint":"Push opening, pop + compare on closing. Stack empty at end = valid."},{"name":"Minimum Add to Make Parentheses Valid (#921)","hint":"Track open and unmatched close counts. Result = open + unmatched."},{"name":"Minimum Remove to Make Valid (#1249)","hint":"Track indices of unmatched parens on stack. Build result string excluding those indices."},{"name":"Longest Valid Parentheses (#32)","hint":"Push indices (not chars). Keep a sentinel -1 on stack. Update max length on valid close."}]},{"name":"Expression Evaluation","description":"Use one or two stacks to evaluate mathematical expressions: one for operands, one for operators. Process based on operator precedence.","when":"Calculator problems, postfix/prefix evaluation, parsing nested expressions.","template":"// Basic Calculator II: +, -, *, / with no parentheses\npublic static int calculate(String s) {\n    Deque<Integer> stack = new ArrayDeque<>();\n    int num = 0;\n    char prevOp = '+';\n\n    for (int i = 0; i < s.length(); i++) {\n        char c = s.charAt(i);\n        if (Character.isDigit(c)) {\n            num = num * 10 + (c - '0');\n        }\n        if ((!Character.isDigit(c) && c != ' ') || i == s.length() - 1) {\n            switch (prevOp) {\n                case '+': stack.push(num); break;\n                case '-': stack.push(-num); break;\n                case '*': stack.push(stack.pop() * num); break;\n                case '/': stack.push(stack.pop() / num); break;\n            }\n            prevOp = c;\n            num = 0;\n        }\n    }\n    int result = 0;\n    for (int n : stack) result += n;\n    return result;\n}","problems":[{"name":"Basic Calculator II (#227)","hint":"Stack + prevOp. Push for +/-, compute immediately for */. Sum stack at end."},{"name":"Basic Calculator (#224)","hint":"Add recursion for parentheses. Or use two stacks: numbers + operators. Process on ')' or lower precedence."},{"name":"Evaluate Reverse Polish Notation (#150)","hint":"Push numbers. On operator, pop two, compute, push result. Final stack top = answer."}]},{"name":"Stack for Undo / Track State","description":"Use a stack to track previous states so you can 'go back' or reconstruct. Each push saves a snapshot, each pop restores.","when":"Decode strings, simplify paths, backspace comparisons, design browser history.","template":"// Decode String: \"3[a2[c]]\" → \"accaccacc\"\npublic static String decodeString(String s) {\n    Deque<StringBuilder> strStack = new ArrayDeque<>();\n    Deque<Integer> numStack = new ArrayDeque<>();\n    StringBuilder current = new StringBuilder();\n    int num = 0;\n\n    for (char c : s.toCharArray()) {\n        if (Character.isDigit(c)) {\n            num = num * 10 + (c - '0');\n        } else if (c == '[') {\n            numStack.push(num);\n            strStack.push(current);\n            current = new StringBuilder();\n            num = 0;\n        } else if (c == ']') {\n            int repeat = numStack.pop();\n            StringBuilder prev = strStack.pop();\n            prev.append(String.valueOf(current).repeat(repeat));\n            current = prev;\n        } else {\n            current.append(c);\n        }\n    }\n    return current.toString();\n}","problems":[{"name":"Decode String (#394)","hint":"Two stacks: numbers and strings. On '[', push current state. On ']', pop and repeat."},{"name":"Simplify Path (#71)","hint":"Split by '/'. Stack for dirs. '..' = pop, '.' = skip, else push. Join with '/'."},{"name":"Backspace String Compare (#844)","hint":"Stack: push chars, pop on '#'. Or O(1) space: traverse backwards with skip counters."},{"name":"Design Browser History (#1472)","hint":"Two stacks: back and forward. visit() clears forward stack."}]},{"name":"Min Stack / Stack with Metadata","description":"Augment a stack to track additional information (minimum, maximum, frequency) alongside each element.","when":"Get min/max in O(1), track running stats, maintain auxiliary info per stack frame.","template":"class MinStack {\n    Deque<int[]> stack = new ArrayDeque<>();\n    // Each entry: [value, currentMin]\n\n    public void push(int val) {\n        int min = stack.isEmpty() ? val : Math.min(val, stack.peek()[1]);\n        stack.push(new int[] { val, min });\n    }\n\n    public void pop()  { stack.pop(); }\n    public int top()   { return stack.peek()[0]; }\n    public int getMin(){ return stack.peek()[1]; }\n}","problems":[{"name":"Min Stack (#155)","hint":"Store (value, currentMin) pair. Each push records the min at that point. O(1) getMin."},{"name":"Max Stack (#716)","hint":"Two stacks or TreeMap + doubly linked list for O(log n) popMax."},{"name":"Maximum Frequency Stack (#895)","hint":"HashMap<val, freq> + HashMap<freq, Stack>. Track maxFreq. Pop from highest-freq stack."}]}]},{"name":"MONOTONIC_STACK","overview":"A monotonic stack maintains elements in strictly increasing or decreasing order. When a new element violates the order, you pop elements — and each pop reveals the answer for the popped element. This transforms O(n²) 'next greater/smaller' problems into O(n).","variants":[{"name":"Next Greater Element","description":"For each element, find the next element to its right that is larger. Maintain a decreasing stack: pop when current > stack top.","when":"Next greater, next warmer temperature, stock span, daily temperatures.","template":"// Next Greater Element (store indices on stack)\npublic static int[] nextGreaterElement(int[] nums) {\n    int n = nums.length;\n    int[] result = new int[n];\n    Arrays.fill(result, -1);  // default: no greater element\n    Deque<Integer> stack = new ArrayDeque<>(); // indices\n\n    for (int i = 0; i < n; i++) {\n        // Pop all elements that current is greater than\n        while (!stack.isEmpty() && nums[i] > nums[stack.peek()]) {\n            result[stack.pop()] = nums[i];\n        }\n        stack.push(i);\n    }\n    return result;\n}","problems":[{"name":"Daily Temperatures (#739)","hint":"Decreasing stack of indices. On pop: result[popped] = i - popped. Classic monotonic stack."},{"name":"Next Greater Element I (#496)","hint":"Build next-greater map for nums2 using monotonic stack. Look up each num in nums1."},{"name":"Next Greater Element II (#503)","hint":"Circular array: iterate 2*n, use i % n for index. Same monotonic stack otherwise."},{"name":"Online Stock Span (#901)","hint":"Decreasing stack of (price, span) pairs. Pop and accumulate span while top ≤ current price."}]},{"name":"Next Smaller Element","description":"For each element, find the next element to its right that is smaller. Maintain an increasing stack: pop when current < stack top.","when":"Next smaller, previous smaller, histogram area, removing digits.","template":"// Next Smaller Element\npublic static int[] nextSmallerElement(int[] nums) {\n    int n = nums.length;\n    int[] result = new int[n];\n    Arrays.fill(result, -1);\n    Deque<Integer> stack = new ArrayDeque<>();\n\n    for (int i = 0; i < n; i++) {\n        while (!stack.isEmpty() && nums[i] < nums[stack.peek()]) {\n            result[stack.pop()] = nums[i];\n        }\n        stack.push(i);\n    }\n    return result;\n}\n\n// Previous Smaller: iterate LEFT to RIGHT, peek gives prev smaller\n// Previous Greater: iterate LEFT to RIGHT with decreasing stack","problems":[{"name":"Largest Rectangle in Histogram (#84)","hint":"For each bar, find left and right boundaries where it's the minimum. Increasing stack. Area = h * (right - left - 1)."},{"name":"Remove K Digits (#402)","hint":"Increasing stack. Pop when current < top (removes larger digits). Maintain smallest number."},{"name":"132 Pattern (#456)","hint":"Decreasing stack from right. Track max 'two' value popped. If nums[i] < two, pattern found."},{"name":"Sum of Subarray Minimums (#907)","hint":"For each element, count subarrays where it's the minimum. Use previous-smaller and next-smaller distances."}]},{"name":"Monotonic Stack + Width/Area Calculation","description":"Combine monotonic stack with distance calculations to find maximum areas, spans, or ranges where an element is the extremum.","when":"Histogram area, trapping rain water (stack approach), maximal rectangle.","template":"// Largest Rectangle in Histogram\npublic static int largestRectangleArea(int[] heights) {\n    Deque<Integer> stack = new ArrayDeque<>();\n    int maxArea = 0;\n\n    for (int i = 0; i <= heights.length; i++) {\n        int h = (i == heights.length) ? 0 : heights[i];\n        while (!stack.isEmpty() && h < heights[stack.peek()]) {\n            int height = heights[stack.pop()];\n            int width = stack.isEmpty() ? i : i - stack.peek() - 1;\n            maxArea = Math.max(maxArea, height * width);\n        }\n        stack.push(i);\n    }\n    return maxArea;\n}","problems":[{"name":"Largest Rectangle in Histogram (#84)","hint":"Append 0 sentinel. Increasing stack. On pop: width = i - stack.peek() - 1 (or i if empty)."},{"name":"Maximal Rectangle (#85)","hint":"Build histogram row by row. Apply largest rectangle in histogram for each row."},{"name":"Trapping Rain Water (#42)","hint":"Stack approach: pop when current > top. Water = (min(curr, below) - popped) * width. Or two pointers."},{"name":"Sum of Subarray Ranges (#2104)","hint":"For each element, compute contribution as max and min. Two monotonic stack passes. O(n)."}]}]},{"name":"BFS_FUNDAMENTALS","overview":"BFS (Breadth-First Search) explores level by level using a queue. It guarantees shortest path in unweighted graphs. In Java, use ArrayDeque<> as the queue. BFS is the go-to when you need minimum steps, shortest distance, or level-by-level processing.","variants":[{"name":"Standard BFS (Graph / Grid)","description":"Start from source, explore all neighbors at distance 1, then distance 2, etc. Use a visited set/array to avoid cycles.","when":"Shortest path in unweighted graph, minimum moves, reachability.","template":"// BFS on a grid (shortest path)\npublic static int bfs(int[][] grid, int[] start, int[] end) {\n    int m = grid.length, n = grid[0].length;\n    boolean[][] visited = new boolean[m][n];\n    Queue<int[]> queue = new ArrayDeque<>();\n    int[][] dirs = {{0,1},{0,-1},{1,0},{-1,0}};\n\n    queue.offer(start);\n    visited[start[0]][start[1]] = true;\n    int steps = 0;\n\n    while (!queue.isEmpty()) {\n        int size = queue.size();       // process level by level\n        for (int i = 0; i < size; i++) {\n            int[] cell = queue.poll();\n            if (cell[0] == end[0] && cell[1] == end[1]) return steps;\n\n            for (int[] d : dirs) {\n                int nr = cell[0] + d[0], nc = cell[1] + d[1];\n                if (nr >= 0 && nr < m && nc >= 0 && nc < n\n                    && !visited[nr][nc] && grid[nr][nc] != 1) {\n                    visited[nr][nc] = true;\n                    queue.offer(new int[] {nr, nc});\n                }\n            }\n        }\n        steps++;\n    }\n    return -1; // unreachable\n}","problems":[{"name":"Number of Islands (#200)","hint":"BFS (or DFS) from each unvisited '1'. Mark visited. Count connected components."},{"name":"Shortest Path in Binary Matrix (#1091)","hint":"BFS from (0,0) to (n-1,n-1). 8-directional. Level = distance. Return steps + 1."},{"name":"01 Matrix (#542)","hint":"Multi-source BFS from all 0s simultaneously. Expand outward to fill distances to 1s."},{"name":"Rotting Oranges (#994)","hint":"Multi-source BFS from all rotten oranges. Each level = 1 minute. Check if fresh remain."}]},{"name":"Level-Order Tree Traversal","description":"BFS on a tree processes nodes level by level. Track level boundaries using queue.size() snapshot at each iteration.","when":"Level-order traversal, zigzag, right side view, level averages, minimum depth.","template":"// Level-order traversal\npublic static List<List<Integer>> levelOrder(TreeNode root) {\n    List<List<Integer>> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Queue<TreeNode> queue = new ArrayDeque<>();\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        int levelSize = queue.size();    // SNAPSHOT level size\n        List<Integer> level = new ArrayList<>();\n\n        for (int i = 0; i < levelSize; i++) {\n            TreeNode node = queue.poll();\n            level.add(node.val);\n            if (node.left != null)  queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n        result.add(level);\n    }\n    return result;\n}","problems":[{"name":"Binary Tree Level Order Traversal (#102)","hint":"Standard BFS with level-size snapshot. One list per level."},{"name":"Binary Tree Zigzag Level Order (#103)","hint":"Same BFS. Alternate adding to front/back of level list (or reverse odd levels)."},{"name":"Binary Tree Right Side View (#199)","hint":"BFS. Take the LAST element of each level. Or DFS right-first, track depth."},{"name":"Minimum Depth of Binary Tree (#111)","hint":"BFS. First LEAF node encountered = minimum depth. Check both children null."}]},{"name":"Multi-Source BFS","description":"Start BFS from multiple sources simultaneously. All sources are added to the queue at the start. Each level expands one step from ALL sources.","when":"Distance from nearest X, simultaneous expansion, fire spreading, walls and gates.","template":"// Multi-source BFS: distance from nearest 0\npublic static int[][] updateMatrix(int[][] mat) {\n    int m = mat.length, n = mat[0].length;\n    int[][] dist = new int[m][n];\n    Queue<int[]> queue = new ArrayDeque<>();\n    int[][] dirs = {{0,1},{0,-1},{1,0},{-1,0}};\n\n    // Enqueue ALL sources (0s) at once\n    for (int i = 0; i < m; i++)\n        for (int j = 0; j < n; j++)\n            if (mat[i][j] == 0) queue.offer(new int[]{i, j});\n            else dist[i][j] = Integer.MAX_VALUE;\n\n    while (!queue.isEmpty()) {\n        int[] cell = queue.poll();\n        for (int[] d : dirs) {\n            int nr = cell[0] + d[0], nc = cell[1] + d[1];\n            if (nr >= 0 && nr < m && nc >= 0 && nc < n\n                && dist[nr][nc] > dist[cell[0]][cell[1]] + 1) {\n                dist[nr][nc] = dist[cell[0]][cell[1]] + 1;\n                queue.offer(new int[]{nr, nc});\n            }\n        }\n    }\n    return dist;\n}","problems":[{"name":"01 Matrix (#542)","hint":"Multi-source from all 0s. BFS outward. Each step = +1 distance."},{"name":"Rotting Oranges (#994)","hint":"Multi-source from all rotten. BFS levels = minutes. Check leftover fresh count."},{"name":"Walls and Gates (#286)","hint":"Multi-source from all gates (0). BFS fills rooms with shortest distance."},{"name":"Shortest Bridge (#934)","hint":"DFS to find first island. Multi-source BFS from its border to reach second island."}]},{"name":"BFS with State Encoding","description":"When BFS state is more than just position, encode additional information into the visited key (bitmask, collected keys, remaining moves).","when":"Keys and doors, minimum moves with constraints, shortest path with state changes.","template":"// BFS with state: position + collected keys as bitmask\n// visited[row][col][keyMask] or Set<String> for state\nQueue<int[]> queue = new ArrayDeque<>();\n// Each entry: {row, col, keyMask, steps}\nSet<String> visited = new HashSet<>();\n\nqueue.offer(new int[]{startR, startC, 0, 0});\nvisited.add(startR + \",\" + startC + \",\" + 0);\n\nwhile (!queue.isEmpty()) {\n    int[] curr = queue.poll();\n    int r = curr[0], c = curr[1], keys = curr[2], steps = curr[3];\n\n    // If key found: keys |= (1 << (grid[r][c] - 'a'))\n    // If door found: check if (keys & (1 << (door - 'A'))) != 0\n    // State key: r + \",\" + c + \",\" + keys\n}","problems":[{"name":"Shortest Path to Get All Keys (#864)","hint":"BFS with state = (row, col, keyBitmask). Visited per state. Return steps when all keys collected."},{"name":"Open the Lock (#752)","hint":"BFS from '0000'. Each state has 8 neighbors (±1 per digit). HashSet for visited + deadends."},{"name":"Sliding Puzzle (#773)","hint":"Encode board as string. BFS from initial state. Target = '123450'. Each move swaps 0 with neighbor."},{"name":"Word Ladder (#127)","hint":"BFS on word graph. Neighbors differ by one char. Visited set. Return level count."}]}]},{"name":"ADVANCED_PATTERNS","overview":"Beyond basic stacks and queues, there are powerful hybrid patterns: deque-based sliding window, priority queue (min/max heap), stack-based DFS conversion, and special queue variants.","variants":[{"name":"Monotonic Deque (Sliding Window Max/Min)","description":"A double-ended queue that maintains a monotonic ordering. Elements are added at the back and removed from both ends. Enables O(1) max/min queries within a sliding window.","when":"Sliding window maximum/minimum, jump game optimizations.","template":"// Sliding Window Maximum\npublic static int[] maxSlidingWindow(int[] nums, int k) {\n    Deque<Integer> deque = new ArrayDeque<>(); // indices, decreasing values\n    int[] result = new int[nums.length - k + 1];\n\n    for (int i = 0; i < nums.length; i++) {\n        // Remove elements outside window\n        while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {\n            deque.pollFirst();\n        }\n        // Remove smaller elements (they'll never be the max)\n        while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {\n            deque.pollLast();\n        }\n        deque.offerLast(i);\n\n        if (i >= k - 1) {\n            result[i - k + 1] = nums[deque.peekFirst()];\n        }\n    }\n    return result;\n}","problems":[{"name":"Sliding Window Maximum (#239)","hint":"Monotonic decreasing deque of indices. Front = current max. Remove out-of-window and smaller-than-current."},{"name":"Shortest Subarray with Sum at Least K (#862)","hint":"Monotonic deque on prefix sums. Handles negative numbers. Deque of indices, increasing prefix values."}]},{"name":"Priority Queue (Heap) as Queue Variant","description":"A PriorityQueue processes elements by priority instead of FIFO order. Min-heap by default in Java. Use for 'next best' or 'K-th' problems.","when":"Merge K sorted, K-th smallest/largest, scheduling, Dijkstra's algorithm.","template":"// Merge K Sorted Lists\npublic static ListNode mergeKLists(ListNode[] lists) {\n    PriorityQueue<ListNode> pq = new PriorityQueue<>(\n        (a, b) -> a.val - b.val  // min-heap by node value\n    );\n    for (ListNode head : lists) {\n        if (head != null) pq.offer(head);\n    }\n\n    ListNode dummy = new ListNode(0), curr = dummy;\n    while (!pq.isEmpty()) {\n        ListNode node = pq.poll();\n        curr.next = node;\n        curr = curr.next;\n        if (node.next != null) pq.offer(node.next);\n    }\n    return dummy.next;\n}","problems":[{"name":"Merge K Sorted Lists (#23)","hint":"Min-heap of list heads. Poll min, advance that list, re-offer. O(n log k)."},{"name":"Kth Largest Element (#215)","hint":"Min-heap of size k. After processing all elements, peek = k-th largest. Or quickselect O(n) avg."},{"name":"Task Scheduler (#621)","hint":"Max-heap for task frequencies. Greedy: schedule highest-freq first. Cooldown with queue."},{"name":"Find Median from Data Stream (#295)","hint":"Two heaps: max-heap for lower half, min-heap for upper half. Balance sizes. Median from tops."}]},{"name":"Stack-Based DFS (Iterative)","description":"Convert recursive DFS to iterative using an explicit stack. Avoids stack overflow for deep recursion.","when":"Tree/graph DFS without recursion, iterative inorder/preorder/postorder traversal.","template":"// Iterative Inorder Traversal\npublic static List<Integer> inorderTraversal(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    Deque<TreeNode> stack = new ArrayDeque<>();\n    TreeNode curr = root;\n\n    while (curr != null || !stack.isEmpty()) {\n        // Go as far left as possible\n        while (curr != null) {\n            stack.push(curr);\n            curr = curr.left;\n        }\n        curr = stack.pop();\n        result.add(curr.val);    // visit\n        curr = curr.right;        // go right\n    }\n    return result;\n}","problems":[{"name":"Binary Tree Inorder Traversal (#94)","hint":"Push all lefts. Pop, visit, go right. Repeat until stack empty and curr null."},{"name":"Flatten Binary Tree to Linked List (#114)","hint":"Iterative preorder with stack. Or Morris traversal for O(1) space."},{"name":"Binary Search Tree Iterator (#173)","hint":"Controlled inorder: push all lefts. next() pops, pushes rights. O(h) space."}]}]}]},"linked-lists":{"sections":["Core Techniques","Fast & Slow Pointers","Reversal Patterns","Merge & Sort","Pattern Recognition","Formulas & Tips","Revision Cards"],"patterns":[{"name":"CORE_TECHNIQUES","overview":"Linked list problems test pointer manipulation under pressure. Unlike arrays, you have no random access — every operation is local. The key mental model: you're rewiring connections between nodes. In Java, a ListNode is just a val + a next pointer (and prev for doubly linked). Use Deque<> (ArrayDeque) for implementing stacks/queues, but for interview problems the raw ListNode is what matters. The three skills that cover 90% of problems: using a dummy head, traversing with multiple pointers, and rewiring .next references without losing nodes.","variants":[{"name":"Dummy Head (Sentinel Node)","description":"Create a fake node before the real head. It eliminates all edge cases where the head itself might be removed, changed, or doesn't exist yet. Return dummy.next at the end.","when":"Any problem that modifies the list structure — removal, merging, partitioning, insertion. Basically use it by default unless you have a reason not to.","template":"// Dummy head template — use this by default\npublic ListNode solve(ListNode head) {\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    ListNode prev = dummy, curr = head;\n\n    while (curr != null) {\n        if (/* condition to remove curr */) {\n            prev.next = curr.next;  // skip curr\n        } else {\n            prev = curr;            // advance prev\n        }\n        curr = curr.next;           // always advance curr\n    }\n    return dummy.next;  // NOT head — head may have been removed\n}","problems":[{"name":"Remove Linked List Elements (#203)","hint":"Dummy head + prev/curr. If curr.val == target, prev.next = curr.next. Otherwise advance prev."},{"name":"Remove Duplicates from Sorted List II (#82)","hint":"Dummy head. When curr.val == curr.next.val, skip ALL nodes with that value. prev stays put."},{"name":"Partition List (#86)","hint":"Two dummy heads: one for nodes < x, one for ≥ x. Append to appropriate list. Splice them together."},{"name":"Merge Two Sorted Lists (#21)","hint":"Dummy head. Compare l1.val vs l2.val, append smaller, advance that pointer. Attach remaining."}]},{"name":"Prev / Curr / Next Triple","description":"Maintain three pointers to safely rewire links. Prev trails behind, curr is the node you're processing, next is saved before you modify curr.next. Essential for any in-place restructuring.","when":"Reversing, reordering, swapping nodes, deleting with access to the previous node.","template":"// Prev / Curr / Next — the safe rewiring pattern\nListNode prev = null, curr = head;\nwhile (curr != null) {\n    ListNode next = curr.next;  // SAVE next before rewiring\n    curr.next = prev;           // rewire\n    prev = curr;                // advance prev\n    curr = next;                // advance curr\n}\n// prev is now the new head","problems":[{"name":"Reverse Linked List (#206)","hint":"The exact template above. prev starts null, at the end prev is the new head."},{"name":"Swap Nodes in Pairs (#24)","hint":"Save next pair. Rewire: second.next = first, first.next = next pair's result. Recurse or iterate."},{"name":"Odd Even Linked List (#328)","hint":"Two pointers: odd and even. odd.next = even.next, advance odd. even.next = odd.next, advance even. Splice."}]},{"name":"Two-Pointer Gap Technique","description":"Advance one pointer n steps ahead, then move both at the same speed. When the leader hits null, the follower is at the target position. Converts 'n-th from end' into a single-pass solution.","when":"Finding the n-th node from the end, finding the middle, removing the n-th from end.","template":"// Remove N-th from end — single pass\npublic ListNode removeNthFromEnd(ListNode head, int n) {\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    ListNode fast = dummy, slow = dummy;\n\n    // Advance fast n+1 steps (so slow lands on the node BEFORE target)\n    for (int i = 0; i <= n; i++) {\n        fast = fast.next;\n    }\n    // Move both until fast hits null\n    while (fast != null) {\n        fast = fast.next;\n        slow = slow.next;\n    }\n    slow.next = slow.next.next;  // skip the target\n    return dummy.next;\n}","problems":[{"name":"Remove Nth Node From End (#19)","hint":"Dummy head + gap technique. Fast leads by n+1. When fast == null, slow.next is the target. Skip it."},{"name":"Middle of the Linked List (#876)","hint":"Fast moves 2 steps, slow moves 1. When fast reaches end, slow is at middle. No gap needed here — this is fast/slow."},{"name":"Rotate List (#61)","hint":"Find length. k %= length. Gap technique to find new tail. Rewire: old tail → old head, new tail.next = null."}]}]},{"name":"FAST_SLOW","overview":"Fast and slow pointers (Floyd's Tortoise and Hare) is the most elegant linked list technique. Slow moves 1 step, fast moves 2 steps. This gives you three superpowers: (1) cycle detection — if there's a cycle, fast catches slow; (2) middle finding — when fast reaches the end, slow is at the middle; (3) cycle entry point — after detection, reset one pointer to head and move both at speed 1 until they meet. These three cover a huge range of problems.","variants":[{"name":"Cycle Detection (Floyd's Algorithm)","description":"slow = slow.next, fast = fast.next.next. If they meet, there's a cycle. If fast or fast.next becomes null, no cycle. The proof: fast closes the gap by 1 each step, so it always catches slow within one cycle.","when":"Detect if a linked list has a cycle. Also applies to any 'repeated state' problem (happy number, duplicate detection).","template":"// Cycle detection\npublic boolean hasCycle(ListNode head) {\n    ListNode slow = head, fast = head;\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow == fast) return true;  // cycle found\n    }\n    return false;  // fast reached end — no cycle\n}","problems":[{"name":"Linked List Cycle (#141)","hint":"The exact template. fast != null && fast.next != null guards against odd/even length. Reference equality (==) not .equals()."},{"name":"Happy Number (#202)","hint":"Same pattern but on numbers: slow = nextDigitSum(slow), fast = nextDigitSum(nextDigitSum(fast)). Cycle = unhappy."},{"name":"Find the Duplicate Number (#287)","hint":"Treat array as linked list: index → nums[index]. Floyd's on array indices. Same cycle detection + entry point."}]},{"name":"Cycle Entry Point","description":"After fast and slow meet inside the cycle, reset one pointer to head. Move both at speed 1. The point where they meet again is the cycle's entry node. This works because of the mathematical relationship: distance from head to entry = distance from meeting point to entry (going around the cycle).","when":"Find WHERE a cycle starts, not just IF one exists.","template":"// Cycle entry point (Phase 2 of Floyd's)\npublic ListNode detectCycle(ListNode head) {\n    ListNode slow = head, fast = head;\n\n    // Phase 1: Detect cycle\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow == fast) {\n            // Phase 2: Find entry\n            ListNode entry = head;\n            while (entry != slow) {\n                entry = entry.next;\n                slow = slow.next;\n            }\n            return entry;  // cycle start\n        }\n    }\n    return null;  // no cycle\n}","problems":[{"name":"Linked List Cycle II (#142)","hint":"Phase 1: detect with fast/slow. Phase 2: reset one to head, move both at speed 1. Meeting point = cycle entry."},{"name":"Find the Duplicate Number (#287)","hint":"Phase 1: slow = nums[slow], fast = nums[nums[fast]]. Phase 2: reset one to 0, both advance by nums[i]. Meeting = duplicate value."}]},{"name":"Middle Finding","description":"slow moves 1, fast moves 2. When fast can't move anymore, slow is at the middle. For even-length lists, this gives the second middle node (or first, depending on the loop condition).","when":"Find middle for merge sort on linked list, palindrome check (reverse second half), reorder list.","template":"// Find middle — slow lands on second middle for even length\npublic ListNode findMiddle(ListNode head) {\n    ListNode slow = head, fast = head;\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    return slow;  // middle (or second middle for even length)\n}\n\n// Find middle — slow lands on FIRST middle for even length\n// (useful when you need to split into two halves)\npublic ListNode findFirstMiddle(ListNode head) {\n    ListNode slow = head, fast = head;\n    while (fast.next != null && fast.next.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    return slow;  // first middle — slow.next starts second half\n}","problems":[{"name":"Middle of the Linked List (#876)","hint":"Standard fast/slow. Return slow. For even length, returns second middle."},{"name":"Palindrome Linked List (#234)","hint":"Find first middle → reverse second half → compare both halves → (optionally) restore."},{"name":"Sort List (#148)","hint":"Find first middle → split → recursively sort both halves → merge. O(n log n) time, O(log n) stack space."},{"name":"Reorder List (#143)","hint":"Find middle → reverse second half → interleave (merge alternating). Three classic techniques in one problem."}]}]},{"name":"REVERSAL_PATTERNS","overview":"Reversing a linked list is the single most important linked list operation. It appears standalone, as a subroutine in harder problems, and as a building block for reorder/palindrome/add problems. You must be able to reverse iteratively (prev/curr/next) and recursively (trust the recursion returns the new head, rewire on the way back up). Partial reversal (reverse between positions m and n) is the intermediate skill that unlocks the hardest problems.","variants":[{"name":"Full Iterative Reversal","description":"The bread and butter. Three pointers: prev (starts null), curr (starts head), next (saved each iteration). Rewire curr.next = prev, then shift all three forward. At the end, prev is the new head.","when":"Reverse entire list, or as a subroutine called on a sublist.","template":"// Full iterative reversal\npublic ListNode reverseList(ListNode head) {\n    ListNode prev = null, curr = head;\n    while (curr != null) {\n        ListNode next = curr.next;\n        curr.next = prev;\n        prev = curr;\n        curr = next;\n    }\n    return prev;  // new head\n}","problems":[{"name":"Reverse Linked List (#206)","hint":"The exact template. 5 lines of code. Practice until you can write it with your eyes closed."},{"name":"Palindrome Linked List (#234)","hint":"Find middle, reverse second half, compare with first half. Reverse is the subroutine."}]},{"name":"Full Recursive Reversal","description":"Base case: head == null or head.next == null → return head. Recurse on head.next. After recursion returns the new head, rewire: head.next.next = head, head.next = null. The recursion 'bubbles up' the new head while each stack frame handles one rewiring.","when":"When you prefer elegance, or when the problem structure naturally recurses (e.g., reverse in groups).","template":"// Recursive reversal\npublic ListNode reverseList(ListNode head) {\n    if (head == null || head.next == null) return head;\n    ListNode newHead = reverseList(head.next);\n    head.next.next = head;  // the node after me now points back to me\n    head.next = null;       // I no longer point forward\n    return newHead;         // pass the new head all the way up\n}","problems":[{"name":"Reverse Linked List (#206)","hint":"Same problem, recursive approach. Understand BOTH. Interviewers sometimes ask for the other after you give one."},{"name":"Reverse Nodes in k-Group (#25)","hint":"Check if k nodes exist. If yes, reverse k nodes (iteratively), recurse on remainder. Reconnect."}]},{"name":"Partial Reversal (Between Positions)","description":"Reverse only the sublist from position left to right. Navigate to the node before 'left', then reverse 'right - left + 1' nodes using the iterative technique. Reconnect the reversed segment back into the original list.","when":"Reverse Between Positions, Reverse in K-Groups, any problem that modifies only a segment.","template":"// Reverse between positions left and right (1-indexed)\npublic ListNode reverseBetween(ListNode head, int left, int right) {\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    ListNode prev = dummy;\n\n    // Step 1: Navigate to node before 'left'\n    for (int i = 1; i < left; i++) {\n        prev = prev.next;\n    }\n\n    // Step 2: Reverse 'right - left + 1' nodes\n    ListNode curr = prev.next;\n    for (int i = 0; i < right - left; i++) {\n        ListNode next = curr.next;\n        curr.next = next.next;\n        next.next = prev.next;\n        prev.next = next;\n    }\n    return dummy.next;\n}","problems":[{"name":"Reverse Linked List II (#92)","hint":"Dummy head + navigate to position. 'Insertion reversal': repeatedly move curr.next to right after prev. Elegant and avoids explicit reconnection."},{"name":"Reverse Nodes in k-Group (#25)","hint":"Count k nodes. If enough, reverse them (call iterative reversal on the segment). Recurse on the rest. Connect tail of reversed group to next group's result."},{"name":"Swap Nodes in Pairs (#24)","hint":"Special case of k-group reversal where k = 2. Can also solve with straightforward pointer swapping."}]}]},{"name":"MERGE_AND_SORT","overview":"Merge operations on linked lists are uniquely elegant compared to arrays — you just rewire pointers with no shifting or extra space for the merge itself. Merge two sorted lists is a Tier 1 fundamental. Merge sort on linked lists runs in O(n log n) time with O(log n) space (recursion stack only — no auxiliary array needed unlike array merge sort). These patterns also appear in 'add two numbers' problems where you traverse two lists in lockstep.","variants":[{"name":"Merge Two Sorted Lists","description":"Classic merge: compare heads of both lists, append the smaller one, advance that pointer. Use a dummy head for clean code. After one list is exhausted, attach the remainder of the other.","when":"Merging sorted lists, final step of merge sort, combining results from two sources.","template":"// Merge two sorted lists — iterative\npublic ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n    ListNode dummy = new ListNode(0), curr = dummy;\n    while (l1 != null && l2 != null) {\n        if (l1.val <= l2.val) {\n            curr.next = l1;\n            l1 = l1.next;\n        } else {\n            curr.next = l2;\n            l2 = l2.next;\n        }\n        curr = curr.next;\n    }\n    curr.next = (l1 != null) ? l1 : l2;  // attach remainder\n    return dummy.next;\n}","problems":[{"name":"Merge Two Sorted Lists (#21)","hint":"The exact template. Dummy head + compare + append smaller. O(n + m) time, O(1) space."},{"name":"Merge K Sorted Lists (#23)","hint":"Min-heap of k heads: O(n log k). Or divide-and-conquer: pair up and merge, halving each round — also O(n log k)."}]},{"name":"Merge Sort on Linked List","description":"Find middle (fast/slow, using first-middle variant), split into two halves, recursively sort each, merge. The beauty: splitting is O(1) pointer reassignment (unlike array copying), and merge is in-place pointer rewiring.","when":"Sort a linked list in O(n log n). This is the standard approach — quicksort is possible but less stable.","template":"// Merge sort on linked list\npublic ListNode sortList(ListNode head) {\n    if (head == null || head.next == null) return head;\n\n    // Split: find first middle, cut\n    ListNode slow = head, fast = head;\n    while (fast.next != null && fast.next.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    ListNode secondHalf = slow.next;\n    slow.next = null;  // cut the list\n\n    // Recurse\n    ListNode left = sortList(head);\n    ListNode right = sortList(secondHalf);\n\n    // Merge\n    return mergeTwoLists(left, right);\n}","problems":[{"name":"Sort List (#148)","hint":"Find first middle → cut → sort both → merge. O(n log n) time. Bottom-up variant for O(1) space."},{"name":"Insertion Sort List (#147)","hint":"Build a new sorted list. For each node, find its correct position in the sorted portion and insert. O(n²)."}]},{"name":"Add Two Numbers (Lockstep Traversal)","description":"Traverse two lists simultaneously, processing corresponding nodes. Carry propagation: carry = sum / 10, digit = sum % 10. A dummy head simplifies building the result list.","when":"Adding numbers represented as linked lists, zipping two lists, comparing element by element.","template":"// Add two numbers — digits in reverse order\npublic ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    ListNode dummy = new ListNode(0), curr = dummy;\n    int carry = 0;\n\n    while (l1 != null || l2 != null || carry != 0) {\n        int sum = carry;\n        if (l1 != null) { sum += l1.val; l1 = l1.next; }\n        if (l2 != null) { sum += l2.val; l2 = l2.next; }\n        carry = sum / 10;\n        curr.next = new ListNode(sum % 10);\n        curr = curr.next;\n    }\n    return dummy.next;\n}","problems":[{"name":"Add Two Numbers (#2)","hint":"Digits in reverse order (LSB first). Process left to right with carry. The template above."},{"name":"Add Two Numbers II (#445)","hint":"Digits in forward order (MSB first). Use stacks to reverse, or reverse the lists first, then apply #2's pattern."}]}]}]},"trees":{"sections":["Tree Traversals","Recursion Patterns","BST Operations","Advanced Patterns","Pattern Recognition","Formulas & Tips","Revision Cards"],"patterns":[{"name":"TREE_TRAVERSALS","overview":"Tree traversal visits every node exactly once. DFS (Depth-First Search) goes deep before wide — preorder, inorder, postorder. BFS (Breadth-First Search) goes level by level. In Java, TreeNode has val, left, right. Master both recursive and iterative implementations.","variants":[{"name":"Preorder (Root → Left → Right)","description":"Visit the root FIRST, then recurse left, then right. Use when you need to process nodes top-down or serialize a tree.","when":"Serialize tree, copy tree, prefix expression, top-down path building.","template":"// Recursive Preorder\npublic void preorder(TreeNode root, List<Integer> result) {\n    if (root == null) return;\n    result.add(root.val);       // VISIT\n    preorder(root.left, result);\n    preorder(root.right, result);\n}\n\n// Iterative Preorder (stack)\npublic List<Integer> preorderIterative(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    if (root == null) return result;\n    Deque<TreeNode> stack = new ArrayDeque<>();\n    stack.push(root);\n\n    while (!stack.isEmpty()) {\n        TreeNode node = stack.pop();\n        result.add(node.val);\n        // Push RIGHT first so LEFT is processed first (LIFO)\n        if (node.right != null) stack.push(node.right);\n        if (node.left != null) stack.push(node.left);\n    }\n    return result;\n}","problems":[{"name":"Binary Tree Preorder Traversal (#144)","hint":"Recursive is trivial. Iterative: push right then left so left pops first."},{"name":"Flatten Binary Tree to Linked List (#114)","hint":"Preorder traversal + reassign pointers. Or reverse postorder (right, left, root) and link backwards."},{"name":"Construct BST from Preorder (#1008)","hint":"First element = root. Recursively build with upper bound. O(n) with bound tracking."}]},{"name":"Inorder (Left → Root → Right)","description":"Recurse left, THEN visit root, then right. For BST, inorder gives nodes in SORTED order. Essential for BST validation and finding kth element.","when":"BST sorted order, kth smallest, validate BST, convert BST to sorted list.","template":"// Recursive Inorder\npublic void inorder(TreeNode root, List<Integer> result) {\n    if (root == null) return;\n    inorder(root.left, result);\n    result.add(root.val);        // VISIT\n    inorder(root.right, result);\n}\n\n// Iterative Inorder (stack + go-left loop)\npublic List<Integer> inorderIterative(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    Deque<TreeNode> stack = new ArrayDeque<>();\n    TreeNode curr = root;\n\n    while (curr != null || !stack.isEmpty()) {\n        // Go as far left as possible\n        while (curr != null) {\n            stack.push(curr);\n            curr = curr.left;\n        }\n        curr = stack.pop();\n        result.add(curr.val);     // VISIT\n        curr = curr.right;         // Go right\n    }\n    return result;\n}","problems":[{"name":"Binary Tree Inorder Traversal (#94)","hint":"Push all lefts. Pop, visit, go right. Repeat until stack empty and curr null."},{"name":"Kth Smallest Element in BST (#230)","hint":"Inorder traversal, decrement k. When k == 0, return current node's value."},{"name":"Validate BST (#98)","hint":"Inorder: each node must be > previous. Or recursive with (min, max) bounds."},{"name":"Convert BST to Sorted Doubly Linked List (#426)","hint":"Inorder traversal. Track 'prev' and 'head'. Link prev.right = curr, curr.left = prev."}]},{"name":"Postorder (Left → Right → Root)","description":"Recurse left, then right, THEN visit root. Use when you need to process children before parent (bottom-up). Essential for deletion and subtree computations.","when":"Delete tree, calculate subtree values, bottom-up DP on trees, serialize.","template":"// Recursive Postorder\npublic void postorder(TreeNode root, List<Integer> result) {\n    if (root == null) return;\n    postorder(root.left, result);\n    postorder(root.right, result);\n    result.add(root.val);        // VISIT\n}\n\n// Iterative Postorder (modified preorder + reverse)\npublic List<Integer> postorderIterative(TreeNode root) {\n    LinkedList<Integer> result = new LinkedList<>();\n    if (root == null) return result;\n    Deque<TreeNode> stack = new ArrayDeque<>();\n    stack.push(root);\n\n    while (!stack.isEmpty()) {\n        TreeNode node = stack.pop();\n        result.addFirst(node.val);  // Add to FRONT\n        // Push LEFT first, then RIGHT (reverse of preorder)\n        if (node.left != null) stack.push(node.left);\n        if (node.right != null) stack.push(node.right);\n    }\n    return result;\n}","problems":[{"name":"Binary Tree Postorder Traversal (#145)","hint":"Iterative: modified preorder (root, right, left) then reverse, OR use addFirst()."},{"name":"Delete Nodes And Return Forest (#1110)","hint":"Postorder so children are processed before parent. Return null to delete, add roots to result."},{"name":"Binary Tree Maximum Path Sum (#124)","hint":"Postorder: compute max path through each node bottom-up. Track global max."}]},{"name":"Level-Order (BFS)","description":"Process nodes level by level using a queue. Essential for shortest path, level-specific operations, and right/left side views.","when":"Level grouping, shortest path in tree, right side view, zigzag, level averages.","template":"// Level-Order Traversal\npublic List<List<Integer>> levelOrder(TreeNode root) {\n    List<List<Integer>> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Queue<TreeNode> queue = new ArrayDeque<>();\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        int levelSize = queue.size();  // SNAPSHOT level size\n        List<Integer> level = new ArrayList<>();\n\n        for (int i = 0; i < levelSize; i++) {\n            TreeNode node = queue.poll();\n            level.add(node.val);\n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n        result.add(level);\n    }\n    return result;\n}","problems":[{"name":"Binary Tree Level Order Traversal (#102)","hint":"BFS with level-size snapshot. One inner loop per level."},{"name":"Binary Tree Zigzag Level Order (#103)","hint":"Same BFS. Alternate addFirst/addLast for level list (or reverse odd levels)."},{"name":"Binary Tree Right Side View (#199)","hint":"BFS, take last element of each level. Or DFS right-first, track depth."},{"name":"Minimum Depth of Binary Tree (#111)","hint":"BFS. First LEAF node (both children null) = minimum depth."}]}]},{"name":"RECURSION_PATTERNS","overview":"Tree problems are naturally recursive because trees are recursive structures. Master these patterns: return value (bottom-up), pass parameters (top-down), global variable, and the 'two-call' pattern where you need info from both subtrees.","variants":[{"name":"Return Value Pattern (Bottom-Up)","description":"Recursively solve for left and right subtrees, then combine results at the current node. The function's return value carries information upward.","when":"Height, depth, diameter, subtree sums, path existence.","template":"// Max Depth (return value pattern)\npublic int maxDepth(TreeNode root) {\n    if (root == null) return 0;\n\n    int leftDepth = maxDepth(root.left);\n    int rightDepth = maxDepth(root.right);\n\n    return Math.max(leftDepth, rightDepth) + 1;\n}\n\n// Is Balanced (return -1 for unbalanced)\npublic int checkHeight(TreeNode root) {\n    if (root == null) return 0;\n\n    int left = checkHeight(root.left);\n    if (left == -1) return -1;  // early termination\n\n    int right = checkHeight(root.right);\n    if (right == -1) return -1;\n\n    if (Math.abs(left - right) > 1) return -1;  // unbalanced\n    return Math.max(left, right) + 1;\n}","problems":[{"name":"Maximum Depth of Binary Tree (#104)","hint":"return max(left, right) + 1. Base case: null → 0."},{"name":"Balanced Binary Tree (#110)","hint":"Return height, or -1 if subtree unbalanced. Propagate -1 up to short-circuit."},{"name":"Diameter of Binary Tree (#543)","hint":"Diameter through node = leftHeight + rightHeight. Track global max. Return height."},{"name":"Subtree of Another Tree (#572)","hint":"For each node, check isSameTree(). Return true if any match found."}]},{"name":"Pass Parameters Pattern (Top-Down)","description":"Pass accumulated information (path, sum, bounds) from parent to children via function parameters. The recursion carries context downward.","when":"Path sum, root-to-leaf paths, BST validation with bounds, prefix paths.","template":"// Path Sum (top-down parameter passing)\npublic boolean hasPathSum(TreeNode root, int targetSum) {\n    if (root == null) return false;\n\n    // Check if leaf with correct sum\n    if (root.left == null && root.right == null) {\n        return root.val == targetSum;\n    }\n\n    // Pass remaining sum to children\n    int remaining = targetSum - root.val;\n    return hasPathSum(root.left, remaining)\n        || hasPathSum(root.right, remaining);\n}\n\n// All root-to-leaf paths\npublic void findPaths(TreeNode root, String path, List<String> result) {\n    if (root == null) return;\n\n    path += root.val;\n    if (root.left == null && root.right == null) {\n        result.add(path);  // leaf reached\n    } else {\n        path += \"->\";\n        findPaths(root.left, path, result);\n        findPaths(root.right, path, result);\n    }\n}","problems":[{"name":"Path Sum (#112)","hint":"Pass remaining sum. At leaf, check if remaining == node.val."},{"name":"Path Sum II (#113)","hint":"Pass current path list. At leaf, if sum matches, add copy of path to result."},{"name":"Sum Root to Leaf Numbers (#129)","hint":"Pass currentNum = currentNum * 10 + node.val. At leaf, add to total."},{"name":"Binary Tree Paths (#257)","hint":"Pass path string. At leaf, add to result. String immutability handles backtracking."}]},{"name":"Global Variable Pattern","description":"Use a class-level variable to track state across recursive calls. Useful when you need to find a global optimum or count something.","when":"Maximum path sum, diameter, count nodes with condition, longest consecutive.","template":"// Diameter with global max\nprivate int maxDiameter = 0;\n\npublic int diameterOfBinaryTree(TreeNode root) {\n    height(root);\n    return maxDiameter;\n}\n\nprivate int height(TreeNode node) {\n    if (node == null) return 0;\n\n    int left = height(node.left);\n    int right = height(node.right);\n\n    // Update global max (diameter through this node)\n    maxDiameter = Math.max(maxDiameter, left + right);\n\n    return Math.max(left, right) + 1;\n}","problems":[{"name":"Diameter of Binary Tree (#543)","hint":"Global maxDiameter. At each node, update with left + right. Return height."},{"name":"Binary Tree Maximum Path Sum (#124)","hint":"Global maxSum. Path sum through node = node.val + max(0, left) + max(0, right)."},{"name":"Longest Univalue Path (#687)","hint":"Global maxLen. Extend path if child.val == node.val. Return single-side length."},{"name":"Count Good Nodes (#1448)","hint":"Pass maxSoFar. If node.val >= maxSoFar, increment global count."}]},{"name":"Two-Call / Divide-and-Conquer Pattern","description":"Make two recursive calls and combine their results. Often used when the answer at a node depends on information from both subtrees.","when":"Same tree, symmetric tree, merge trees, LCA, tree equality checks.","template":"// Same Tree (two-call pattern)\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    if (p.val != q.val) return false;\n\n    return isSameTree(p.left, q.left)\n        && isSameTree(p.right, q.right);\n}\n\n// Symmetric Tree\npublic boolean isSymmetric(TreeNode root) {\n    if (root == null) return true;\n    return isMirror(root.left, root.right);\n}\n\nprivate boolean isMirror(TreeNode t1, TreeNode t2) {\n    if (t1 == null && t2 == null) return true;\n    if (t1 == null || t2 == null) return false;\n    return t1.val == t2.val\n        && isMirror(t1.left, t2.right)\n        && isMirror(t1.right, t2.left);\n}","problems":[{"name":"Same Tree (#100)","hint":"Both null → true. One null → false. Values equal + both subtrees same."},{"name":"Symmetric Tree (#101)","hint":"Helper isMirror(left, right). Compare left.left with right.right, etc."},{"name":"Merge Two Binary Trees (#617)","hint":"If one null, return other. Else new node with sum, recurse both sides."},{"name":"Lowest Common Ancestor (#236)","hint":"If root is p or q, return root. If found in both subtrees, root is LCA."}]}]},{"name":"BST_OPERATIONS","overview":"A Binary Search Tree maintains the invariant: left < root < right. This enables O(log n) search, insert, delete in balanced trees. Inorder traversal of a BST yields sorted order. Many BST problems reduce to 'use the BST property to go left or right'.","variants":[{"name":"Search in BST","description":"Compare target with current node. Go left if target < node, right if target > node. O(h) where h is height.","when":"Find element, check existence, find floor/ceiling.","template":"// Search in BST\npublic TreeNode searchBST(TreeNode root, int val) {\n    if (root == null || root.val == val) return root;\n\n    if (val < root.val) {\n        return searchBST(root.left, val);\n    } else {\n        return searchBST(root.right, val);\n    }\n}\n\n// Iterative version (often preferred)\npublic TreeNode searchBSTIterative(TreeNode root, int val) {\n    while (root != null && root.val != val) {\n        root = (val < root.val) ? root.left : root.right;\n    }\n    return root;\n}","problems":[{"name":"Search in a BST (#700)","hint":"Go left if val < root.val, right otherwise. Return node or null."},{"name":"Closest Binary Search Tree Value (#270)","hint":"Track closest while traversing. Update when |node.val - target| improves."},{"name":"Two Sum IV - Input is a BST (#653)","hint":"HashSet + DFS. Or two pointers with BST iterator (next + before)."}]},{"name":"Insert into BST","description":"Navigate to the correct leaf position (where node would be if it existed), then insert. Maintain BST property.","when":"Build BST from scratch, add elements dynamically.","template":"// Insert into BST (recursive)\npublic TreeNode insertIntoBST(TreeNode root, int val) {\n    if (root == null) return new TreeNode(val);\n\n    if (val < root.val) {\n        root.left = insertIntoBST(root.left, val);\n    } else {\n        root.right = insertIntoBST(root.right, val);\n    }\n    return root;\n}\n\n// Iterative version\npublic TreeNode insertIterative(TreeNode root, int val) {\n    if (root == null) return new TreeNode(val);\n\n    TreeNode curr = root;\n    while (true) {\n        if (val < curr.val) {\n            if (curr.left == null) { curr.left = new TreeNode(val); break; }\n            curr = curr.left;\n        } else {\n            if (curr.right == null) { curr.right = new TreeNode(val); break; }\n            curr = curr.right;\n        }\n    }\n    return root;\n}","problems":[{"name":"Insert into a BST (#701)","hint":"Navigate to null position, insert. Return modified root."},{"name":"Convert Sorted Array to BST (#108)","hint":"Mid element = root. Recursively build left from left half, right from right half."},{"name":"Convert Sorted List to BST (#109)","hint":"Find mid with slow/fast pointers. Or use inorder simulation with global pointer."}]},{"name":"Delete from BST","description":"Three cases: (1) leaf → just remove, (2) one child → replace with child, (3) two children → replace with inorder successor/predecessor, then delete that.","when":"Remove element while maintaining BST property.","template":"// Delete from BST\npublic TreeNode deleteNode(TreeNode root, int key) {\n    if (root == null) return null;\n\n    if (key < root.val) {\n        root.left = deleteNode(root.left, key);\n    } else if (key > root.val) {\n        root.right = deleteNode(root.right, key);\n    } else {\n        // Found node to delete\n        if (root.left == null) return root.right;\n        if (root.right == null) return root.left;\n\n        // Two children: find inorder successor (min in right subtree)\n        TreeNode successor = findMin(root.right);\n        root.val = successor.val;\n        root.right = deleteNode(root.right, successor.val);\n    }\n    return root;\n}\n\nprivate TreeNode findMin(TreeNode node) {\n    while (node.left != null) node = node.left;\n    return node;\n}","problems":[{"name":"Delete Node in a BST (#450)","hint":"Three cases: leaf, one child, two children. For two children, use successor."},{"name":"Trim a BST (#669)","hint":"If root.val < low, return trimmed right. If root.val > high, return trimmed left."}]},{"name":"Validate BST","description":"Every node must satisfy: min < node.val < max. Pass bounds down, or do inorder and check sorted order.","when":"Verify BST property, check if tree is valid BST.","template":"// Validate BST with bounds\npublic boolean isValidBST(TreeNode root) {\n    return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);\n}\n\nprivate boolean validate(TreeNode node, long min, long max) {\n    if (node == null) return true;\n    if (node.val <= min || node.val >= max) return false;\n\n    return validate(node.left, min, node.val)\n        && validate(node.right, node.val, max);\n}\n\n// Inorder approach: each value must be > previous\nprivate Integer prev = null;\n\npublic boolean isValidBSTInorder(TreeNode root) {\n    if (root == null) return true;\n    if (!isValidBSTInorder(root.left)) return false;\n    if (prev != null && root.val <= prev) return false;\n    prev = root.val;\n    return isValidBSTInorder(root.right);\n}","problems":[{"name":"Validate Binary Search Tree (#98)","hint":"Bounds approach: pass (min, max). Or inorder: check each > prev."},{"name":"Recover Binary Search Tree (#99)","hint":"Inorder finds two swapped nodes (violations). Swap their values back."}]},{"name":"BST Range Queries","description":"Exploit BST property to prune search space. If node.val < low, only search right. If node.val > high, only search left.","when":"Range sum, count nodes in range, kth smallest, inorder successor.","template":"// Range Sum BST\npublic int rangeSumBST(TreeNode root, int low, int high) {\n    if (root == null) return 0;\n\n    if (root.val < low) {\n        return rangeSumBST(root.right, low, high);\n    }\n    if (root.val > high) {\n        return rangeSumBST(root.left, low, high);\n    }\n    // low <= root.val <= high\n    return root.val\n         + rangeSumBST(root.left, low, high)\n         + rangeSumBST(root.right, low, high);\n}","problems":[{"name":"Range Sum of BST (#938)","hint":"If node.val < low, go right only. If > high, go left only. Else add and recurse both."},{"name":"Kth Smallest Element (#230)","hint":"Inorder traversal, count nodes. When count == k, return value. Or augment tree with subtree sizes."},{"name":"Inorder Successor in BST (#285)","hint":"If p.val < root.val, successor might be root, search left. Else search right."}]}]},{"name":"ADVANCED_PATTERNS","overview":"Beyond basic traversals and BST operations, advanced tree patterns include tree construction from traversals, serialization, finding LCA, path queries, and tree DP.","variants":[{"name":"Construct Tree from Traversals","description":"Build a binary tree from preorder+inorder or postorder+inorder. The first/last element of pre/post order is the root. Find root in inorder to determine left/right subtree sizes.","when":"Reconstruct tree from serialization, interview classic.","template":"// Build tree from preorder + inorder\nprivate int preIndex = 0;\nprivate Map<Integer, Integer> inorderMap = new HashMap<>();\n\npublic TreeNode buildTree(int[] preorder, int[] inorder) {\n    for (int i = 0; i < inorder.length; i++) {\n        inorderMap.put(inorder[i], i);\n    }\n    return build(preorder, 0, inorder.length - 1);\n}\n\nprivate TreeNode build(int[] preorder, int inLeft, int inRight) {\n    if (inLeft > inRight) return null;\n\n    int rootVal = preorder[preIndex++];\n    TreeNode root = new TreeNode(rootVal);\n\n    int inIndex = inorderMap.get(rootVal);\n    root.left = build(preorder, inLeft, inIndex - 1);\n    root.right = build(preorder, inIndex + 1, inRight);\n    return root;\n}","problems":[{"name":"Construct Binary Tree from Preorder and Inorder (#105)","hint":"Preorder[0] = root. Find in inorder to split left/right. HashMap for O(1) lookup."},{"name":"Construct Binary Tree from Inorder and Postorder (#106)","hint":"Postorder[last] = root. Process postorder right-to-left. Build right subtree before left."},{"name":"Construct BST from Preorder (#1008)","hint":"No inorder needed. Use upper bound: if val > bound, return null. O(n)."}]},{"name":"Lowest Common Ancestor (LCA)","description":"The LCA of two nodes is the deepest node that is an ancestor of both. If nodes are in different subtrees, current node is LCA.","when":"Find LCA, distance between nodes, path queries.","template":"// LCA of Binary Tree\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    if (root == null || root == p || root == q) return root;\n\n    TreeNode left = lowestCommonAncestor(root.left, p, q);\n    TreeNode right = lowestCommonAncestor(root.right, p, q);\n\n    if (left != null && right != null) return root;  // p, q in different subtrees\n    return left != null ? left : right;\n}\n\n// LCA in BST (use BST property)\npublic TreeNode lcaBST(TreeNode root, TreeNode p, TreeNode q) {\n    if (p.val < root.val && q.val < root.val) {\n        return lcaBST(root.left, p, q);\n    }\n    if (p.val > root.val && q.val > root.val) {\n        return lcaBST(root.right, p, q);\n    }\n    return root;  // split point or one equals root\n}","problems":[{"name":"Lowest Common Ancestor of a Binary Tree (#236)","hint":"If found in both subtrees, return root. If one subtree, return that. Post-order natural fit."},{"name":"Lowest Common Ancestor of a BST (#235)","hint":"If both < root, go left. If both > root, go right. Else root is LCA."},{"name":"LCA of Deepest Leaves (#1123)","hint":"Return (node, depth). LCA is where left.depth == right.depth at deepest level."}]},{"name":"Serialize / Deserialize Tree","description":"Convert tree to string and back. Use preorder with null markers for full reconstruction. BFS also works.","when":"Store tree, transmit tree structure, codec design.","template":"// Serialize (preorder with null markers)\npublic String serialize(TreeNode root) {\n    StringBuilder sb = new StringBuilder();\n    serializeHelper(root, sb);\n    return sb.toString();\n}\n\nprivate void serializeHelper(TreeNode node, StringBuilder sb) {\n    if (node == null) {\n        sb.append(\"#,\");\n        return;\n    }\n    sb.append(node.val).append(\",\");\n    serializeHelper(node.left, sb);\n    serializeHelper(node.right, sb);\n}\n\n// Deserialize\nprivate int index = 0;\n\npublic TreeNode deserialize(String data) {\n    String[] nodes = data.split(\",\");\n    return deserializeHelper(nodes);\n}\n\nprivate TreeNode deserializeHelper(String[] nodes) {\n    if (nodes[index].equals(\"#\")) {\n        index++;\n        return null;\n    }\n    TreeNode node = new TreeNode(Integer.parseInt(nodes[index++]));\n    node.left = deserializeHelper(nodes);\n    node.right = deserializeHelper(nodes);\n    return node;\n}","problems":[{"name":"Serialize and Deserialize Binary Tree (#297)","hint":"Preorder with '#' for null. Deserialize recursively with index pointer."},{"name":"Serialize and Deserialize BST (#449)","hint":"No null markers needed. Use bounds during deserialize. More compact."},{"name":"Verify Preorder Serialization (#331)","hint":"Count slots: start with 1, each number adds 1 (uses 1, creates 2), each # uses 1. End with 0."}]},{"name":"Tree DP / Path Problems","description":"Dynamic programming on trees. Typically compute a value for each node based on its children. Often involves 'include this node' vs 'exclude this node' choices.","when":"House robber III, max path sum, tree coloring, tree games.","template":"// House Robber III: rob or don't rob each node\npublic int rob(TreeNode root) {\n    int[] result = robHelper(root);\n    return Math.max(result[0], result[1]);\n}\n\n// Returns [notRobbed, robbed]\nprivate int[] robHelper(TreeNode node) {\n    if (node == null) return new int[] {0, 0};\n\n    int[] left = robHelper(node.left);\n    int[] right = robHelper(node.right);\n\n    // If we don't rob this node, we can take max of each child\n    int notRobbed = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\n    // If we rob this node, children must not be robbed\n    int robbed = node.val + left[0] + right[0];\n\n    return new int[] {notRobbed, robbed};\n}","problems":[{"name":"House Robber III (#337)","hint":"Return [notRob, rob] for each node. Post-order DP. O(n) with memoization."},{"name":"Binary Tree Maximum Path Sum (#124)","hint":"Max path through node = val + max(0, left) + max(0, right). Return single branch for parent."},{"name":"Distribute Coins in Binary Tree (#979)","hint":"Post-order. Each node passes excess coins up. Count total moves as |excess| at each node."},{"name":"Binary Tree Cameras (#968)","hint":"Greedy post-order. States: covered, has camera, not covered. Minimize cameras."}]}]}]},"graphs":{"sections":["Graph Fundamentals","BFS — Breadth-First Search","DFS — Depth-First Search","Topological Sort","Union-Find (DSU)","Pattern Recognition","Formulas & Tips","Revision Cards"],"patterns":[{"name":"FUNDAMENTALS","overview":"","variants":[]},{"name":"BFS_CONTENT","overview":"BFS explores level-by-level from a source. Uses a queue. Guarantees shortest path in UNWEIGHTED graphs. Time: O(V+E). Space: O(V) for the queue and visited set.","variants":[{"name":"Shortest Path (Unweighted)","description":"BFS finds shortest path in unweighted graphs because it explores all nodes at distance d before any node at distance d+1.","when":"Minimum steps, shortest path in grid, word ladder, minimum operations.","template":"// BFS returns distance, not just reachability\n// The level counter IS the shortest distance\n// To reconstruct path: store parent pointers\nMap<Integer, Integer> parent = new HashMap<>();\nparent.put(start, -1);\n// In BFS loop: parent.put(neighbor, curr);\n// Backtrack from target using parent map","problems":[{"name":"Shortest Path in Binary Matrix (#1091)","hint":"BFS from (0,0). 8-directional. Return level when reaching (n-1,n-1)."},{"name":"Word Ladder (#127)","hint":"BFS on implicit graph. Each word is a node. Edge exists if words differ by one char."},{"name":"01 Matrix (#542)","hint":"Multi-source BFS: start from ALL zeros (not single source). Expand outward."},{"name":"Rotting Oranges (#994)","hint":"Multi-source BFS from all rotten oranges. Count levels until no more fresh."}]},{"name":"Multi-Source BFS","description":"Start BFS from multiple sources simultaneously. Add ALL sources to queue before starting.","when":"Nearest from any of K sources, spreading from multiple origins, distance to nearest 0.","template":"// Multi-source BFS: add all sources first\nQueue<int[]> queue = new LinkedList<>();\nfor (int i = 0; i < rows; i++) {\n    for (int j = 0; j < cols; j++) {\n        if (grid[i][j] == 0) { // 0 is a source\n            queue.offer(new int[]{i, j});\n            // Mark visited or set distance = 0\n        }\n    }\n}\n// Standard BFS from here — expands from ALL sources simultaneously","problems":[{"name":"01 Matrix (#542)","hint":"Multi-source BFS from all 0s. Distance to nearest 0."},{"name":"Walls and Gates (#286)","hint":"Multi-source BFS from all gates. Fill rooms with distance to nearest gate."},{"name":"As Far from Land as Possible (#1162)","hint":"Multi-source BFS from all land cells. Find max distance water cell."},{"name":"Map of Highest Peak (#1765)","hint":"Multi-source BFS from all water cells (height 0). Land cells get increasing height."}]},{"name":"BFS with State","description":"When simple (row, col) or node ID isn't enough. State = (position, additional info).","when":"Keys and doors, remaining moves, visited subset, carrying items.","template":"// State = (row, col, keys bitmask)\n// visited = Set<String> or boolean[row][col][stateMask]\nQueue<int[]> queue = new LinkedList<>();\nSet<String> visited = new HashSet<>();\nqueue.offer(new int[]{startR, startC, 0}); // 0 = no keys\nvisited.add(startR + \",\" + startC + \",\" + 0);\n\nwhile (!queue.isEmpty()) {\n    int[] curr = queue.poll();\n    int r = curr[0], c = curr[1], keys = curr[2];\n    // Process...\n    String state = nr + \",\" + nc + \",\" + newKeys;\n    if (!visited.contains(state)) {\n        visited.add(state);\n        queue.offer(new int[]{nr, nc, newKeys});\n    }\n}","problems":[{"name":"Shortest Path to Get All Keys (#864)","hint":"State = (row, col, keysMask). BFS. Goal: keysMask has all bits set."},{"name":"Shortest Path in Grid with Obstacles (#1293)","hint":"State = (row, col, obstaclesRemoved). Can remove up to k obstacles."},{"name":"Minimum Moves to Reach Target (#1197)","hint":"State includes knight's current position AND allowed moves state."}]},{"name":"0-1 BFS","description":"BFS variant for graphs with edge weights 0 or 1 only. Use deque: push weight-0 edges to FRONT, weight-1 edges to BACK.","when":"Binary-weighted shortest path, flip 0/1 to create path, some grid problems.","template":"// 0-1 BFS with Deque\nDeque<int[]> deque = new ArrayDeque<>();\nint[] dist = new int[n];\nArrays.fill(dist, Integer.MAX_VALUE);\ndist[start] = 0;\ndeque.offerFirst(new int[]{start, 0});\n\nwhile (!deque.isEmpty()) {\n    int[] curr = deque.pollFirst();\n    int u = curr[0], d = curr[1];\n    if (d > dist[u]) continue; // Stale entry\n    \n    for (int[] edge : graph.get(u)) {\n        int v = edge[0], w = edge[1]; // w is 0 or 1\n        if (dist[u] + w < dist[v]) {\n            dist[v] = dist[u] + w;\n            if (w == 0) deque.offerFirst(new int[]{v, dist[v]});\n            else deque.offerLast(new int[]{v, dist[v]});\n        }\n    }\n}","problems":[{"name":"Minimum Cost to Make at Least One Valid Path (#1368)","hint":"Grid with arrows. Moving in arrow direction = cost 0. Otherwise cost 1. 0-1 BFS."},{"name":"Minimum Obstacle Removal to Reach Corner (#2290)","hint":"Empty cell = cost 0. Obstacle = cost 1. 0-1 BFS for shortest path."}]}]},{"name":"DFS_CONTENT","overview":"DFS explores as deep as possible before backtracking. Uses recursion (implicit stack) or explicit stack. Time: O(V+E). Space: O(V) for recursion stack or visited set.","variants":[{"name":"Connected Components / Flood Fill","description":"Count or mark distinct connected regions. Classic DFS use case.","when":"Number of islands, count components, flood fill, surrounded regions.","template":"// Count connected components\nint count = 0;\nboolean[] visited = new boolean[n];\nfor (int i = 0; i < n; i++) {\n    if (!visited[i]) {\n        dfs(i, graph, visited);\n        count++;\n    }\n}\n\n// Grid flood fill\nvoid dfs(int[][] grid, int r, int c, int target, int replacement) {\n    if (r < 0 || c < 0 || r >= grid.length || c >= grid[0].length) return;\n    if (grid[r][c] != target) return;\n    grid[r][c] = replacement; // Mark visited by changing value\n    dfs(grid, r+1, c, target, replacement);\n    dfs(grid, r-1, c, target, replacement);\n    dfs(grid, r, c+1, target, replacement);\n    dfs(grid, r, c-1, target, replacement);\n}","problems":[{"name":"Number of Islands (#200)","hint":"DFS/BFS from each unvisited '1'. Mark as visited (set to '0'). Count components."},{"name":"Number of Provinces (#547)","hint":"Adjacency matrix. DFS from each unvisited city. Count components."},{"name":"Flood Fill (#733)","hint":"DFS from starting pixel. Change all connected same-color pixels."},{"name":"Surrounded Regions (#130)","hint":"DFS from border 'O's to mark safe. Flip remaining 'O's to 'X'."}]},{"name":"Cycle Detection","description":"Detect if graph contains a cycle. Different techniques for directed vs undirected.","when":"Course schedule, deadlock detection, validate tree structure.","template":"// Directed graph: three states (WHITE=0, GRAY=1, BLACK=2)\nint[] state = new int[n]; // 0=unvisited, 1=in-progress, 2=done\nboolean hasCycle(int node, List<List<Integer>> graph) {\n    state[node] = 1; // In-progress\n    for (int neighbor : graph.get(node)) {\n        if (state[neighbor] == 1) return true; // Back edge = cycle\n        if (state[neighbor] == 0 && hasCycle(neighbor, graph)) return true;\n    }\n    state[node] = 2; // Done\n    return false;\n}\n\n// Undirected graph: track parent to avoid false positive\nboolean hasCycle(int node, int parent, List<List<Integer>> graph, boolean[] visited) {\n    visited[node] = true;\n    for (int neighbor : graph.get(node)) {\n        if (!visited[neighbor]) {\n            if (hasCycle(neighbor, node, graph, visited)) return true;\n        } else if (neighbor != parent) {\n            return true; // Visited and not parent = cycle\n        }\n    }\n    return false;\n}","problems":[{"name":"Course Schedule (#207)","hint":"Directed cycle detection. If cycle exists, can't finish all courses."},{"name":"Course Schedule II (#210)","hint":"Topological sort. Return order or empty array if cycle."},{"name":"Graph Valid Tree (#261)","hint":"Tree = connected + no cycle. Check edges == n-1 AND connected."},{"name":"Redundant Connection (#684)","hint":"Find the edge that creates a cycle. Union-Find or DFS."}]},{"name":"Path Finding / Backtracking","description":"Find all paths, check if path exists, or find path with constraints.","when":"All paths from source to target, path with specific properties, maze solving.","template":"// All paths from source to target (DAG)\nList<List<Integer>> result = new ArrayList<>();\nList<Integer> path = new ArrayList<>();\n\nvoid dfs(int node, int target, List<List<Integer>> graph) {\n    path.add(node);\n    if (node == target) {\n        result.add(new ArrayList<>(path)); // Copy path\n    } else {\n        for (int neighbor : graph.get(node)) {\n            dfs(neighbor, target, graph);\n        }\n    }\n    path.remove(path.size() - 1); // Backtrack\n}","problems":[{"name":"All Paths From Source to Target (#797)","hint":"DAG guaranteed. DFS with backtracking. Collect all paths to node n-1."},{"name":"Path with Maximum Gold (#1219)","hint":"Grid backtracking. Visit each cell at most once per path. Track max gold."},{"name":"Word Search (#79)","hint":"DFS + backtracking. Mark visited during DFS, unmark on backtrack."},{"name":"Longest Increasing Path in a Matrix (#329)","hint":"DFS + memoization. dp[i][j] = longest path starting from (i,j)."}]},{"name":"DFS with Memoization","description":"Cache DFS results to avoid recomputation. Converts exponential to polynomial.","when":"Counting paths, longest path in DAG, any overlapping subproblems in graph.","template":"// DFS + memo for counting/optimization\nint[] memo = new int[n];\nArrays.fill(memo, -1);\n\nint dfs(int node, List<List<Integer>> graph) {\n    if (memo[node] != -1) return memo[node];\n    \n    int result = baseCase; // e.g., 1 if target node\n    for (int neighbor : graph.get(node)) {\n        result = combine(result, dfs(neighbor, graph)); // e.g., +=, max\n    }\n    memo[node] = result;\n    return result;\n}","problems":[{"name":"Longest Increasing Path in a Matrix (#329)","hint":"memo[i][j] = longest path from (i,j). DFS to all valid neighbors."},{"name":"All Paths from Source Lead to Destination (#1059)","hint":"Memo whether each node leads only to destination. Three states."},{"name":"Number of Ways to Arrive at Destination (#1976)","hint":"Dijkstra + DP. Count paths with minimum distance."}]}]},{"name":"TOPO_SORT_CONTENT","overview":"Linear ordering of vertices such that for every edge u→v, u comes before v. Only possible for DAGs (directed acyclic graphs). If cycle exists, topological sort is impossible.","variants":[]},{"name":"UNION_FIND_CONTENT","overview":"Disjoint Set Union (DSU). Efficiently tracks which elements belong to the same set. Two operations: find(x) and union(x, y). Near O(1) with path compression + union by rank.","variants":[{"name":"Basic Connectivity","description":"Check if two elements are in the same set, count connected components.","when":"Number of connected components, friend circles, accounts merge.","template":"// Count components after processing edges\nUnionFind uf = new UnionFind(n);\nfor (int[] edge : edges) {\n    uf.union(edge[0], edge[1]);\n}\nreturn uf.getCount();","problems":[{"name":"Number of Provinces (#547)","hint":"Union friends. Return uf.getCount()."},{"name":"Number of Connected Components (#323)","hint":"Union edges. Return uf.getCount()."},{"name":"Redundant Connection (#684)","hint":"Union edges. The edge that doesn't reduce count is redundant."},{"name":"Accounts Merge (#721)","hint":"Union emails belonging to same account. Group by root."}]},{"name":"Cycle Detection","description":"An edge creates a cycle if both endpoints are already in the same set.","when":"Find redundant edge, validate tree, detect when merging same component.","template":"// Edge creates cycle if find(u) == find(v) BEFORE union\nfor (int[] edge : edges) {\n    if (uf.find(edge[0]) == uf.find(edge[1])) {\n        // This edge creates a cycle!\n        return edge;\n    }\n    uf.union(edge[0], edge[1]);\n}","problems":[{"name":"Redundant Connection (#684)","hint":"First edge where both ends already connected."},{"name":"Graph Valid Tree (#261)","hint":"Tree: exactly n-1 edges AND no cycle. Check with UF."},{"name":"Redundant Connection II (#685)","hint":"Directed graph. Handle two cases: node with 2 parents, or cycle."}]},{"name":"Union-Find with Size/Weight","description":"Track additional info per component: size, sum, min/max.","when":"Largest component, sum of component values, component statistics.","template":"class UnionFind {\n    int[] parent, size;\n    int maxSize;\n    \n    UnionFind(int n) {\n        parent = new int[n];\n        size = new int[n];\n        maxSize = 1;\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n            size[i] = 1;\n        }\n    }\n    \n    // Union by size + track max\n    boolean union(int x, int y) {\n        int px = find(x), py = find(y);\n        if (px == py) return false;\n        if (size[px] < size[py]) { int temp = px; px = py; py = temp; }\n        parent[py] = px;\n        size[px] += size[py];\n        maxSize = Math.max(maxSize, size[px]);\n        return true;\n    }\n}","problems":[{"name":"Largest Component Size by Common Factor (#952)","hint":"Union numbers sharing prime factors. Track max component size."},{"name":"Process Restricted Friend Requests (#2076)","hint":"Track component members. Check restrictions before union."},{"name":"Minimize Malware Spread (#924)","hint":"Find which initial node, if removed, minimizes final infection count."}]},{"name":"Grid Union-Find","description":"Map 2D grid coordinates to 1D index. Union adjacent cells.","when":"Number of islands, making cells connected, grid component queries.","template":"// 2D to 1D mapping\nint index(int r, int c, int cols) {\n    return r * cols + c;\n}\n\n// Number of islands using Union-Find\nUnionFind uf = new UnionFind(rows * cols);\nint water = 0;\nfor (int r = 0; r < rows; r++) {\n    for (int c = 0; c < cols; c++) {\n        if (grid[r][c] == '0') { water++; continue; }\n        // Union with right and down neighbors (avoid double counting)\n        if (c + 1 < cols && grid[r][c+1] == '1')\n            uf.union(index(r, c, cols), index(r, c+1, cols));\n        if (r + 1 < rows && grid[r+1][c] == '1')\n            uf.union(index(r, c, cols), index(r+1, c, cols));\n    }\n}\nreturn uf.getCount() - water;","problems":[{"name":"Number of Islands (#200)","hint":"UF alternative to DFS. Map grid to 1D. Union land neighbors."},{"name":"Number of Islands II (#305)","hint":"Process addLand operations online. Union with neighbors. Track count."},{"name":"Making A Large Island (#827)","hint":"Label components with sizes. For each 0, check sum of adjacent component sizes."},{"name":"Swim in Rising Water (#778)","hint":"Binary search + UF: can you reach end with max height ≤ mid?"}]},{"name":"Union-Find with Rollback","description":"Undo union operations. Required for some online/offline algorithms.","when":"Dynamic connectivity with deletions, persistent DSU, divide and conquer on queries.","template":"// Cannot use path compression with rollback\n// Use union by rank + explicit stack of operations\nStack<int[]> history = new Stack<>(); // [child, oldParent, oldRankOfParent]\n\nvoid unionWithRollback(int x, int y) {\n    int px = find(x), py = find(y);\n    if (px == py) return;\n    if (rank[px] < rank[py]) { int temp = px; px = py; py = temp; }\n    history.push(new int[]{py, parent[py], rank[px]});\n    parent[py] = px;\n    if (rank[px] == rank[py]) rank[px]++;\n}\n\nvoid rollback() {\n    int[] op = history.pop();\n    parent[op[0]] = op[1];\n    rank[find(op[0])] = op[2];\n}","problems":[{"name":"Online Queries of Dynamic Connectivity","hint":"Use DSU with rollback for divide and conquer."}]}]}]},"heaps":{"sections":["Heap Fundamentals","Top-K Problems","Merge K Sorted","Two-Heap Pattern","Priority Scheduling","Advanced Patterns","Pattern Recognition","Formulas & Tips","Revision Cards"],"patterns":[{"name":"HEAP_FUNDAMENTALS","overview":"A heap is a complete binary tree satisfying the heap property: in a min-heap, parent ≤ children; in a max-heap, parent ≥ children. In Java, use PriorityQueue<> — it's a min-heap by default. Heaps give O(1) access to min/max and O(log n) insert/remove. They're the go-to when you need to repeatedly find and remove the smallest or largest element.","variants":[]},{"name":"TOP_K_CONTENT","overview":"Top-K problems ask for the K largest, smallest, or most frequent elements. Two main approaches: (1) Use a heap of size K for O(n log k), or (2) Use Quickselect for O(n) average. The heap approach is simpler, more stable, and works for streaming data.","variants":[{"name":"K Largest / K Smallest Elements","description":"Find the K largest (or smallest) elements from a collection. Use opposite heap type with size K.","when":"Top K, K closest, K most frequent (after counting).","template":"// K largest elements — use MIN-heap of size K\npublic int[] topKLargest(int[] nums, int k) {\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n    for (int num : nums) {\n        minHeap.offer(num);\n        if (minHeap.size() > k) {\n            minHeap.poll(); // Remove smallest, keeping K largest\n        }\n    }\n    // Heap now contains K largest\n    int[] result = new int[k];\n    for (int i = k - 1; i >= 0; i--) {\n        result[i] = minHeap.poll();\n    }\n    return result;\n}\n\n// K smallest elements — use MAX-heap of size K\npublic int[] topKSmallest(int[] nums, int k) {\n    PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\n    for (int num : nums) {\n        maxHeap.offer(num);\n        if (maxHeap.size() > k) {\n            maxHeap.poll(); // Remove largest, keeping K smallest\n        }\n    }\n    return maxHeap.stream().mapToInt(i -> i).toArray();\n}","problems":[{"name":"Kth Largest Element (#215)","hint":"Min-heap size k. After processing all, peek() = kth largest."},{"name":"K Closest Points to Origin (#973)","hint":"Max-heap by distance, size k. Compare squared distances to avoid sqrt."},{"name":"Top K Frequent Elements (#347)","hint":"Count freq with HashMap. Then top-K by frequency using min-heap of size k."},{"name":"Top K Frequent Words (#692)","hint":"Same as above but with tiebreaker: if same freq, smaller lexicographic order wins."}]},{"name":"Kth Element (Single Value)","description":"Find exactly the Kth largest/smallest element, not all K of them.","when":"Kth largest, Kth smallest, median (k = n/2).","template":"// Kth largest — min-heap of size k, peek at end\npublic int findKthLargest(int[] nums, int k) {\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n    for (int num : nums) {\n        minHeap.offer(num);\n        if (minHeap.size() > k) {\n            minHeap.poll();\n        }\n    }\n    return minHeap.peek(); // The smallest of the K largest = Kth largest\n}\n\n// Alternative: Quickselect (O(n) average, O(n²) worst)\n// Partition like quicksort, but only recurse into one half\npublic int quickselect(int[] nums, int k) {\n    int target = nums.length - k; // Convert to \"kth smallest\" index\n    int left = 0, right = nums.length - 1;\n    while (left < right) {\n        int pivot = partition(nums, left, right);\n        if (pivot == target) return nums[pivot];\n        else if (pivot < target) left = pivot + 1;\n        else right = pivot - 1;\n    }\n    return nums[left];\n}","problems":[{"name":"Kth Largest Element (#215)","hint":"Heap: O(n log k). Quickselect: O(n) avg. Heap is safer for interviews."},{"name":"Kth Smallest in Matrix (#378)","hint":"Binary search on value range, or min-heap with (val, row, col) tuples."},{"name":"Kth Smallest Pair Distance (#719)","hint":"Binary search on distance + count pairs ≤ mid."}]},{"name":"Top K with Custom Comparison","description":"When elements need custom ordering — by frequency, by distance, by multiple criteria.","when":"Most frequent, closest points, custom scoring.","template":"// Top K frequent — custom comparator on frequency\npublic int[] topKFrequent(int[] nums, int k) {\n    // Step 1: Count frequencies\n    Map<Integer, Integer> freq = new HashMap<>();\n    for (int n : nums) freq.merge(n, 1, Integer::sum);\n    \n    // Step 2: Min-heap by frequency, size k\n    PriorityQueue<Integer> pq = new PriorityQueue<>(\n        Comparator.comparingInt(freq::get) // Sort by frequency ascending\n    );\n    \n    for (int num : freq.keySet()) {\n        pq.offer(num);\n        if (pq.size() > k) pq.poll();\n    }\n    \n    return pq.stream().mapToInt(i -> i).toArray();\n}\n\n// K closest points — max-heap by distance, size k\npublic int[][] kClosest(int[][] points, int k) {\n    PriorityQueue<int[]> maxHeap = new PriorityQueue<>(\n        (a, b) -> (b[0]*b[0] + b[1]*b[1]) - (a[0]*a[0] + a[1]*a[1])\n    );\n    for (int[] p : points) {\n        maxHeap.offer(p);\n        if (maxHeap.size() > k) maxHeap.poll();\n    }\n    return maxHeap.toArray(new int[k][]);\n}","problems":[{"name":"Top K Frequent Elements (#347)","hint":"HashMap for freq, min-heap by freq for top-K."},{"name":"K Closest Points (#973)","hint":"Max-heap by distance (squared), size k."},{"name":"Reorganize String (#767)","hint":"Max-heap by frequency. Greedily place most frequent, ensuring no adjacent same."}]},{"name":"Streaming / Online Top-K","description":"Maintain top-K as elements arrive one by one. Can't reprocess old data.","when":"Kth largest in stream, real-time top-K, sliding window queries.","template":"// Kth largest in a stream\nclass KthLargest {\n    private PriorityQueue<Integer> minHeap;\n    private int k;\n    \n    public KthLargest(int k, int[] nums) {\n        this.k = k;\n        minHeap = new PriorityQueue<>();\n        for (int n : nums) add(n);\n    }\n    \n    public int add(int val) {\n        minHeap.offer(val);\n        if (minHeap.size() > k) minHeap.poll();\n        return minHeap.peek();\n    }\n}","problems":[{"name":"Kth Largest Element in Stream (#703)","hint":"Min-heap of size k. Each add: offer, poll if > k, peek for answer."},{"name":"Find Median from Data Stream (#295)","hint":"Two heaps: max-heap for lower half, min-heap for upper half. Balance sizes."}]}]},{"name":"MERGE_K_CONTENT","overview":"Merge K sorted lists/arrays into one sorted result. The heap approach processes all sources in parallel: always extend the result with the globally smallest element. Time: O(N log k) where N = total elements, k = number of lists.","variants":[{"name":"Merge K Sorted Lists","description":"Merge K linked lists into one sorted list. Classic heap problem.","when":"Multiple sorted streams, external merge sort, distributed sorting.","template":"// Already shown above. Key points:\n// 1. Heap contains at most K nodes (one from each list)\n// 2. Each of N total nodes enters and leaves heap once\n// 3. Time: O(N log k), Space: O(k) for heap","problems":[{"name":"Merge K Sorted Lists (#23)","hint":"Min-heap of list heads. Poll smallest, add its next. Repeat until empty."},{"name":"Merge Sorted Array (#88)","hint":"K=2, already in-place. Two pointers from end. Not a heap problem."}]},{"name":"Merge K Sorted Arrays / Iterators","description":"Same pattern but with arrays or iterators instead of linked lists.","when":"Merge sorted files, K-way merge sort, sorted matrix search.","template":"// Merge K sorted arrays\npublic int[] mergeKArrays(int[][] arrays) {\n    // PQ entry: [value, arrayIndex, elementIndex]\n    PriorityQueue<int[]> pq = new PriorityQueue<>(\n        Comparator.comparingInt(a -> a[0])\n    );\n    \n    int total = 0;\n    for (int i = 0; i < arrays.length; i++) {\n        if (arrays[i].length > 0) {\n            pq.offer(new int[]{arrays[i][0], i, 0});\n            total += arrays[i].length;\n        }\n    }\n    \n    int[] result = new int[total];\n    int idx = 0;\n    \n    while (!pq.isEmpty()) {\n        int[] curr = pq.poll();\n        result[idx++] = curr[0];\n        \n        int arrIdx = curr[1], elemIdx = curr[2];\n        if (elemIdx + 1 < arrays[arrIdx].length) {\n            pq.offer(new int[]{arrays[arrIdx][elemIdx + 1], arrIdx, elemIdx + 1});\n        }\n    }\n    \n    return result;\n}","problems":[{"name":"Kth Smallest in Sorted Matrix (#378)","hint":"Treat each row as a sorted list. Merge with heap, stop at kth element."},{"name":"Smallest Range Covering Elements from K Lists (#632)","hint":"Heap + sliding window. Track max while polling min. Minimize range."}]},{"name":"Find Kth Smallest in K Sorted Sources","description":"Don't need full merge — just find the Kth element.","when":"Kth smallest in matrix, Kth smallest pair sum.","template":"// Kth Smallest Element in Sorted Matrix\npublic int kthSmallest(int[][] matrix, int k) {\n    int n = matrix.length;\n    // PQ entry: [value, row, col]\n    PriorityQueue<int[]> pq = new PriorityQueue<>(\n        Comparator.comparingInt(a -> a[0])\n    );\n    \n    // Start with first element of each row (or just first column)\n    for (int i = 0; i < n; i++) {\n        pq.offer(new int[]{matrix[i][0], i, 0});\n    }\n    \n    int result = 0;\n    for (int i = 0; i < k; i++) {\n        int[] curr = pq.poll();\n        result = curr[0];\n        int row = curr[1], col = curr[2];\n        if (col + 1 < n) {\n            pq.offer(new int[]{matrix[row][col + 1], row, col + 1});\n        }\n    }\n    return result;\n}","problems":[{"name":"Kth Smallest in Sorted Matrix (#378)","hint":"Heap: O(k log n). Binary search on value: O(n log(max-min))."},{"name":"Find K Pairs with Smallest Sums (#373)","hint":"Heap of (sum, i, j). Start with (nums1[i], nums2[0]) pairs. Expand j."},{"name":"Kth Smallest Pair Distance (#719)","hint":"Binary search on distance + count pairs ≤ mid. Not a heap problem."}]},{"name":"Divide and Conquer Alternative","description":"Merge lists pairwise, halving the number of lists each round.","when":"When heap constant factor matters, or parallelization is possible.","template":"// Divide and conquer merge — same O(N log k) but different approach\npublic ListNode mergeKLists(ListNode[] lists) {\n    if (lists.length == 0) return null;\n    int interval = 1;\n    while (interval < lists.length) {\n        for (int i = 0; i + interval < lists.length; i += interval * 2) {\n            lists[i] = mergeTwoLists(lists[i], lists[i + interval]);\n        }\n        interval *= 2;\n    }\n    return lists[0];\n}\n\n// Standard merge two sorted lists\nListNode mergeTwoLists(ListNode l1, ListNode l2) {\n    ListNode dummy = new ListNode(0), curr = dummy;\n    while (l1 != null && l2 != null) {\n        if (l1.val < l2.val) { curr.next = l1; l1 = l1.next; }\n        else { curr.next = l2; l2 = l2.next; }\n        curr = curr.next;\n    }\n    curr.next = (l1 != null) ? l1 : l2;\n    return dummy.next;\n}","problems":[{"name":"Merge K Sorted Lists (#23)","hint":"Both heap and divide-conquer are O(N log k). D&C may have better cache behavior."}]}]},{"name":"TWO_HEAP_CONTENT","overview":"The two-heap pattern uses a max-heap and min-heap together to efficiently track the median or balance two halves of a dataset. The max-heap holds the smaller half, the min-heap holds the larger half. The median is at one or both roots.","variants":[{"name":"Running Median","description":"Find median of all elements seen so far, updated with each new element.","when":"Stream of numbers, real-time median, sliding window median.","template":"// Core insight:\n// maxHeap contains smaller half → its root is the largest of small half\n// minHeap contains larger half → its root is the smallest of large half\n// If equal sizes: median = average of both roots\n// If maxHeap has one more: median = maxHeap root\n\n// Invariants to maintain:\n// 1. All elements in maxHeap ≤ all elements in minHeap\n// 2. |maxHeap.size() - minHeap.size()| ≤ 1","problems":[{"name":"Find Median from Data Stream (#295)","hint":"Two heaps. Add to maxHeap, rebalance. O(log n) per add, O(1) median."},{"name":"Sliding Window Median (#480)","hint":"Two heaps + lazy deletion. Track elements to remove, clean on access."}]},{"name":"Sliding Window Median","description":"Find median of each window of size k. Requires handling removals.","when":"Fixed window statistics, moving median.","template":"// Sliding window median with lazy deletion\npublic double[] medianSlidingWindow(int[] nums, int k) {\n    PriorityQueue<Integer> small = new PriorityQueue<>(Collections.reverseOrder()); // max-heap\n    PriorityQueue<Integer> large = new PriorityQueue<>(); // min-heap\n    Map<Integer, Integer> toRemove = new HashMap<>(); // delayed removal\n    \n    double[] result = new double[nums.length - k + 1];\n    \n    // Initialize first window\n    for (int i = 0; i < k; i++) small.offer(nums[i]);\n    for (int i = 0; i < k / 2; i++) large.offer(small.poll());\n    \n    for (int i = k; ; i++) {\n        // Get median\n        result[i - k] = k % 2 == 1 ? small.peek() : ((long)small.peek() + large.peek()) / 2.0;\n        \n        if (i >= nums.length) break;\n        \n        int outgoing = nums[i - k], incoming = nums[i];\n        int balance = 0;\n        \n        // Remove outgoing (lazy)\n        toRemove.merge(outgoing, 1, Integer::sum);\n        balance += (outgoing <= small.peek()) ? -1 : 1;\n        \n        // Add incoming\n        if (!small.isEmpty() && incoming <= small.peek()) {\n            small.offer(incoming);\n            balance++;\n        } else {\n            large.offer(incoming);\n            balance--;\n        }\n        \n        // Rebalance\n        if (balance < 0) { small.offer(large.poll()); balance++; }\n        if (balance > 0) { large.offer(small.poll()); balance--; }\n        \n        // Clean heap tops\n        while (!small.isEmpty() && toRemove.getOrDefault(small.peek(), 0) > 0) {\n            toRemove.merge(small.poll(), -1, Integer::sum);\n        }\n        while (!large.isEmpty() && toRemove.getOrDefault(large.peek(), 0) > 0) {\n            toRemove.merge(large.poll(), -1, Integer::sum);\n        }\n    }\n    return result;\n}","problems":[{"name":"Sliding Window Median (#480)","hint":"Two heaps + lazy deletion. Clean heap tops before accessing."}]},{"name":"IPO / Maximize with Constraints","description":"Choose K items to maximize profit, but each item has a capital requirement.","when":"Selecting best options with prerequisites, resource-constrained optimization.","template":"// IPO: Choose at most k projects to maximize capital\n// Each project has (capital_needed, profit)\npublic int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {\n    int n = profits.length;\n    int[][] projects = new int[n][2];\n    for (int i = 0; i < n; i++) {\n        projects[i] = new int[]{capital[i], profits[i]};\n    }\n    Arrays.sort(projects, (a, b) -> a[0] - b[0]); // Sort by capital needed\n    \n    PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\n    int i = 0;\n    \n    for (int j = 0; j < k; j++) {\n        // Add all projects we can now afford\n        while (i < n && projects[i][0] <= w) {\n            maxHeap.offer(projects[i][1]);\n            i++;\n        }\n        if (maxHeap.isEmpty()) break;\n        w += maxHeap.poll(); // Take most profitable affordable project\n    }\n    return w;\n}","problems":[{"name":"IPO (#502)","hint":"Sort by capital. Max-heap of profits for affordable projects. Greedily pick best."}]}]},{"name":"SCHEDULING_CONTENT","overview":"Priority scheduling uses heaps to manage tasks, jobs, or events by their priority (deadline, importance, timestamp). The heap ensures we always process the highest-priority item next. Common in task schedulers, meeting rooms, and event-driven simulations.","variants":[{"name":"Task Scheduler / CPU Scheduling","description":"Execute tasks with cooldown constraints. Same task can't run within n intervals.","when":"Task scheduling with gaps, CPU scheduling, cooldown-based sequencing.","template":"// Task Scheduler: minimize total time with cooldown n\npublic int leastInterval(char[] tasks, int n) {\n    // Count frequencies\n    int[] freq = new int[26];\n    for (char c : tasks) freq[c - 'A']++;\n    \n    // Max-heap of frequencies\n    PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\n    for (int f : freq) if (f > 0) maxHeap.offer(f);\n    \n    int time = 0;\n    \n    while (!maxHeap.isEmpty()) {\n        List<Integer> temp = new ArrayList<>();\n        int cycle = n + 1; // One cycle = n+1 slots (task + n cooldown)\n        \n        // Fill one cycle\n        while (cycle > 0 && !maxHeap.isEmpty()) {\n            int count = maxHeap.poll();\n            if (count > 1) temp.add(count - 1); // Remaining executions\n            time++;\n            cycle--;\n        }\n        \n        // Add back to heap\n        for (int t : temp) maxHeap.offer(t);\n        \n        // If heap not empty, we need idle time\n        if (!maxHeap.isEmpty()) time += cycle;\n    }\n    return time;\n}\n\n// Math formula alternative: O(n) time, O(1) space\npublic int leastIntervalFormula(char[] tasks, int n) {\n    int[] freq = new int[26];\n    int maxFreq = 0, maxCount = 0;\n    for (char c : tasks) {\n        freq[c - 'A']++;\n        if (freq[c - 'A'] > maxFreq) {\n            maxFreq = freq[c - 'A'];\n            maxCount = 1;\n        } else if (freq[c - 'A'] == maxFreq) {\n            maxCount++;\n        }\n    }\n    // (maxFreq - 1) full cycles of (n + 1) + final partial cycle\n    int minLength = (maxFreq - 1) * (n + 1) + maxCount;\n    return Math.max(minLength, tasks.length);\n}","problems":[{"name":"Task Scheduler (#621)","hint":"Max-heap by freq. Fill cycles of n+1 slots. Add idle if needed."},{"name":"Reorganize String (#767)","hint":"Max-heap by freq. Alternate placements. If freq > (n+1)/2, impossible."},{"name":"Task Scheduler II (#2365)","hint":"HashMap tracks next available time for each task type."}]},{"name":"Meeting Rooms / Interval Scheduling","description":"Find minimum rooms needed, or maximum non-overlapping intervals.","when":"Meeting room allocation, CPU cores needed, concurrent connections.","template":"// Meeting Rooms II: minimum rooms needed\npublic int minMeetingRooms(int[][] intervals) {\n    Arrays.sort(intervals, (a, b) -> a[0] - b[0]); // Sort by start time\n    \n    // Min-heap of end times (earliest ending room is freed first)\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n    \n    for (int[] interval : intervals) {\n        // If earliest ending room is free, reuse it\n        if (!minHeap.isEmpty() && minHeap.peek() <= interval[0]) {\n            minHeap.poll();\n        }\n        // Book a room (new or reused)\n        minHeap.offer(interval[1]);\n    }\n    \n    return minHeap.size(); // Number of rooms in use at peak\n}\n\n// Alternative: Line sweep (event-based)\npublic int minMeetingRoomsSweep(int[][] intervals) {\n    List<int[]> events = new ArrayList<>();\n    for (int[] i : intervals) {\n        events.add(new int[]{i[0], 1});  // Start\n        events.add(new int[]{i[1], -1}); // End\n    }\n    events.sort((a, b) -> a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]);\n    \n    int rooms = 0, maxRooms = 0;\n    for (int[] e : events) {\n        rooms += e[1];\n        maxRooms = Math.max(maxRooms, rooms);\n    }\n    return maxRooms;\n}","problems":[{"name":"Meeting Rooms II (#253)","hint":"Min-heap of end times. For each meeting, check if room frees up."},{"name":"Car Pooling (#1094)","hint":"Line sweep or sort events. Track passengers at each point."},{"name":"My Calendar I, II, III","hint":"I: Just check overlap. II: Allow double, not triple. III: Return max overlap (line sweep)."}]},{"name":"Event-Driven Simulation","description":"Process events in chronological order. Each event may generate new events.","when":"Simulation problems, Dijkstra's algorithm, time-based state changes.","template":"// Process events in time order, generating new events\n// Example: Furthest Building You Can Reach\npublic int furthestBuilding(int[] heights, int bricks, int ladders) {\n    // Min-heap tracks the smallest ladder-replaceable climbs\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n    \n    for (int i = 0; i < heights.length - 1; i++) {\n        int diff = heights[i + 1] - heights[i];\n        if (diff <= 0) continue; // No climb needed\n        \n        // Use a ladder optimistically\n        minHeap.offer(diff);\n        \n        // If we've used too many ladders, replace smallest with bricks\n        if (minHeap.size() > ladders) {\n            bricks -= minHeap.poll();\n            if (bricks < 0) return i;\n        }\n    }\n    return heights.length - 1;\n}","problems":[{"name":"Furthest Building (#1642)","hint":"Use ladders for large climbs (max-heap), bricks for small. Or: min-heap, replace smallest ladder use with bricks."},{"name":"Single-Threaded CPU (#1834)","hint":"Sort by arrival. Min-heap by (process time, index). Simulate time."},{"name":"Process Tasks Using Servers (#1882)","hint":"Two heaps: available servers (by weight), busy servers (by free time)."}]},{"name":"Dijkstra's Algorithm (Shortest Path)","description":"Shortest path in weighted graph. Heap gives next closest unvisited node.","when":"Weighted shortest path, minimum cost path, network routing.","template":"// Dijkstra's shortest path\npublic int[] dijkstra(int n, List<List<int[]>> graph, int source) {\n    int[] dist = new int[n];\n    Arrays.fill(dist, Integer.MAX_VALUE);\n    dist[source] = 0;\n    \n    // Min-heap: [distance, node]\n    PriorityQueue<int[]> pq = new PriorityQueue<>(\n        Comparator.comparingInt(a -> a[0])\n    );\n    pq.offer(new int[]{0, source});\n    \n    while (!pq.isEmpty()) {\n        int[] curr = pq.poll();\n        int d = curr[0], u = curr[1];\n        \n        if (d > dist[u]) continue; // Stale entry\n        \n        for (int[] edge : graph.get(u)) {\n            int v = edge[0], w = edge[1];\n            if (dist[u] + w < dist[v]) {\n                dist[v] = dist[u] + w;\n                pq.offer(new int[]{dist[v], v});\n            }\n        }\n    }\n    return dist;\n}","problems":[{"name":"Network Delay Time (#743)","hint":"Dijkstra from source. Return max of all distances (or -1 if unreachable)."},{"name":"Path with Minimum Effort (#1631)","hint":"Modified Dijkstra. Cost = max edge weight on path, not sum."},{"name":"Cheapest Flights Within K Stops (#787)","hint":"BFS/Dijkstra with state (node, stops). Or Bellman-Ford k+1 iterations."}]}]},{"name":"ADVANCED_PATTERNS","overview":"","variants":[{"name":"Greedy + Heap","description":"Make locally optimal choices using heap to track best options.","when":"Maximize/minimize with constraints, resource allocation, scheduling.","template":"// Example: Maximum Performance of a Team\n// Choose at most k engineers to maximize sum(speed) * min(efficiency)\npublic int maxPerformance(int n, int[] speed, int[] efficiency, int k) {\n    int[][] engineers = new int[n][2];\n    for (int i = 0; i < n; i++) {\n        engineers[i] = new int[]{efficiency[i], speed[i]};\n    }\n    // Sort by efficiency descending\n    Arrays.sort(engineers, (a, b) -> b[0] - a[0]);\n    \n    // Min-heap of speeds (to remove slowest if > k)\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n    long speedSum = 0, maxPerf = 0;\n    \n    for (int[] eng : engineers) {\n        int eff = eng[0], spd = eng[1];\n        minHeap.offer(spd);\n        speedSum += spd;\n        \n        if (minHeap.size() > k) {\n            speedSum -= minHeap.poll();\n        }\n        \n        // Current engineer has minimum efficiency (we sorted by efficiency desc)\n        maxPerf = Math.max(maxPerf, speedSum * eff);\n    }\n    return (int)(maxPerf % 1_000_000_007);\n}","problems":[{"name":"Maximum Performance of a Team (#1383)","hint":"Sort by efficiency desc. Min-heap for speeds. Each step, current eff is min."},{"name":"Minimum Cost to Hire K Workers (#857)","hint":"Sort by wage/quality ratio. Min-heap for quality. Track sum * current ratio."},{"name":"Course Schedule III (#630)","hint":"Sort by deadline. Max-heap of durations. If can't fit, swap if new is shorter."}]},{"name":"Heap + HashMap (Lazy Deletion)","description":"When you need to remove arbitrary elements but want to avoid O(n) removal.","when":"Sliding window + heap, dynamic updates, frequency-based heap.","template":"// Lazy deletion pattern\nclass LazyHeap {\n    PriorityQueue<Integer> heap = new PriorityQueue<>();\n    Map<Integer, Integer> toDelete = new HashMap<>();\n    \n    void add(int val) { heap.offer(val); }\n    \n    void remove(int val) {\n        toDelete.merge(val, 1, Integer::sum); // Mark for deletion\n    }\n    \n    int peek() {\n        cleanup();\n        return heap.peek();\n    }\n    \n    int poll() {\n        cleanup();\n        return heap.poll();\n    }\n    \n    private void cleanup() {\n        while (!heap.isEmpty() && toDelete.getOrDefault(heap.peek(), 0) > 0) {\n            toDelete.merge(heap.poll(), -1, Integer::sum);\n        }\n    }\n}","problems":[{"name":"Sliding Window Median (#480)","hint":"Two lazy heaps. Mark outgoing elements, clean on access."},{"name":"Design Twitter (#355)","hint":"Merge k sorted feeds (recent tweets). Heap of (time, tweetId, userId)."}]},{"name":"Index Min Heap / Update Priority","description":"When you need to update the priority of elements already in the heap.","when":"Dijkstra with updates, dynamic priority changes.","template":"// Java PriorityQueue doesn't support decrease-key\n// Option 1: Add duplicate entries, skip stale ones\n// Option 2: Use TreeMap<Integer, Set<Integer>> for O(log n) update\n// Option 3: Implement index heap manually (rarely needed in interviews)\n\n// Option 1: Duplicate entries (most common in interviews)\n// In Dijkstra, we add (newDist, node) even if node already in heap\n// When we poll, we check: if polled distance > known distance, skip\nif (d > dist[u]) continue; // Stale entry","problems":[{"name":"Network Delay Time (#743)","hint":"Add duplicates to heap. Skip stale entries (d > dist[u])."},{"name":"Path with Maximum Probability (#1514)","hint":"Same duplicate technique. Max-heap (use -prob or reverseOrder)."}]},{"name":"Multi-Way Heap / Nested Heaps","description":"Complex structures combining multiple heaps or heaps of heaps.","when":"Complex prioritization, multiple criteria, nested optimization.","template":"// Example: Design a Food Rating System\n// Need quick lookup by cuisine → highest rated\n// Use HashMap<String, TreeMap<>> or HashMap<String, PriorityQueue<>>\n\nclass FoodRatings {\n    Map<String, String> foodToCuisine = new HashMap<>();\n    Map<String, Integer> foodToRating = new HashMap<>();\n    Map<String, TreeMap<Integer, TreeSet<String>>> cuisineToFoods = new HashMap<>();\n    \n    public void changeRating(String food, int newRating) {\n        String cuisine = foodToCuisine.get(food);\n        int oldRating = foodToRating.get(food);\n        \n        // Remove from old rating bucket\n        TreeMap<Integer, TreeSet<String>> map = cuisineToFoods.get(cuisine);\n        map.get(oldRating).remove(food);\n        if (map.get(oldRating).isEmpty()) map.remove(oldRating);\n        \n        // Add to new rating bucket\n        foodToRating.put(food, newRating);\n        map.computeIfAbsent(newRating, k -> new TreeSet<>()).add(food);\n    }\n    \n    public String highestRated(String cuisine) {\n        TreeMap<Integer, TreeSet<String>> map = cuisineToFoods.get(cuisine);\n        return map.lastEntry().getValue().first(); // Highest rating, lex smallest\n    }\n}","problems":[{"name":"Design a Food Rating System (#2353)","hint":"HashMap + TreeMap + TreeSet for multi-key lookup."},{"name":"Stock Price Fluctuation (#2034)","hint":"Track current, min, max. HashMap + two heaps with lazy deletion."},{"name":"Exam Room (#855)","hint":"Track intervals. Max-heap by distance to nearest person."}]}]}]},"dp":{"sections":["1D DP Foundations","2D DP Patterns","Advanced DP","State Design","Pattern Recognition","Formulas & Tips","Revision Cards"],"patterns":[{"name":"DP_1D_FOUNDATIONS","overview":"Dynamic Programming is recursion + memoization, or bottom-up iteration with a table. The core insight: if a problem has OPTIMAL SUBSTRUCTURE (optimal solution built from optimal solutions to subproblems) and OVERLAPPING SUBPROBLEMS (same subproblems solved multiple times), DP will help. Start with 1D DP where your state is a single variable — usually an index or an amount. The recurrence relates dp[i] to previous states like dp[i-1], dp[i-2], or dp[j] for all j < i. Master these patterns before moving to 2D.","variants":[{"name":"Linear Sequence (Fibonacci-style)","description":"The simplest DP pattern. dp[i] depends on a fixed number of previous states — usually dp[i-1] and dp[i-2]. Space can often be optimized to O(1) by keeping only the last 2-3 values.","when":"Climbing stairs, fibonacci, tiling problems, tribonacci, decode ways.","template":"// Climbing Stairs — dp[i] = dp[i-1] + dp[i-2]\npublic int climbStairs(int n) {\n    if (n <= 2) return n;\n    int prev2 = 1, prev1 = 2;\n    for (int i = 3; i <= n; i++) {\n        int curr = prev1 + prev2;\n        prev2 = prev1;\n        prev1 = curr;\n    }\n    return prev1;\n}\n\n// Decode Ways — with conditional transitions\npublic int numDecodings(String s) {\n    int n = s.length();\n    int[] dp = new int[n + 1];\n    dp[0] = 1;  // empty string = 1 way\n    dp[1] = s.charAt(0) == '0' ? 0 : 1;\n\n    for (int i = 2; i <= n; i++) {\n        int oneDigit = s.charAt(i - 1) - '0';\n        int twoDigit = Integer.parseInt(s.substring(i - 2, i));\n        if (oneDigit >= 1) dp[i] += dp[i - 1];\n        if (twoDigit >= 10 && twoDigit <= 26) dp[i] += dp[i - 2];\n    }\n    return dp[n];\n}","problems":[{"name":"Climbing Stairs (#70)","hint":"dp[i] = dp[i-1] + dp[i-2]. Can reach step i from i-1 or i-2. Base: dp[1]=1, dp[2]=2."},{"name":"Fibonacci Number (#509)","hint":"Same as climbing stairs. dp[0]=0, dp[1]=1, dp[i]=dp[i-1]+dp[i-2]."},{"name":"Decode Ways (#91)","hint":"One digit (1-9) adds dp[i-1]. Two digits (10-26) adds dp[i-2]. Handle '0' carefully."},{"name":"House Robber (#198)","hint":"dp[i] = max(dp[i-1], dp[i-2] + nums[i]). Skip or rob current house."}]},{"name":"Take or Skip / Knapsack-1D","description":"For each item, decide to take it or skip it. dp[i] represents the optimal value considering items 0..i or the optimal value achievable with capacity i. Classic 0/1 knapsack and house robber fall here.","when":"Subset sum, coin change (min), knapsack capacity, house robber, partition equal subset.","template":"// House Robber — take or skip each house\npublic int rob(int[] nums) {\n    int n = nums.length;\n    if (n == 1) return nums[0];\n    int prev2 = 0, prev1 = nums[0];\n    for (int i = 1; i < n; i++) {\n        int curr = Math.max(prev1, prev2 + nums[i]);\n        prev2 = prev1;\n        prev1 = curr;\n    }\n    return prev1;\n}\n\n// Partition Equal Subset Sum — subset sum variant\npublic boolean canPartition(int[] nums) {\n    int total = 0;\n    for (int num : nums) total += num;\n    if (total % 2 != 0) return false;\n    int target = total / 2;\n\n    boolean[] dp = new boolean[target + 1];\n    dp[0] = true;\n    for (int num : nums) {\n        for (int j = target; j >= num; j--) {  // reverse to avoid reuse\n            dp[j] = dp[j] || dp[j - num];\n        }\n    }\n    return dp[target];\n}","problems":[{"name":"House Robber (#198)","hint":"dp[i] = max(skip: dp[i-1], rob: dp[i-2] + nums[i]). O(1) space possible."},{"name":"House Robber II (#213)","hint":"Circular: max(rob(0..n-2), rob(1..n-1)). Run House Robber twice, exclude one end each time."},{"name":"Partition Equal Subset Sum (#416)","hint":"Find subset with sum = total/2. Boolean DP: dp[j] = dp[j] || dp[j-num]. Iterate j backwards."},{"name":"Target Sum (#494)","hint":"Count ways to reach (total + target) / 2 using + only. Same as subset sum counting."}]},{"name":"Unbounded Choices (Coin Change style)","description":"Unlike 0/1 knapsack, each item can be used unlimited times. dp[i] = optimal value to reach amount/capacity i. Key difference: inner loop iterates FORWARD (not backward) to allow reuse, or you loop over items last.","when":"Coin change, perfect squares, integer break, unbounded knapsack.","template":"// Coin Change — minimum coins to make amount\npublic int coinChange(int[] coins, int amount) {\n    int[] dp = new int[amount + 1];\n    Arrays.fill(dp, amount + 1);  // infinity\n    dp[0] = 0;\n\n    for (int i = 1; i <= amount; i++) {\n        for (int coin : coins) {\n            if (coin <= i) {\n                dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n            }\n        }\n    }\n    return dp[amount] > amount ? -1 : dp[amount];\n}\n\n// Perfect Squares — min squares summing to n\npublic int numSquares(int n) {\n    int[] dp = new int[n + 1];\n    Arrays.fill(dp, Integer.MAX_VALUE);\n    dp[0] = 0;\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j * j <= i; j++) {\n            dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n        }\n    }\n    return dp[n];\n}","problems":[{"name":"Coin Change (#322)","hint":"dp[i] = min(dp[i], dp[i-coin] + 1) for each coin. Init dp[0]=0, rest=infinity."},{"name":"Coin Change II (#518)","hint":"Count combinations (not permutations). Loop coins OUTER, amounts INNER. dp[j] += dp[j-coin]."},{"name":"Perfect Squares (#279)","hint":"dp[i] = min(dp[i], dp[i - j²] + 1) for all valid j. Same as coin change with 'coins' = 1,4,9,16..."},{"name":"Integer Break (#343)","hint":"dp[i] = max(j * (i-j), j * dp[i-j]) for j = 1..i-1. Choose to break further or stop."}]},{"name":"Maximum Subarray / Kadane's Algorithm","description":"A special 1D DP pattern for contiguous subarrays. dp[i] = max subarray ending at i. At each position: extend previous subarray or start fresh. The recurrence: dp[i] = max(nums[i], dp[i-1] + nums[i]).","when":"Maximum subarray sum, maximum product, best time to buy/sell stock, max circular subarray.","template":"// Maximum Subarray — Kadane's Algorithm\npublic int maxSubArray(int[] nums) {\n    int maxEndingHere = nums[0];\n    int maxSoFar = nums[0];\n\n    for (int i = 1; i < nums.length; i++) {\n        maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]);\n        maxSoFar = Math.max(maxSoFar, maxEndingHere);\n    }\n    return maxSoFar;\n}\n\n// Maximum Product Subarray — track both min and max\npublic int maxProduct(int[] nums) {\n    int maxProd = nums[0], minProd = nums[0], result = nums[0];\n\n    for (int i = 1; i < nums.length; i++) {\n        if (nums[i] < 0) {\n            int temp = maxProd;\n            maxProd = minProd;\n            minProd = temp;\n        }\n        maxProd = Math.max(nums[i], maxProd * nums[i]);\n        minProd = Math.min(nums[i], minProd * nums[i]);\n        result = Math.max(result, maxProd);\n    }\n    return result;\n}","problems":[{"name":"Maximum Subarray (#53)","hint":"Kadane's: maxEndingHere = max(nums[i], maxEndingHere + nums[i]). Track global max."},{"name":"Maximum Product Subarray (#152)","hint":"Track both max and min (negative × negative = positive). Swap on negative number."},{"name":"Best Time to Buy and Sell Stock (#121)","hint":"Track minPrice so far. maxProfit = max(maxProfit, price - minPrice). One transaction."},{"name":"Maximum Sum Circular Subarray (#918)","hint":"Answer = max(normal Kadane, total - min subarray). Handle all-negative edge case."}]},{"name":"Longest Increasing Subsequence (LIS)","description":"dp[i] = length of LIS ending at index i. For each i, check all j < i: if nums[j] < nums[i], then dp[i] = max(dp[i], dp[j] + 1). O(n²) naive, O(n log n) with binary search optimization.","when":"LIS, longest chain, Russian doll envelopes, number of LIS, longest bitonic.","template":"// LIS — O(n²) DP\npublic int lengthOfLIS(int[] nums) {\n    int n = nums.length;\n    int[] dp = new int[n];\n    Arrays.fill(dp, 1);  // each element is LIS of length 1\n    int maxLen = 1;\n\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (nums[j] < nums[i]) {\n                dp[i] = Math.max(dp[i], dp[j] + 1);\n            }\n        }\n        maxLen = Math.max(maxLen, dp[i]);\n    }\n    return maxLen;\n}\n\n// LIS — O(n log n) with binary search\npublic int lengthOfLIS_Optimized(int[] nums) {\n    List<Integer> tails = new ArrayList<>();\n    for (int num : nums) {\n        int pos = Collections.binarySearch(tails, num);\n        if (pos < 0) pos = -(pos + 1);\n        if (pos == tails.size()) {\n            tails.add(num);\n        } else {\n            tails.set(pos, num);\n        }\n    }\n    return tails.size();\n}","problems":[{"name":"Longest Increasing Subsequence (#300)","hint":"O(n²): dp[i] = max(dp[j] + 1) for j < i where nums[j] < nums[i]. O(n log n): binary search on tails."},{"name":"Number of LIS (#673)","hint":"Track count[i] alongside dp[i]. If dp[j] + 1 == dp[i], add count[j] to count[i]."},{"name":"Russian Doll Envelopes (#354)","hint":"Sort by width asc, then height desc. LIS on heights. Height desc prevents same-width stacking."},{"name":"Longest String Chain (#1048)","hint":"Sort by length. For each word, check all predecessors (remove one char). dp[word] = max(dp[pred] + 1)."}]}]},{"name":"DP_2D_PATTERNS","overview":"2D DP introduces a second state dimension — often two indices (i, j), or (index, capacity), or (index, state). The recurrence now fills a 2D table where dp[i][j] depends on neighboring cells like dp[i-1][j], dp[i][j-1], dp[i-1][j-1], or dp[i-1][k] for all k. Visualize the table and understand the fill order — usually row by row, column by column, or diagonal by diagonal. Space optimization often reduces 2D to 1D by keeping only the previous row.","variants":[{"name":"Grid Paths (Unique Paths, Min Path Sum)","description":"Navigate an m×n grid from top-left to bottom-right. dp[i][j] = number of ways or min cost to reach (i,j). Depends on dp[i-1][j] (from above) and dp[i][j-1] (from left).","when":"Unique paths, minimum path sum, grid with obstacles, triangle, dungeon game.","template":"// Unique Paths — count ways to reach bottom-right\npublic int uniquePaths(int m, int n) {\n    int[][] dp = new int[m][n];\n    for (int i = 0; i < m; i++) dp[i][0] = 1;  // left column\n    for (int j = 0; j < n; j++) dp[0][j] = 1;  // top row\n\n    for (int i = 1; i < m; i++) {\n        for (int j = 1; j < n; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n    return dp[m - 1][n - 1];\n}\n\n// Minimum Path Sum\npublic int minPathSum(int[][] grid) {\n    int m = grid.length, n = grid[0].length;\n    int[][] dp = new int[m][n];\n    dp[0][0] = grid[0][0];\n\n    for (int i = 1; i < m; i++) dp[i][0] = dp[i - 1][0] + grid[i][0];\n    for (int j = 1; j < n; j++) dp[0][j] = dp[0][j - 1] + grid[0][j];\n\n    for (int i = 1; i < m; i++) {\n        for (int j = 1; j < n; j++) {\n            dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n        }\n    }\n    return dp[m - 1][n - 1];\n}","problems":[{"name":"Unique Paths (#62)","hint":"dp[i][j] = dp[i-1][j] + dp[i][j-1]. First row and column are all 1s."},{"name":"Unique Paths II (#63)","hint":"Same, but if obstacle, dp[i][j] = 0. Handle obstacles in first row/column carefully."},{"name":"Minimum Path Sum (#64)","hint":"dp[i][j] = min(from top, from left) + grid[i][j]. Initialize edges by accumulating."},{"name":"Triangle (#120)","hint":"Bottom-up: dp[j] = min(dp[j], dp[j+1]) + triangle[i][j]. O(n) space."}]},{"name":"Two Strings (Edit Distance, LCS, Palindrome)","description":"Compare two strings or check a string against itself. dp[i][j] = answer for s1[0..i-1] and s2[0..j-1]. Classic patterns: Longest Common Subsequence, Edit Distance, and Longest Palindromic Subsequence.","when":"Edit distance, LCS, shortest common supersequence, longest palindromic subsequence, interleaving string.","template":"// Edit Distance (Levenshtein)\npublic int minDistance(String word1, String word2) {\n    int m = word1.length(), n = word2.length();\n    int[][] dp = new int[m + 1][n + 1];\n\n    for (int i = 0; i <= m; i++) dp[i][0] = i;  // delete all\n    for (int j = 0; j <= n; j++) dp[0][j] = j;  // insert all\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1];  // no operation\n            } else {\n                dp[i][j] = 1 + Math.min(dp[i - 1][j - 1],  // replace\n                               Math.min(dp[i - 1][j],      // delete\n                                        dp[i][j - 1]));    // insert\n            }\n        }\n    }\n    return dp[m][n];\n}\n\n// Longest Common Subsequence\npublic int longestCommonSubsequence(String s1, String s2) {\n    int m = s1.length(), n = s2.length();\n    int[][] dp = new int[m + 1][n + 1];\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[m][n];\n}","problems":[{"name":"Edit Distance (#72)","hint":"Match: dp[i-1][j-1]. Else: 1 + min(replace, delete, insert) = min(diag, top, left)."},{"name":"Longest Common Subsequence (#1143)","hint":"Match: dp[i-1][j-1] + 1. No match: max(dp[i-1][j], dp[i][j-1])."},{"name":"Longest Palindromic Subsequence (#516)","hint":"LCS of s and reverse(s). Or: dp[i][j] on s itself, expand from diagonals."},{"name":"Distinct Subsequences (#115)","hint":"Count ways s contains t. Match: dp[i-1][j-1] + dp[i-1][j]. No match: dp[i-1][j]."}]},{"name":"Interval DP (Range DP)","description":"dp[i][j] = answer for the substring or subarray from index i to j. Fill diagonally: first all intervals of length 1, then length 2, etc. Or recurse with memoization. Used for problems where you process from both ends or split the interval.","when":"Palindrome partitioning, burst balloons, merge stones, matrix chain multiplication.","template":"// Longest Palindromic Substring — expand or DP\n// DP approach: dp[i][j] = true if s[i..j] is palindrome\npublic String longestPalindrome(String s) {\n    int n = s.length();\n    boolean[][] dp = new boolean[n][n];\n    int start = 0, maxLen = 1;\n\n    // Base: single chars\n    for (int i = 0; i < n; i++) dp[i][i] = true;\n\n    // Base: two chars\n    for (int i = 0; i < n - 1; i++) {\n        if (s.charAt(i) == s.charAt(i + 1)) {\n            dp[i][i + 1] = true;\n            start = i;\n            maxLen = 2;\n        }\n    }\n\n    // Fill for length 3+\n    for (int len = 3; len <= n; len++) {\n        for (int i = 0; i <= n - len; i++) {\n            int j = i + len - 1;\n            if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {\n                dp[i][j] = true;\n                start = i;\n                maxLen = len;\n            }\n        }\n    }\n    return s.substring(start, start + maxLen);\n}\n\n// Palindrome Partitioning II — min cuts\npublic int minCut(String s) {\n    int n = s.length();\n    boolean[][] isPalin = new boolean[n][n];\n    int[] dp = new int[n];\n\n    for (int j = 0; j < n; j++) {\n        dp[j] = j;  // max cuts = j (all single chars)\n        for (int i = 0; i <= j; i++) {\n            if (s.charAt(i) == s.charAt(j) && (j - i < 2 || isPalin[i + 1][j - 1])) {\n                isPalin[i][j] = true;\n                dp[j] = (i == 0) ? 0 : Math.min(dp[j], dp[i - 1] + 1);\n            }\n        }\n    }\n    return dp[n - 1];\n}","problems":[{"name":"Longest Palindromic Substring (#5)","hint":"dp[i][j] = (s[i]==s[j] && dp[i+1][j-1]). Or expand around center O(n²)."},{"name":"Palindrome Partitioning II (#132)","hint":"Precompute isPalin[i][j]. dp[j] = min cuts for s[0..j]. If isPalin[i][j], dp[j] = min(dp[j], dp[i-1]+1)."},{"name":"Burst Balloons (#312)","hint":"dp[i][j] = max coins bursting balloons (i,j) exclusive. Last balloon k: dp[i][k] + dp[k][j] + nums[i]*nums[k]*nums[j]."},{"name":"Minimum Cost to Merge Stones (#1000)","hint":"Interval DP with constraints. dp[i][j][k] = cost to merge i..j into k piles. Merge when k reaches final."}]},{"name":"0/1 Knapsack (2D version)","description":"dp[i][w] = max value using items 0..i-1 with capacity w. Transition: skip item (dp[i-1][w]) or take it (dp[i-1][w-weight[i]] + value[i]). Can optimize to 1D by iterating capacity in reverse.","when":"Knapsack, partition problems, subset with target sum, bounded knapsack.","template":"// 0/1 Knapsack — 2D version\npublic int knapsack(int[] weights, int[] values, int capacity) {\n    int n = weights.length;\n    int[][] dp = new int[n + 1][capacity + 1];\n\n    for (int i = 1; i <= n; i++) {\n        for (int w = 0; w <= capacity; w++) {\n            dp[i][w] = dp[i - 1][w];  // skip item i-1\n            if (weights[i - 1] <= w) {\n                dp[i][w] = Math.max(dp[i][w],\n                    dp[i - 1][w - weights[i - 1]] + values[i - 1]);\n            }\n        }\n    }\n    return dp[n][capacity];\n}\n\n// 0/1 Knapsack — 1D space optimization\npublic int knapsack1D(int[] weights, int[] values, int capacity) {\n    int[] dp = new int[capacity + 1];\n    for (int i = 0; i < weights.length; i++) {\n        for (int w = capacity; w >= weights[i]; w--) {  // REVERSE\n            dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);\n        }\n    }\n    return dp[capacity];\n}","problems":[{"name":"Partition Equal Subset Sum (#416)","hint":"Subset sum = half of total. dp[j] = can we make sum j? Iterate j backwards."},{"name":"Last Stone Weight II (#1049)","hint":"Minimize difference between two groups. Same as subset sum closest to total/2."},{"name":"Ones and Zeroes (#474)","hint":"Two-dimensional knapsack: dp[m][n] = max strings with ≤m zeros and ≤n ones. Iterate both backwards."},{"name":"Profitable Schemes (#879)","hint":"dp[people][profit] = count. Three nested loops. Watch for profit cap at minProfit."}]}]},{"name":"DP_ADVANCED","overview":"Advanced DP goes beyond simple state definitions. You'll encounter bitmask DP (state = subset as bitmask), digit DP (count numbers with digit constraints), DP on trees, and DP with optimizations (monotonic deque, convex hull trick). The key skill: recognizing WHAT state you need to track and HOW states transition. Sometimes the state isn't obvious — it might be 'last action taken', 'remaining moves', or 'parity of something'.","variants":[{"name":"State Machine DP (Buy/Sell Stock)","description":"Track multiple states at each position — like 'holding stock', 'not holding', 'in cooldown'. dp[i][state] represents the optimal value at position i in that state. Transitions move between states based on actions (buy, sell, rest).","when":"Stock trading with cooldowns or transaction limits, state-dependent transitions.","template":"// Best Time to Buy and Sell Stock with Cooldown\npublic int maxProfit(int[] prices) {\n    int n = prices.length;\n    if (n < 2) return 0;\n\n    int[] hold = new int[n];    // holding stock\n    int[] sold = new int[n];    // just sold\n    int[] rest = new int[n];    // in cooldown or resting\n\n    hold[0] = -prices[0];\n    sold[0] = 0;  // can't sell on day 0\n    rest[0] = 0;\n\n    for (int i = 1; i < n; i++) {\n        hold[i] = Math.max(hold[i - 1], rest[i - 1] - prices[i]);\n        sold[i] = hold[i - 1] + prices[i];\n        rest[i] = Math.max(rest[i - 1], sold[i - 1]);\n    }\n    return Math.max(sold[n - 1], rest[n - 1]);\n}\n\n// Best Time to Buy and Sell Stock IV (at most k transactions)\npublic int maxProfit(int k, int[] prices) {\n    int n = prices.length;\n    if (n == 0 || k == 0) return 0;\n\n    // Optimization: if k >= n/2, unlimited transactions\n    if (k >= n / 2) {\n        int profit = 0;\n        for (int i = 1; i < n; i++) {\n            if (prices[i] > prices[i - 1]) profit += prices[i] - prices[i - 1];\n        }\n        return profit;\n    }\n\n    int[][] dp = new int[k + 1][n];\n    for (int t = 1; t <= k; t++) {\n        int maxDiff = -prices[0];\n        for (int d = 1; d < n; d++) {\n            dp[t][d] = Math.max(dp[t][d - 1], prices[d] + maxDiff);\n            maxDiff = Math.max(maxDiff, dp[t - 1][d] - prices[d]);\n        }\n    }\n    return dp[k][n - 1];\n}","problems":[{"name":"Best Time to Buy and Sell Stock with Cooldown (#309)","hint":"Three states: hold, sold, rest. Transitions: hold→sold, rest→hold, sold→rest, rest→rest."},{"name":"Best Time to Buy and Sell Stock with Transaction Fee (#714)","hint":"Two states: hold, cash. Transition includes fee on sell. dp[hold] = max(hold, cash - price), dp[cash] = max(cash, hold + price - fee)."},{"name":"Best Time to Buy and Sell Stock III (#123)","hint":"At most 2 transactions. Track buy1, sell1, buy2, sell2. Update in sequence each day."},{"name":"Best Time to Buy and Sell Stock IV (#188)","hint":"At most k transactions. dp[t][d] = max profit with t transactions by day d. Optimize maxDiff to O(kn)."}]},{"name":"Bitmask DP (Subset State)","description":"When the state involves a subset of n items (n ≤ 20), represent the subset as a bitmask. dp[mask] = answer for the subset represented by mask. Iterate over all 2^n masks. Useful for Traveling Salesman, assignment problems, and subset problems.","when":"TSP, assignment problems, shortest path visiting all nodes, partition into k groups, SOS DP.","template":"// Shortest Path Visiting All Nodes\npublic int shortestPathLength(int[][] graph) {\n    int n = graph.length;\n    int fullMask = (1 << n) - 1;\n\n    // BFS with state = (node, visited_mask)\n    Queue<int[]> queue = new LinkedList<>();\n    boolean[][] visited = new boolean[n][1 << n];\n\n    for (int i = 0; i < n; i++) {\n        queue.offer(new int[]{i, 1 << i, 0});\n        visited[i][1 << i] = true;\n    }\n\n    while (!queue.isEmpty()) {\n        int[] curr = queue.poll();\n        int node = curr[0], mask = curr[1], dist = curr[2];\n\n        if (mask == fullMask) return dist;\n\n        for (int neighbor : graph[node]) {\n            int newMask = mask | (1 << neighbor);\n            if (!visited[neighbor][newMask]) {\n                visited[neighbor][newMask] = true;\n                queue.offer(new int[]{neighbor, newMask, dist + 1});\n            }\n        }\n    }\n    return -1;\n}\n\n// Partition to K Equal Sum Subsets\npublic boolean canPartitionKSubsets(int[] nums, int k) {\n    int total = 0;\n    for (int num : nums) total += num;\n    if (total % k != 0) return false;\n    int target = total / k;\n\n    Arrays.sort(nums);\n    int n = nums.length;\n    int[] dp = new int[1 << n];\n    Arrays.fill(dp, -1);\n    dp[0] = 0;\n\n    for (int mask = 0; mask < (1 << n); mask++) {\n        if (dp[mask] == -1) continue;\n        for (int i = 0; i < n; i++) {\n            if ((mask & (1 << i)) != 0) continue;\n            if (dp[mask] + nums[i] <= target) {\n                int newMask = mask | (1 << i);\n                dp[newMask] = (dp[mask] + nums[i]) % target;\n            }\n        }\n    }\n    return dp[(1 << n) - 1] == 0;\n}","problems":[{"name":"Shortest Path Visiting All Nodes (#847)","hint":"BFS with (node, visited_mask). Start from all nodes. Goal: mask == (1 << n) - 1."},{"name":"Partition to K Equal Sum Subsets (#698)","hint":"dp[mask] = sum mod target for elements in mask. If divisible at full mask, valid partition."},{"name":"Parallel Courses II (#1494)","hint":"dp[mask] = min semesters. Enumerate submasks of available courses (in-degree 0), take at most k."},{"name":"Find the Shortest Superstring (#943)","hint":"TSP variant: dp[mask][last] = min length ending with 'last'. Precompute overlaps."}]},{"name":"DP on Trees","description":"Compute DP values for each node based on its children (bottom-up via post-order DFS). dp[node] might represent the answer for the subtree rooted at node. Sometimes you need dp[node][0] and dp[node][1] for 'include node' vs 'exclude node'.","when":"Tree diameter, house robber III, max path sum, tree coloring, tree distances.","template":"// House Robber III — rob or skip each node\npublic int rob(TreeNode root) {\n    int[] result = robDFS(root);\n    return Math.max(result[0], result[1]);\n}\n\n// Returns [robThis, skipThis]\nprivate int[] robDFS(TreeNode node) {\n    if (node == null) return new int[]{0, 0};\n\n    int[] left = robDFS(node.left);\n    int[] right = robDFS(node.right);\n\n    int robThis = node.val + left[1] + right[1];  // must skip children\n    int skipThis = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\n\n    return new int[]{robThis, skipThis};\n}\n\n// Binary Tree Maximum Path Sum\nint maxSum = Integer.MIN_VALUE;\n\npublic int maxPathSum(TreeNode root) {\n    dfs(root);\n    return maxSum;\n}\n\nprivate int dfs(TreeNode node) {\n    if (node == null) return 0;\n    int left = Math.max(0, dfs(node.left));   // ignore negative paths\n    int right = Math.max(0, dfs(node.right));\n\n    maxSum = Math.max(maxSum, node.val + left + right);  // path through node\n    return node.val + Math.max(left, right);  // path to parent\n}","problems":[{"name":"House Robber III (#337)","hint":"Return [rob, skip] from each node. rob = val + skip(left) + skip(right). skip = max(children)."},{"name":"Binary Tree Maximum Path Sum (#124)","hint":"At each node, update global max with left + node + right. Return node + max(left, right) for parent."},{"name":"Diameter of Binary Tree (#543)","hint":"Diameter = max(left_depth + right_depth). Return 1 + max(left, right) to parent."},{"name":"Binary Tree Cameras (#968)","hint":"Three states: 0=needs coverage, 1=has camera, 2=covered. Greedy post-order: place camera at parent of uncovered."}]},{"name":"DP with Optimization (Monotonic Deque, Divide & Conquer)","description":"When the naive DP is too slow (O(n²) or O(n³)), apply optimizations: monotonic deque for sliding window max/min in transitions, divide and conquer for certain recurrences, or convex hull trick for linear transitions.","when":"Sliding window constrained DP, optimizing O(n²) to O(n log n), convex hull trick problems.","template":"// Jump Game VI — monotonic deque optimization\npublic int maxResult(int[] nums, int k) {\n    int n = nums.length;\n    int[] dp = new int[n];\n    dp[0] = nums[0];\n\n    Deque<Integer> deque = new ArrayDeque<>();  // stores indices\n    deque.offer(0);\n\n    for (int i = 1; i < n; i++) {\n        // Remove out-of-window elements\n        while (!deque.isEmpty() && deque.peekFirst() < i - k) {\n            deque.pollFirst();\n        }\n        // dp[i] = max in window + nums[i]\n        dp[i] = dp[deque.peekFirst()] + nums[i];\n\n        // Maintain decreasing order\n        while (!deque.isEmpty() && dp[deque.peekLast()] <= dp[i]) {\n            deque.pollLast();\n        }\n        deque.offerLast(i);\n    }\n    return dp[n - 1];\n}","problems":[{"name":"Jump Game VI (#1696)","hint":"dp[i] = max(dp[i-k..i-1]) + nums[i]. Monotonic deque for O(n) instead of O(nk)."},{"name":"Constrained Subsequence Sum (#1425)","hint":"Same pattern as Jump Game VI. Max sum with adjacent indices at most k apart."},{"name":"Sliding Window Maximum (#239)","hint":"Monotonic decreasing deque of indices. Front = current max. O(n) total."},{"name":"Shortest Subarray with Sum at Least K (#862)","hint":"Prefix sums + monotonic deque. Remove from front when valid, from back to maintain order."}]}]},{"name":"STATE_DESIGN","overview":"The hardest part of DP is often DEFINING THE STATE. A good state captures exactly the information needed to make optimal decisions for remaining subproblems. Too little information → wrong answer. Too much → exponential blowup. The mantra: 'What do I need to know at this point to solve the rest optimally?' Common state components: current index/position, remaining capacity/budget, last choice made, parity, and bitmask of used items.","variants":[{"name":"Single Index State","description":"dp[i] = answer considering elements 0..i or elements i..n-1. The simplest state. Works when the future doesn't depend on HOW you got to i, only THAT you're at i.","when":"House robber, climbing stairs, LIS, word break.","template":"// State: dp[i] = max money robbing houses 0..i-1\n// What do we need to know? Just the index.\n// Transition: dp[i] = max(dp[i-1], dp[i-2] + nums[i-1])","problems":[{"name":"House Robber (#198)","hint":"dp[i] = max profit from first i houses. Don't need to track which houses were robbed."},{"name":"Word Break (#139)","hint":"dp[i] = can we segment s[0..i-1]? Check all j < i where dp[j] && s[j..i-1] is a word."}]},{"name":"Index + Capacity/Amount State","description":"dp[i][w] = answer using items 0..i-1 with capacity w remaining. When there's a resource constraint (capacity, budget, count), add it as a dimension.","when":"Knapsack, coin change, target sum, partition problems.","template":"// State: dp[i][w] = max value with items 0..i-1, capacity w\n// What do we need? Index AND remaining capacity.\n// Transition: skip item (dp[i-1][w]) or take (dp[i-1][w-wt] + val)","problems":[{"name":"0/1 Knapsack","hint":"dp[i][w] depends on dp[i-1][w] (skip) and dp[i-1][w-weight[i]] (take)."},{"name":"Target Sum (#494)","hint":"dp[i][sum] = ways to reach sum using first i numbers. Or reduce to subset sum."}]},{"name":"Two Indices State (Interval or Two Strings)","description":"dp[i][j] = answer for range [i,j] or for s1[0..i-1] and s2[0..j-1]. Fill order: by length for intervals, row by row for two strings.","when":"LCS, edit distance, palindrome problems, interval DP.","template":"// State: dp[i][j] = answer for subproblem defined by two endpoints\n// For LCS: dp[i][j] = LCS of s1[0..i-1] and s2[0..j-1]\n// For Palindrome: dp[i][j] = answer for s[i..j]","problems":[{"name":"Edit Distance (#72)","hint":"dp[i][j] = min ops to transform s1[0..i-1] to s2[0..j-1]."},{"name":"Longest Palindromic Subsequence (#516)","hint":"dp[i][j] = LPS length in s[i..j]. Fill by increasing length."}]},{"name":"Index + Last Choice State","description":"When the transition depends on what you did last (cooldown, consecutive constraints), add 'last action' as a state dimension.","when":"Stock with cooldown, paint house, tiling with constraints.","template":"// State: dp[i][lastColor] = min cost painting houses 0..i with house i in lastColor\n// Need to track last choice because it constrains current choice","problems":[{"name":"Paint House (#256)","hint":"dp[i][c] = min cost painting 0..i with house i color c. Transition: min of other colors."},{"name":"Stock with Cooldown (#309)","hint":"Track state: holding, just_sold, resting. Different transitions from each."}]},{"name":"Bitmask State","description":"When you need to track a subset (visited nodes, selected items), use a bitmask as the state. Each bit represents whether an element is included. n ≤ 20 typically.","when":"TSP, assignment, partition into groups, graph problems with subset states.","template":"// State: dp[mask] = answer having processed the subset 'mask'\n// mask & (1 << i) checks if i is in the subset\n// mask | (1 << i) adds i to the subset","problems":[{"name":"Traveling Salesman (TSP)","hint":"dp[mask][last] = min cost visiting 'mask' nodes ending at 'last'."},{"name":"Shortest Path Visiting All Nodes (#847)","hint":"BFS with state (node, visited_mask). Goal: mask = 2^n - 1."}]}]}]},"tries":{"sections":["Trie Fundamentals","Advanced Trie Patterns","Beyond Tries","Pattern Recognition","Formulas & Tips","Revision Cards"],"patterns":[{"name":"TRIE_FUNDAMENTALS","overview":"A Trie (prefix tree) is a tree where each node represents a character, and paths from root to nodes form prefixes. All operations are O(m) where m = key length — independent of dataset size. In Java, use TrieNode with children[26] (lowercase) or HashMap<Character, TrieNode> (Unicode). Tries convert prefix-matching from O(n·m) brute force to O(m) lookups.","variants":[{"name":"Basic Trie (Insert / Search / StartsWith)","description":"The foundation. Each TrieNode has an array of 26 children (for lowercase English) and a boolean isEnd marker. Insert builds the path character by character. Search verifies the full path ends at a word. StartsWith verifies any prefix path exists.","when":"Autocomplete, spell checking, prefix matching, dictionary lookup, word validation.","template":"class TrieNode {\n    TrieNode[] children = new TrieNode[26];\n    boolean isEnd = false;\n}\n\nclass Trie {\n    TrieNode root = new TrieNode();\n\n    public void insert(String word) {\n        TrieNode node = root;\n        for (char c : word.toCharArray()) {\n            int idx = c - 'a';\n            if (node.children[idx] == null)\n                node.children[idx] = new TrieNode();\n            node = node.children[idx];\n        }\n        node.isEnd = true;\n    }\n\n    public boolean search(String word) {\n        TrieNode node = traverse(word);\n        return node != null && node.isEnd;\n    }\n\n    public boolean startsWith(String prefix) {\n        return traverse(prefix) != null;\n    }\n\n    private TrieNode traverse(String s) {\n        TrieNode node = root;\n        for (char c : s.toCharArray()) {\n            int idx = c - 'a';\n            if (node.children[idx] == null) return null;\n            node = node.children[idx];\n        }\n        return node;\n    }\n}","problems":[{"name":"Implement Trie (#208)","hint":"Exactly the template above. TrieNode[] children of size 26, boolean isEnd. Insert/search/startsWith."},{"name":"Search Suggestions System (#1268)","hint":"Insert all products into Trie. For each prefix of searchWord, DFS from prefix node to collect up to 3 lexicographic results."},{"name":"Longest Common Prefix (#14)","hint":"Insert all strings. Traverse from root while node has exactly 1 child and isEnd is false. Or just compare chars column by column."}]},{"name":"Trie + DFS Grid Search","description":"Build a Trie from the word list, then DFS the grid while simultaneously traversing the Trie. Only continue DFS if the current path is a valid prefix. This prunes the search space massively.","when":"Word search on a 2D board with a word dictionary. Finding multiple words in a grid simultaneously.","template":"// Word Search II — Trie + DFS on grid\nclass TrieNode {\n    TrieNode[] children = new TrieNode[26];\n    String word = null; // store complete word at leaf\n}\n\npublic List<String> findWords(char[][] board, String[] words) {\n    // Build Trie\n    TrieNode root = new TrieNode();\n    for (String w : words) {\n        TrieNode node = root;\n        for (char c : w.toCharArray()) {\n            int idx = c - 'a';\n            if (node.children[idx] == null)\n                node.children[idx] = new TrieNode();\n            node = node.children[idx];\n        }\n        node.word = w;\n    }\n\n    List<String> result = new ArrayList<>();\n    for (int i = 0; i < board.length; i++)\n        for (int j = 0; j < board[0].length; j++)\n            dfs(board, i, j, root, result);\n    return result;\n}\n\nprivate void dfs(char[][] board, int r, int c, TrieNode node, List<String> result) {\n    if (r < 0 || r >= board.length || c < 0 || c >= board[0].length) return;\n    char ch = board[r][c];\n    if (ch == '#' || node.children[ch - 'a'] == null) return;\n\n    node = node.children[ch - 'a'];\n    if (node.word != null) {\n        result.add(node.word);\n        node.word = null; // de-duplicate\n    }\n\n    board[r][c] = '#'; // mark visited\n    dfs(board, r+1, c, node, result);\n    dfs(board, r-1, c, node, result);\n    dfs(board, r, c+1, node, result);\n    dfs(board, r, c-1, node, result);\n    board[r][c] = ch; // restore\n}","problems":[{"name":"Word Search II (#212)","hint":"Build Trie from words. DFS grid with Trie traversal. Store word at leaf node for easy collection. Set word = null after finding to dedup."},{"name":"Word Search (#79)","hint":"Single word — no Trie needed, just DFS + backtracking. But Trie approach works for multiple words."},{"name":"Boggle Game","hint":"Same Trie + DFS pattern. Trie prunes invalid prefixes early, avoiding exponential blowup."}]},{"name":"Trie with Stored Values / Counts","description":"Augment TrieNode with extra fields: word count, prefix count, associated values. This turns the Trie into an associative data structure, not just a set.","when":"Count words with a given prefix, map design with prefix lookups, autocomplete with rankings.","template":"class TrieNode {\n    TrieNode[] children = new TrieNode[26];\n    int prefixCount = 0; // how many words pass through\n    int wordCount = 0;   // how many words end here\n}\n\n// Insert: increment prefixCount at every node, wordCount at end\npublic void insert(String word) {\n    TrieNode node = root;\n    for (char c : word.toCharArray()) {\n        int idx = c - 'a';\n        if (node.children[idx] == null)\n            node.children[idx] = new TrieNode();\n        node = node.children[idx];\n        node.prefixCount++;\n    }\n    node.wordCount++;\n}\n\n// Count words equal to word\npublic int countWordsEqualTo(String word) {\n    TrieNode node = traverse(word);\n    return node == null ? 0 : node.wordCount;\n}\n\n// Count words starting with prefix\npublic int countWordsStartingWith(String prefix) {\n    TrieNode node = traverse(prefix);\n    return node == null ? 0 : node.prefixCount;\n}","problems":[{"name":"Implement Trie II (#1804)","hint":"TrieNode with prefixCount and wordCount. Insert increments both. Erase decrements both. Count* reads them."},{"name":"Map Sum Pairs (#677)","hint":"Trie where each node stores sum of values that pass through it. On re-insert, subtract old value and add new. Or recalculate."},{"name":"Design Add and Search Words (#211)","hint":"Trie + DFS for '.' wildcard: when you hit '.', recurse into ALL children. Otherwise follow exact child."}]},{"name":"Wildcard / Regex Search in Trie","description":"Handle '.' wildcards by branching into all non-null children at that position. This turns a single search into a multi-path DFS through the Trie.","when":"Pattern matching with wildcards, regex-like dictionary search, flexible word lookup.","template":"// Design Add and Search Words Data Structure\npublic boolean search(String word) {\n    return dfs(word, 0, root);\n}\n\nprivate boolean dfs(String word, int idx, TrieNode node) {\n    if (idx == word.length()) return node.isEnd;\n\n    char c = word.charAt(idx);\n    if (c == '.') {\n        // Wildcard: try ALL non-null children\n        for (TrieNode child : node.children) {\n            if (child != null && dfs(word, idx + 1, child))\n                return true;\n        }\n        return false;\n    } else {\n        TrieNode child = node.children[c - 'a'];\n        return child != null && dfs(word, idx + 1, child);\n    }\n}","problems":[{"name":"Design Add and Search Words (#211)","hint":"Insert normally. Search with DFS: on '.', try all 26 children. Worst case O(26^m) but pruned heavily by Trie structure."},{"name":"Prefix and Suffix Search (#745)","hint":"Insert all 'suffix#word' combinations. Search for 'suffix#prefix' in one Trie. Or use two Tries + intersection."}]}]},{"name":"ADVANCED_TRIE_PATTERNS","overview":"Beyond basic prefix matching, Tries power XOR optimization (bitwise Tries), compressed representations (radix trees), and complex string problems like palindrome pairs and stream matching.","variants":[{"name":"Bitwise Trie (XOR Problems)","description":"Build a Trie on the binary representation of numbers (typically 31 bits). To maximize XOR, greedily take the opposite bit at each level. This converts O(n²) pairwise XOR to O(n·31).","when":"Maximum XOR of two numbers, maximum XOR with subarray, XOR queries.","template":"// Maximum XOR of Two Numbers in an Array\nclass BitTrieNode {\n    BitTrieNode[] children = new BitTrieNode[2]; // 0 and 1\n}\n\npublic int findMaximumXOR(int[] nums) {\n    BitTrieNode root = new BitTrieNode();\n\n    // Insert all numbers (31 bits, MSB first)\n    for (int num : nums) {\n        BitTrieNode node = root;\n        for (int i = 30; i >= 0; i--) {\n            int bit = (num >> i) & 1;\n            if (node.children[bit] == null)\n                node.children[bit] = new BitTrieNode();\n            node = node.children[bit];\n        }\n    }\n\n    // For each number, greedily maximize XOR\n    int maxXor = 0;\n    for (int num : nums) {\n        BitTrieNode node = root;\n        int xor = 0;\n        for (int i = 30; i >= 0; i--) {\n            int bit = (num >> i) & 1;\n            int want = 1 - bit; // opposite bit maximizes XOR\n            if (node.children[want] != null) {\n                xor |= (1 << i);\n                node = node.children[want];\n            } else {\n                node = node.children[bit];\n            }\n        }\n        maxXor = Math.max(maxXor, xor);\n    }\n    return maxXor;\n}","problems":[{"name":"Maximum XOR of Two Numbers (#421)","hint":"Bitwise Trie. Insert all nums (31 bits). For each num, traverse greedily taking opposite bit. O(31n)."},{"name":"Maximum XOR With an Element From Array (#1707)","hint":"Sort queries by limit. Insert nums ≤ limit into Trie progressively. Greedy XOR query on each."},{"name":"Count Pairs With XOR in a Range (#1803)","hint":"Bitwise Trie with counts. For each num, query Trie for count of nums where XOR < high+1 minus count where XOR < low."}]},{"name":"Palindrome Pairs via Trie","description":"Insert reversed words into a Trie. For each word, traverse the Trie and check: (1) remaining suffix in Trie is a palindrome, (2) remaining suffix of word is a palindrome. This finds all pairs (i,j) where word[i] + word[j] is a palindrome in O(n·k²).","when":"Palindrome pairs, concatenation palindromes.","template":"// Key insight: word[i] + word[j] is palindrome when:\n// Case 1: reverse(word[j]) is a prefix of word[i],\n//          and the remaining suffix of word[i] is a palindrome\n// Case 2: word[i] is a prefix of reverse(word[j]),\n//          and the remaining suffix of reverse(word[j]) is a palindrome\n// Case 3: reverse(word[j]) == word[i]\n\n// Build Trie of reversed words.\n// For each word, traverse Trie checking both cases.\n// Store word index at isEnd nodes for result collection.","problems":[{"name":"Palindrome Pairs (#336)","hint":"Trie of reversed words. For each word, check 3 cases: exact match, word is longer, Trie word is longer. Check palindrome of remaining part."},{"name":"Shortest Palindrome (#214)","hint":"KMP or reverse string approach. Trie not needed but palindrome-prefix detection is the core idea."}]},{"name":"Stream / Continuous Matching","description":"Process characters one at a time. Maintain pointers into the Trie for all active matches. When a character arrives, advance all pointers and check for completed words.","when":"Multi-pattern matching in a stream, Aho-Corasick style, filter words appearing in a text stream.","template":"// Stream of Characters (#1032)\n// Maintain Trie of REVERSED words. On each char, search backwards.\nclass StreamChecker {\n    TrieNode root = new TrieNode();\n    StringBuilder stream = new StringBuilder();\n\n    public StreamChecker(String[] words) {\n        for (String w : words) {\n            TrieNode node = root;\n            // Insert REVERSED word\n            for (int i = w.length() - 1; i >= 0; i--) {\n                int idx = w.charAt(i) - 'a';\n                if (node.children[idx] == null)\n                    node.children[idx] = new TrieNode();\n                node = node.children[idx];\n            }\n            node.isEnd = true;\n        }\n    }\n\n    public boolean query(char c) {\n        stream.append(c);\n        TrieNode node = root;\n        // Search backwards from the latest character\n        for (int i = stream.length() - 1; i >= 0; i--) {\n            int idx = stream.charAt(i) - 'a';\n            if (node.children[idx] == null) return false;\n            node = node.children[idx];\n            if (node.isEnd) return true;\n        }\n        return false;\n    }\n}","problems":[{"name":"Stream of Characters (#1032)","hint":"Insert reversed words. On each query, walk backwards through stream chars in Trie. Return true if any word found."},{"name":"Multi Search (#17.17 CTCI)","hint":"Build Trie of small strings. For each position in big string, traverse Trie to find all matches starting there."}]},{"name":"Trie with Deletion / Pruning","description":"Support word removal by decrementing counts or recursively pruning empty branches. Critical for problems where the Trie changes over time.","when":"Dynamic word sets, removing found words to avoid re-discovery, LRU-style Trie caching.","template":"// Delete word from Trie (with pruning)\npublic boolean delete(TrieNode node, String word, int depth) {\n    if (depth == word.length()) {\n        if (!node.isEnd) return false; // word doesn't exist\n        node.isEnd = false;\n        return isEmpty(node); // can prune if no children\n    }\n    int idx = word.charAt(depth) - 'a';\n    if (node.children[idx] == null) return false;\n\n    boolean shouldPrune = delete(node.children[idx], word, depth + 1);\n    if (shouldPrune) {\n        node.children[idx] = null;\n        return !node.isEnd && isEmpty(node);\n    }\n    return false;\n}\n\nprivate boolean isEmpty(TrieNode node) {\n    for (TrieNode child : node.children)\n        if (child != null) return false;\n    return true;\n}","problems":[{"name":"Implement Trie II (#1804)","hint":"Use prefixCount and wordCount. Erase = decrement along path. No structural deletion needed if using counts."},{"name":"Word Search II (#212)","hint":"After finding a word, prune the branch if leaf has no children. Optimization: set node.word = null to dedup."}]}]},{"name":"BEYOND_TRIES","overview":"The final tier of DSA topics that build on everything: suffix arrays, segment trees, Fenwick trees (BIT), and advanced string algorithms. These rarely appear in standard interviews but are essential for competitive programming and some FAANG hard problems.","variants":[{"name":"Segment Tree (Range Query + Update)","description":"A binary tree where each node stores an aggregate (sum, min, max) for a range. Supports both point/range updates and range queries in O(log n). Build once from array, then query/update efficiently.","when":"Range sum with updates, range min/max queries, count of elements in a range, interval scheduling with queries.","template":"// Segment Tree for Range Sum Query with Point Updates\nclass SegmentTree {\n    int[] tree;\n    int n;\n\n    public SegmentTree(int[] nums) {\n        n = nums.length;\n        tree = new int[4 * n];\n        build(nums, 1, 0, n - 1);\n    }\n\n    private void build(int[] nums, int node, int lo, int hi) {\n        if (lo == hi) { tree[node] = nums[lo]; return; }\n        int mid = (lo + hi) / 2;\n        build(nums, 2 * node, lo, mid);\n        build(nums, 2 * node + 1, mid + 1, hi);\n        tree[node] = tree[2 * node] + tree[2 * node + 1];\n    }\n\n    public void update(int idx, int val, int node, int lo, int hi) {\n        if (lo == hi) { tree[node] = val; return; }\n        int mid = (lo + hi) / 2;\n        if (idx <= mid) update(idx, val, 2*node, lo, mid);\n        else update(idx, val, 2*node+1, mid+1, hi);\n        tree[node] = tree[2*node] + tree[2*node+1];\n    }\n\n    public int query(int l, int r, int node, int lo, int hi) {\n        if (r < lo || hi < l) return 0;       // out of range\n        if (l <= lo && hi <= r) return tree[node]; // fully in range\n        int mid = (lo + hi) / 2;\n        return query(l, r, 2*node, lo, mid)\n             + query(l, r, 2*node+1, mid+1, hi);\n    }\n}","problems":[{"name":"Range Sum Query – Mutable (#307)","hint":"Classic segment tree. Build O(n), update O(log n), query O(log n). Or use Fenwick tree."},{"name":"Count of Smaller Numbers After Self (#315)","hint":"Segment tree on value range. Process from right. Query count < current value, then update."},{"name":"Count of Range Sum (#327)","hint":"Merge sort approach or segment tree on prefix sums. Count pairs where lower ≤ P[j]-P[i] ≤ upper."}]},{"name":"Fenwick Tree / Binary Indexed Tree (BIT)","description":"A simpler alternative to segment trees for prefix sum queries with point updates. Uses bit manipulation (i & -i) to navigate. More compact and faster in practice, but less versatile (primarily prefix sums, not arbitrary ranges without tricks).","when":"Range sum queries with frequent updates, count inversions, order statistics.","template":"// Fenwick Tree (Binary Indexed Tree)\nclass BIT {\n    int[] tree;\n    int n;\n\n    public BIT(int n) {\n        this.n = n;\n        tree = new int[n + 1]; // 1-indexed\n    }\n\n    // Add delta to index i (1-indexed)\n    public void update(int i, int delta) {\n        for (; i <= n; i += i & (-i))\n            tree[i] += delta;\n    }\n\n    // Prefix sum [1..i]\n    public int query(int i) {\n        int sum = 0;\n        for (; i > 0; i -= i & (-i))\n            sum += tree[i];\n        return sum;\n    }\n\n    // Range sum [l..r]\n    public int rangeQuery(int l, int r) {\n        return query(r) - query(l - 1);\n    }\n}","problems":[{"name":"Range Sum Query – Mutable (#307)","hint":"Fenwick tree: update O(log n), prefix query O(log n). Simpler than segment tree for sum-only."},{"name":"Count of Smaller Numbers After Self (#315)","hint":"Coordinate compress values. Process from right. BIT query for count < current, then BIT update at current."},{"name":"Reverse Pairs (#493)","hint":"Merge sort (count during merge) or BIT with coordinate compression. Count j > i where nums[i] > 2 * nums[j]."}]},{"name":"Suffix Array / KMP / Rabin-Karp","description":"Advanced string algorithms. KMP for pattern matching in O(n+m). Rabin-Karp for rolling hash multi-pattern matching. Suffix arrays for substring queries on large texts.","when":"Repeated substring detection, pattern matching, longest repeated substring, string hashing for comparison.","template":"// KMP Pattern Matching — O(n + m)\npublic int kmpSearch(String text, String pattern) {\n    int[] lps = buildLPS(pattern);\n    int i = 0, j = 0;\n    while (i < text.length()) {\n        if (text.charAt(i) == pattern.charAt(j)) {\n            i++; j++;\n            if (j == pattern.length()) return i - j; // match found\n        } else if (j > 0) {\n            j = lps[j - 1]; // fall back in pattern\n        } else {\n            i++;\n        }\n    }\n    return -1;\n}\n\nprivate int[] buildLPS(String pattern) {\n    int[] lps = new int[pattern.length()];\n    int len = 0, i = 1;\n    while (i < pattern.length()) {\n        if (pattern.charAt(i) == pattern.charAt(len)) {\n            lps[i++] = ++len;\n        } else if (len > 0) {\n            len = lps[len - 1];\n        } else {\n            lps[i++] = 0;\n        }\n    }\n    return lps;\n}\n\n// Rabin-Karp rolling hash (for multi-pattern or substring matching)\n// hash = Σ(s[i] * BASE^(m-1-i)) % MOD\n// Roll: hash = (hash - s[left] * BASE^(m-1)) * BASE + s[right]","problems":[{"name":"Shortest Palindrome (#214)","hint":"KMP trick: compute LPS of word + '#' + reverse(word). LPS last value = longest palindromic prefix."},{"name":"Repeated Substring Pattern (#459)","hint":"KMP: if (n % (n - lps[n-1]) == 0) and lps[n-1] > 0, then repeating pattern exists."},{"name":"Longest Duplicate Substring (#1044)","hint":"Binary search on length + Rabin-Karp rolling hash. Or suffix array. O(n log n)."},{"name":"Find the Index of the First Occurrence (#28)","hint":"KMP for O(n+m). Or built-in indexOf. Good for understanding KMP basics."}]},{"name":"Monotonic Stack + Advanced Combos","description":"When Trie problems combine with other advanced techniques: Trie + DP (word break), Trie + backtracking (word squares), Trie + bit manipulation (XOR queries with constraints).","when":"Word break with dictionary, word squares, concatenated words, complex multi-pattern problems.","template":"// Word Break using Trie (alternative to DP + HashSet)\n// Build Trie from wordDict. DP: dp[i] = can we segment s[0..i-1]\npublic boolean wordBreak(String s, List<String> wordDict) {\n    TrieNode root = new TrieNode();\n    for (String w : wordDict) {\n        TrieNode node = root;\n        for (char c : w.toCharArray()) {\n            int idx = c - 'a';\n            if (node.children[idx] == null)\n                node.children[idx] = new TrieNode();\n            node = node.children[idx];\n        }\n        node.isEnd = true;\n    }\n\n    boolean[] dp = new boolean[s.length() + 1];\n    dp[0] = true;\n    for (int i = 0; i < s.length(); i++) {\n        if (!dp[i]) continue;\n        TrieNode node = root;\n        for (int j = i; j < s.length(); j++) {\n            int idx = s.charAt(j) - 'a';\n            if (node.children[idx] == null) break;\n            node = node.children[idx];\n            if (node.isEnd) dp[j + 1] = true;\n        }\n    }\n    return dp[s.length()];\n}","problems":[{"name":"Word Break (#139)","hint":"DP + Trie (or HashSet). dp[i] = true if s[0..i-1] can be segmented. Trie avoids checking all dict words at each position."},{"name":"Word Break II (#140)","hint":"Trie + backtracking with memoization. Collect all valid segmentations."},{"name":"Concatenated Words (#472)","hint":"Sort by length. For each word, check if it can be formed by previously seen shorter words (Word Break). Insert into Trie after."},{"name":"Word Squares (#425)","hint":"Trie for prefix lookup. Backtracking: at each row, use Trie to find words matching the required prefix from column constraints."}]}]}]}};
const DSA = {"dataStructures":[{"name":"Arrays","icon":"▦","complexity":{"access":"O(1)","search":"O(n)","insert":"O(n)","delete":"O(n)"},"keyPoints":["Contiguous memory allocation — cache-friendly","Fixed size (static) or resizable (dynamic/ArrayList)","Random access via index in constant time","Insertions/deletions expensive due to shifting"],"whenToUse":"Need fast index-based access, known or bounded size, cache performance matters.","commonPatterns":["Two pointers","Sliding window","Prefix sums","Kadane's algorithm"]},{"name":"Linked Lists","icon":"⟿","complexity":{"access":"O(n)","search":"O(n)","insert":"O(1)*","delete":"O(1)*"},"keyPoints":["Nodes with data + pointer(s) to next (and prev for doubly)","O(1) insert/delete *at known position* — O(n) to find it","No random access — must traverse from head","Singly, doubly, and circular variants"],"whenToUse":"Frequent insert/delete at ends, implementing stacks/queues, unknown size.","commonPatterns":["Fast & slow pointers (cycle detection)","Reverse a linked list","Merge two sorted lists","Dummy head technique"]},{"name":"Stacks","icon":"⏛","complexity":{"access":"O(n)","search":"O(n)","insert":"O(1)","delete":"O(1)"},"keyPoints":["LIFO — Last In, First Out","Push to top, pop from top","Can implement with array or linked list","Call stack in recursion follows this pattern"],"whenToUse":"Undo operations, expression evaluation, DFS, backtracking, matching brackets.","commonPatterns":["Monotonic stack","Next greater element","Valid parentheses","Min stack"]},{"name":"Queues","icon":"⏩","complexity":{"access":"O(n)","search":"O(n)","insert":"O(1)","delete":"O(1)"},"keyPoints":["FIFO — First In, First Out","Enqueue at rear, dequeue from front","Variants: deque (double-ended), priority queue, circular queue","BFS traversal uses a queue"],"whenToUse":"BFS, scheduling, buffering, sliding window max/min (deque).","commonPatterns":["BFS traversal","Level-order tree traversal","Sliding window maximum","Task scheduling"]},{"name":"Hash Tables","icon":"⊞","complexity":{"access":"N/A","search":"O(1)*","insert":"O(1)*","delete":"O(1)*"},"keyPoints":["Key → hash function → bucket index","Average O(1) ops — worst case O(n) with collisions","Collision resolution: chaining or open addressing","Load factor triggers resizing (rehashing)"],"whenToUse":"Fast lookups by key, counting frequencies, deduplication, caching.","commonPatterns":["Two sum","Group anagrams","Frequency counting","Subarray sum equals K"]},{"name":"Trees","icon":"🜂","complexity":{"access":"O(log n)*","search":"O(log n)*","insert":"O(log n)*","delete":"O(log n)*"},"keyPoints":["Hierarchical structure — root, children, leaves","Binary tree: ≤ 2 children per node","BST: left < parent < right — enables binary search","Balanced variants: AVL, Red-Black — guarantee O(log n)"],"whenToUse":"Hierarchical data, sorted data with fast ops, range queries, file systems.","commonPatterns":["DFS (inorder, preorder, postorder)","BFS (level order)","LCA (lowest common ancestor)","Serialize/deserialize"]},{"name":"Heaps","icon":"△","complexity":{"access":"O(1)*","search":"O(n)","insert":"O(log n)","delete":"O(log n)"},"keyPoints":["Complete binary tree with heap property","Min-heap: parent ≤ children — Max-heap: parent ≥ children","O(1) access to min/max, O(log n) insert/extract","Typically implemented as an array"],"whenToUse":"Priority queues, top-K problems, median finding, Dijkstra's, merge K sorted lists.","commonPatterns":["Top K elements","Merge K sorted lists","Running median","Task scheduler"]},{"name":"Graphs","icon":"◈","complexity":{"access":"—","search":"O(V+E)","insert":"O(1)","delete":"O(V+E)"},"keyPoints":["Vertices (nodes) + Edges (connections)","Directed vs undirected, weighted vs unweighted, cyclic vs acyclic","Representations: adjacency list (sparse) vs adjacency matrix (dense)","DAG — directed acyclic graph — enables topological sort"],"whenToUse":"Networks, relationships, routing, dependency resolution, social graphs.","commonPatterns":["BFS/DFS traversal","Topological sort","Dijkstra / Bellman-Ford","Union-Find (disjoint sets)"]},{"name":"Tries","icon":"⑂","complexity":{"access":"O(m)","search":"O(m)","insert":"O(m)","delete":"O(m)"},"keyPoints":["Prefix tree — each node represents a character","m = length of the key/word","Shared prefixes save space","Supports prefix matching and autocomplete efficiently"],"whenToUse":"Autocomplete, spell checking, IP routing, word search, prefix matching.","commonPatterns":["Word search II","Implement autocomplete","Longest common prefix","Palindrome pairs"]}],"algorithms":[{"category":"Sorting","items":[{"name":"Quick Sort","time":"O(n log n)*","space":"O(log n)","stable":false,"note":"Avg case fast, worst O(n²). Partition around pivot."},{"name":"Merge Sort","time":"O(n log n)","space":"O(n)","stable":true,"note":"Guaranteed O(n log n). Divide → sort halves → merge."},{"name":"Heap Sort","time":"O(n log n)","space":"O(1)","stable":false,"note":"In-place, not stable. Build max-heap, extract max repeatedly."},{"name":"Counting Sort","time":"O(n + k)","space":"O(k)","stable":true,"note":"Non-comparison. Works when range k is small."}]},{"category":"Searching","items":[{"name":"Binary Search","time":"O(log n)","space":"O(1)","note":"Sorted array required. Halve search space each step."},{"name":"BFS","time":"O(V + E)","space":"O(V)","note":"Level-by-level. Shortest path in unweighted graphs. Uses queue."},{"name":"DFS","time":"O(V + E)","space":"O(V)","note":"Go deep first. Uses stack/recursion. Good for exhaustive search."}]},{"category":"Graph Algorithms","items":[{"name":"Dijkstra's","time":"O((V+E) log V)","space":"O(V)","note":"Shortest path, non-negative weights. Uses min-heap."},{"name":"Bellman-Ford","time":"O(V·E)","space":"O(V)","note":"Handles negative weights. Detects negative cycles."},{"name":"Topological Sort","time":"O(V + E)","space":"O(V)","note":"Linear ordering of DAG. Kahn's (BFS) or DFS-based."},{"name":"Union-Find","time":"O(α(n)) ≈ O(1)","space":"O(n)","note":"Disjoint sets. Path compression + union by rank."}]},{"category":"Dynamic Programming","items":[{"name":"Memoization (Top-Down)","time":"Varies","space":"O(subproblems)","note":"Recursive + cache. Natural problem decomposition."},{"name":"Tabulation (Bottom-Up)","time":"Varies","space":"O(subproblems)","note":"Iterative table filling. Often space-optimizable."}]}],"dpPatterns":[{"pattern":"Linear DP","examples":"Climbing stairs, house robber, decode ways","formula":"dp[i] depends on dp[i-1], dp[i-2], ..."},{"pattern":"Knapsack","examples":"0/1 knapsack, subset sum, coin change","formula":"dp[i][w] = max(include item i, exclude item i)"},{"pattern":"LCS / Edit Distance","examples":"Longest common subsequence, min edit distance","formula":"dp[i][j] using dp[i-1][j], dp[i][j-1], dp[i-1][j-1]"},{"pattern":"Interval DP","examples":"Matrix chain multiplication, burst balloons","formula":"dp[i][j] = best over all splits k in [i, j]"},{"pattern":"Tree DP","examples":"Max path sum, house robber III, diameter","formula":"Solve for subtrees, combine at parent"},{"pattern":"Bitmask DP","examples":"Traveling salesman, assign tasks","formula":"dp[mask] = best config for subset represented by bitmask"}],"problemSolvingFramework":[{"step":"1","title":"Understand","detail":"Restate the problem. Clarify inputs, outputs, constraints, edge cases."},{"step":"2","title":"Examples","detail":"Walk through 2–3 examples by hand. Include edge cases (empty, single element, duplicates)."},{"step":"3","title":"Brute Force","detail":"State the naive solution and its complexity. This shows understanding and gives a baseline."},{"step":"4","title":"Optimize","detail":"Identify bottlenecks. Can you trade space for time? Does sorting help? Recognize patterns."},{"step":"5","title":"Code","detail":"Write clean, readable code. Use meaningful names. Handle edge cases explicitly."},{"step":"6","title":"Test","detail":"Trace through your code with examples. Verify edge cases. Analyze final time & space complexity."}]};

// Blind 75 problem numbers
const BLIND75 = new Set([1,3,5,11,15,20,21,23,33,39,42,48,49,53,54,55,56,57,62,70,73,76,79,98,100,102,104,105,121,124,125,128,133,139,141,143,152,153,167,190,191,198,200,206,207,208,211,212,213,217,226,230,235,238,242,252,253,261,268,269,271,283,295,297,300,322,323,338,347,371,417,424]);
const NEETCODE150_EXTRA = new Set([7,19,22,25,36,43,46,51,66,74,75,78,84,91,97,115,127,130,131,136,138,146,148,155,199,202,210,215,239,261,287,295,312,332,355,416,572,621,659,684,703,739,743,778,846,853,875,981,1046,1143,1584]);

// ====== TOPICS ======
const TOPICS = [
  {id:'arrays-strings',name:'Arrays & Strings',icon:'▦',order:1,desc:'Two pointers, sliding window, prefix sums'},
  {id:'hashmap',name:'Hash Maps',icon:'⊞',order:2,desc:'Frequency counting, two sum variants, grouping'},
  {id:'stacks-queues',name:'Stacks & Queues',icon:'⏛',order:3,desc:'Monotonic stack, BFS, expression evaluation'},
  {id:'linked-lists',name:'Linked Lists',icon:'⟿',order:4,desc:'Fast/slow pointers, reversal, merge'},
  {id:'trees',name:'Trees',icon:'🜂',order:5,desc:'DFS/BFS, BST operations, recursion patterns'},
  {id:'graphs',name:'Graphs',icon:'◈',order:6,desc:'BFS/DFS, topological sort, Union-Find'},
  {id:'heaps',name:'Heaps',icon:'△',order:7,desc:'Top-K, merge K sorted, two heaps'},
  {id:'dp',name:'Dynamic Programming',icon:'◇',order:8,desc:'1D/2D DP, knapsack, LCS, bitmask'},
  {id:'tries',name:'Tries & Advanced',icon:'⑂',order:9,desc:'Prefix trees, word search, XOR trie'},
];

// ====== PATTERN DECISION TREE ======
const DECISION_TREE = [
  {q:"What does the problem ask for?",opts:[
    {label:"Find a pair/triplet with a target sum",next:"sum"},
    {label:"Find longest/shortest subarray or substring",next:"subarray"},
    {label:"Shortest path or minimum steps",next:"shortest"},
    {label:"Top K / Kth largest or smallest",next:"topk"},
    {label:"Count ways / combinations / partitions",next:"dp"},
    {label:"Connected components / groups",next:"graph"},
    {label:"Nested / matched brackets / undo",next:"stack"},
    {label:"Prefix matching / autocomplete",next:"trie"},
    {label:"Intervals / scheduling / merge",next:"interval"},
    {label:"Something else — let me think more",next:"more"}
  ]},
  {id:"sum",result:"Two Pointers or HashMap",detail:"If sorted → two pointers (O(n)). If unsorted → HashMap to store complements. For 3Sum: sort + fix one + two pointers. For 4Sum II: split halves into two HashMaps.",topic:"arrays-strings"},
  {id:"subarray",q:"What kind of constraint?",opts:[
    {label:"At most K distinct / sum ≥ target / no repeats",next:"sliding"},
    {label:"Exact sum = K (can have negatives)",next:"prefix"},
    {label:"Longest increasing / chain",next:"lis"}
  ]},
  {id:"sliding",result:"Sliding Window",detail:"Expand right pointer, shrink left when constraint violated. Variable window: track condition, update answer between shrinks. Fixed window: slide and maintain state. O(n).",topic:"arrays-strings"},
  {id:"prefix",result:"Prefix Sum + HashMap",detail:"prefix[j] - prefix[i] = k. Store prefix sums in HashMap. For each j, check if (currentPrefix - k) exists. Don't forget map.put(0, 1) initialization!",topic:"hashmap"},
  {id:"lis",result:"LIS / DP",detail:"dp[i] = length of LIS ending at i. O(n²) naive, O(n log n) with binary search on tails array. For chains: sort + LIS.",topic:"dp"},
  {id:"shortest",q:"Weighted or unweighted graph?",opts:[
    {label:"Unweighted (grid, word ladder, etc.)",next:"bfs"},
    {label:"Weighted edges",next:"dijkstra"},
    {label:"With state constraints (keys, limited moves)",next:"bfs_state"}
  ]},
  {id:"bfs",result:"BFS (Breadth-First Search)",detail:"Queue-based, level by level. Guarantees shortest path in unweighted graphs. Multi-source BFS: add ALL sources to queue before starting.",topic:"graphs"},
  {id:"dijkstra",result:"Dijkstra's Algorithm",detail:"Priority queue (min-heap). Greedy: always expand closest unvisited node. O((V+E) log V). Skip stale entries: if d > dist[u], continue.",topic:"heaps"},
  {id:"bfs_state",result:"BFS with State Encoding",detail:"State = (position, extra_info). Visited per state, not per position. E.g., (row, col, keyBitmask). HashSet<String> or boolean[r][c][state].",topic:"graphs"},
  {id:"topk",result:"Heap (Priority Queue)",detail:"K largest → min-heap of size K. K smallest → max-heap of size K. After processing all elements, heap contains answer. O(n log k).",topic:"heaps"},
  {id:"dp",q:"What kind of DP?",opts:[
    {label:"Linear sequence (stairs, robber, decode)",next:"dp1d"},
    {label:"Two strings (edit distance, LCS)",next:"dp2d"},
    {label:"Grid paths / min cost",next:"dpgrid"},
    {label:"Subset / knapsack / partition",next:"dpknap"},
    {label:"Stock trading / state machine",next:"dpstate"}
  ]},
  {id:"dp1d",result:"1D Linear DP",detail:"dp[i] depends on dp[i-1], dp[i-2], etc. Often O(1) space by tracking last 2-3 values. Key: define what dp[i] represents clearly before coding.",topic:"dp"},
  {id:"dp2d",result:"Two-String DP",detail:"dp[i][j] = answer for s1[0..i-1] vs s2[0..j-1]. Three transitions: match (diagonal), mismatch (top/left/diagonal + cost). Fill row by row.",topic:"dp"},
  {id:"dpgrid",result:"Grid Path DP",detail:"dp[i][j] = ways or min cost to reach (i,j). Depends on dp[i-1][j] and dp[i][j-1]. Initialize first row and column. Can optimize to 1D.",topic:"dp"},
  {id:"dpknap",result:"Knapsack / Subset Sum DP",detail:"0/1 knapsack: dp[i][w] = skip (dp[i-1][w]) or take (dp[i-1][w-wt] + val). 1D: iterate capacity BACKWARDS. Unbounded: iterate FORWARD.",topic:"dp"},
  {id:"dpstate",result:"State Machine DP",detail:"Track states: holding, sold, cooldown. Transitions between states at each step. Draw the state diagram first, then code transitions.",topic:"dp"},
  {id:"graph",q:"What graph operation?",opts:[
    {label:"Count/find connected components",next:"components"},
    {label:"Detect cycles / ordering",next:"topo"},
    {label:"Dynamic connectivity / merge groups",next:"uf"}
  ]},
  {id:"components",result:"DFS or BFS Flood Fill",detail:"For each unvisited node, DFS/BFS to mark all reachable nodes. Count the number of times you start a new search = number of components.",topic:"graphs"},
  {id:"topo",result:"Topological Sort",detail:"Kahn's (BFS): track in-degrees, process nodes with in-degree 0. If processed < total nodes, cycle exists. DFS: post-order reversal.",topic:"graphs"},
  {id:"uf",result:"Union-Find (Disjoint Set Union)",detail:"find(x) with path compression + union(x,y) by rank. Near O(1) per operation. Count components: start with N, decrement on each successful union.",topic:"graphs"},
  {id:"stack",result:"Stack",detail:"Matching → push opening, pop on closing. Monotonic stack → next greater/smaller element. Expression → two stacks (operands + operators). Nested → save state on push, restore on pop.",topic:"stacks-queues"},
  {id:"trie",result:"Trie (Prefix Tree)",detail:"TrieNode with children[26] and isEnd. Insert/search/startsWith all O(m). For grid word search: build Trie from dictionary, DFS grid with Trie traversal.",topic:"tries"},
  {id:"interval",result:"Sort + Sweep/Merge",detail:"Sort by start time. Merge: compare end of last with start of current. Meeting rooms: min-heap of end times. Line sweep: events at start/end points.",topic:"arrays-strings"},
  {id:"more",q:"What property does the input have?",opts:[
    {label:"Sorted array → Binary Search",next:"bs"},
    {label:"Tree structure → DFS Recursion",next:"tree"},
    {label:"Array rearrangement in-place",next:"cyclic"},
    {label:"Next greater/smaller element",next:"mono"}
  ]},
  {id:"bs",result:"Binary Search",detail:"Search space has monotonic property. lo, hi, mid. Decide which half to keep. For 'minimum that satisfies': leftmost binary search. O(log n).",topic:"arrays-strings"},
  {id:"tree",result:"Tree DFS (Recursion)",detail:"Bottom-up: return value from children, combine at root. Top-down: pass parameters down. Global var: track answer across all recursive calls.",topic:"trees"},
  {id:"cyclic",result:"Cyclic Sort / Two Pointers",detail:"If values are in range [1, n], place each at index value-1. Swap until all in place. Finds missing/duplicate in O(n) time, O(1) space.",topic:"arrays-strings"},
  {id:"mono",result:"Monotonic Stack",detail:"Decreasing stack for next greater. Increasing stack for next smaller. Store INDICES. Pop reveals answer for the popped element. O(n) total.",topic:"stacks-queues"},
];

// ====== STATE ======
let state = {
  view:'dashboard', topic:null, subView:'problems', search:'', diffFilter:'All', blind75Only:false,
  openProblems:new Set(), openTiers:new Set(['0','1','2','3','4']), openCards:new Set(),
  hintLevels:{}, // problemKey -> number of hints revealed
  completed: JSON.parse(localStorage.getItem('dsa_completed')||'{}'),
  completedAt: JSON.parse(localStorage.getItem('dsa_completed_at')||'{}'),
  timerActive:false, timerSeconds:0, timerTotal:2700, timerInterval:null,
  dtPath:[], // decision tree navigation path
};

function saveProgress(){
  localStorage.setItem('dsa_completed',JSON.stringify(state.completed));
  localStorage.setItem('dsa_completed_at',JSON.stringify(state.completedAt));
}

function toggleComplete(tid,pid){
  const k=tid+':'+pid;
  if(state.completed[k]){delete state.completed[k];delete state.completedAt[k];}
  else{state.completed[k]=true;state.completedAt[k]=Date.now();}
  saveProgress();render();
}

function getTopicProgress(tid){
  const tiers=PROBLEMS[tid]||[];
  let total=0,done=0;
  tiers.forEach(t=>t.problems.forEach(p=>{total++;if(state.completed[tid+':'+p.id])done++;}));
  return{total,done,pct:total?Math.round(done/total*100):0};
}

function getTotalProgress(){
  let total=0,done=0;
  Object.keys(PROBLEMS).forEach(k=>{const p=getTopicProgress(k);total+=p.total;done+=p.done;});
  return{total,done,pct:total?Math.round(done/total*100):0};
}

function getAllProblems(){
  let all=[];
  Object.entries(PROBLEMS).forEach(([tid,tiers])=>{
    tiers.forEach((t,ti)=>t.problems.forEach(p=>{all.push({...p,topicId:tid,tierIdx:ti,tierName:t.name,tierColor:t.color});}));
  });
  return all;
}

function getRandomUnsolved(){
  const all=getAllProblems().filter(p=>!state.completed[p.topicId+':'+p.id]);
  if(all.length===0)return null;
  // Weight toward Tier 1 problems
  const weighted=all.flatMap(p=>p.tierIdx===0?[p,p,p]:p.tierIdx===1?[p,p]:[p]);
  return weighted[Math.floor(Math.random()*weighted.length)];
}

function getReviewQueue(){
  const now=Date.now();
  const day=86400000;
  return getAllProblems()
    .filter(p=>{
      const at=state.completedAt[p.topicId+':'+p.id];
      return at && (now-at)>3*day; // completed more than 3 days ago
    })
    .sort((a,b)=>(state.completedAt[a.topicId+':'+a.id]||0)-(state.completedAt[b.topicId+':'+b.id]||0))
    .slice(0,10);
}

function toast(msg){
  const el=document.getElementById('toast');
  el.textContent=msg;el.classList.add('show');
  setTimeout(()=>el.classList.remove('show'),2500);
}

function exportProgress(){
  const data=JSON.stringify({completed:state.completed,completedAt:state.completedAt});
  const blob=new Blob([data],{type:'application/json'});
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a');a.href=url;a.download='dsa-progress.json';a.click();
  URL.revokeObjectURL(url);toast('Progress exported!');
}

function importProgress(){
  const input=document.createElement('input');input.type='file';input.accept='.json';
  input.onchange=e=>{
    const file=e.target.files[0];if(!file)return;
    const reader=new FileReader();
    reader.onload=ev=>{
      try{
        const d=JSON.parse(ev.target.result);
        if(d.completed){state.completed={...state.completed,...d.completed};state.completedAt={...state.completedAt,...(d.completedAt||{})};saveProgress();render();toast('Progress imported!');}
      }catch(err){toast('Invalid file');}
    };
    reader.readAsText(file);
  };
  input.click();
}

// Timer
function startTimer(mins){
  state.timerActive=true;state.timerTotal=mins*60;state.timerSeconds=mins*60;
  if(state.timerInterval)clearInterval(state.timerInterval);
  state.timerInterval=setInterval(()=>{
    state.timerSeconds--;
    if(state.timerSeconds<=0){clearInterval(state.timerInterval);state.timerActive=false;toast('⏰ Time is up!');render();}
    else renderTimer();
  },1000);
  render();
}
function stopTimer(){
  if(state.timerInterval)clearInterval(state.timerInterval);
  state.timerActive=false;state.timerSeconds=0;render();
}
function renderTimer(){
  const el=document.getElementById('timer-display');
  if(el){const m=Math.floor(state.timerSeconds/60);const s=state.timerSeconds%60;el.textContent=String(m).padStart(2,'0')+':'+String(s).padStart(2,'0');}
  const bar=document.getElementById('timer-progress');
  if(bar){bar.style.width=(state.timerSeconds/state.timerTotal*100)+'%';}
}

// Syntax highlighting
function hlCode(code){
  if(!code)return '';
  return code.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')
    .replace(/(\/\/.*$)/gm,'<span class="comment">$1</span>')
    .replace(/\b(public|private|static|void|return|if|else|while|for|new|int|boolean|String|null|true|false|break|continue|class|this|import|final|try|catch|throw|extends|implements)\b/g,'<span class="keyword">$1</span>')
    .replace(/\b(ListNode|TreeNode|Map|HashMap|Set|HashSet|List|ArrayList|Queue|Stack|Deque|ArrayDeque|PriorityQueue|StringBuilder|Arrays|Collections|Math|Integer|Character|LinkedList)\b/g,'<span class="type">$1</span>')
    .replace(/\b(\d+)\b/g,'<span class="number">$1</span>');
}

// ====== DOM HELPERS ======
function h(tag,attrs,...ch){
  const el=document.createElement(tag);
  if(attrs)Object.entries(attrs).forEach(([k,v])=>{
    if(k==='className')el.className=v;
    else if(k==='style'&&typeof v==='object')Object.assign(el.style,v);
    else if(k.startsWith('on'))el.addEventListener(k.slice(2).toLowerCase(),v);
    else if(k==='innerHTML')el.innerHTML=v;
    else el.setAttribute(k,v);
  });
  ch.flat(4).forEach(c=>{if(c!=null&&c!==false)el.appendChild(typeof c==='string'||typeof c==='number'?document.createTextNode(String(c)):c);});
  return el;
}

// ====== RENDER: DASHBOARD ======
function renderDashboard(){
  const total=getTotalProgress();
  const review=getReviewQueue();
  return h('div',{className:'fade-in'},[
    h('div',{className:'hero'},[
      h('div',{className:'hero-label'},'Interview Prep Portal'),
      h('h1',null,'DSA Mastery'),
      h('p',null,'9 Topics · 453 Problems · Code Templates · Pattern Decision Tree'),
    ]),
    // Search
    h('div',{className:'search-wrap',style:{maxWidth:'560px',margin:'20px auto'}},[
      h('span',{className:'search-icon'},'⌕'),
      h('input',{className:'search-input',placeholder:'Search all 453 problems across 9 topics...',
        onKeydown:e=>{if(e.key==='Enter'&&e.target.value.length>=2){state.search=e.target.value;state.view='search';render();}},
        onInput:e=>{if(e.target.value.length>=2){state.search=e.target.value;state.view='search';render();}}
      }),
    ]),
    // Stats
    h('div',{className:'stats-bar'},[
      h('div',{className:'stat'},[h('div',{className:'stat-num'},String(total.done)),h('div',{className:'stat-label'},'Solved')]),
      h('div',{className:'stat'},[h('div',{className:'stat-num'},String(total.total)),h('div',{className:'stat-label'},'Total')]),
      h('div',{className:'stat'},[h('div',{className:'stat-num'},total.pct+'%'),h('div',{className:'stat-label'},'Progress')]),
      h('div',{className:'stat'},[h('div',{className:'stat-num'},String(review.length)),h('div',{className:'stat-label'},'To Review')]),
    ]),
    // Quick actions
    h('div',{className:'quick-actions'},[
      h('button',{className:'qa-btn',onClick:()=>{const p=getRandomUnsolved();if(p){state.view='topic';state.topic=p.topicId;state.subView='problems';state.search=p.title;render();window.scrollTo(0,0);toast('Random: #'+p.num+' '+p.title);}else toast('All problems solved! 🎉');}},[h('span',{className:'qa-icon'},'🎲'),('Pick Random Problem')]),
      h('button',{className:'qa-btn',onClick:()=>{state.view='formulas';state.formulaFilter='All';render();window.scrollTo(0,0);}},[h('span',{className:'qa-icon'},'📐'),('Formula Sheet')]),
      h('button',{className:'qa-btn',onClick:()=>{state.view='decide';state.dtPath=[];render();window.scrollTo(0,0);}},[h('span',{className:'qa-icon'},'🧭'),('Pattern Finder')]),
      h('button',{className:'qa-btn',onClick:()=>startTimer(45)},[h('span',{className:'qa-icon'},'⏱'),('45 min Timer')]),
      h('button',{className:'qa-btn',onClick:()=>{state.view='review';render();window.scrollTo(0,0);}},[h('span',{className:'qa-icon'},'🔄'),('Review Queue'),review.length>0?h('span',{style:{background:'var(--red)',color:'#fff',borderRadius:'50%',width:'16px',height:'16px',display:'inline-flex',alignItems:'center',justifyContent:'center',fontSize:'9px',fontWeight:700,marginLeft:'4px'}},String(review.length)):null]),
      h('button',{className:'qa-btn',onClick:exportProgress},[h('span',{className:'qa-icon'},'💾'),('Export')]),
      h('button',{className:'qa-btn',onClick:importProgress},[h('span',{className:'qa-icon'},'📂'),('Import')]),
    ]),
    // Topic grid
    h('div',{className:'topic-grid'},TOPICS.map(t=>renderTopicCard(t))),
    // Overview
    renderOverview(),
  ]);
}

function renderTopicCard(topic){
  const prog=getTopicProgress(topic.id);
  const guide=GUIDES[topic.id];
  const patterns=guide?guide.patterns.flatMap(p=>p.variants.map(v=>v.name)).slice(0,4):[];
  return h('div',{className:'topic-card',onClick:()=>{state.view='topic';state.topic=topic.id;state.subView='problems';state.diffFilter='All';state.blind75Only=false;state.search='';render();window.scrollTo(0,0);}},[
    h('div',{className:'tc-top'},[h('span',{className:'topic-icon'},topic.icon),h('div',{className:'topic-name'},topic.name)]),
    h('div',{className:'topic-meta'},prog.done+'/'+prog.total+' solved · '+prog.pct+'%'),
    patterns.length>0?h('div',{className:'topic-patterns'},patterns.map(p=>h('span',{className:'pattern-tag'},p))):null,
    h('div',{className:'topic-progress'},[h('div',{className:'topic-progress-bar',style:{width:prog.pct+'%'}})]),
  ]);
}

function renderOverview(){
  if(!DSA)return h('div');
  return h('div',{style:{marginTop:'32px'}},[
    // Complexity table
    h('div',{style:{background:'var(--bg2)',border:'1px solid rgba(255,255,255,0.04)',borderRadius:'var(--radius)',overflow:'hidden',marginBottom:'20px'}},[
      h('div',{style:{padding:'14px 16px',borderBottom:'1px solid rgba(255,255,255,0.04)',font:'normal 16px/1 var(--font-display)',color:'var(--accent)'}},'Complexity Quick Reference'),
      h('div',{style:{overflowX:'auto'}},[h('table',{className:'overview-table'},[
        h('thead',null,h('tr',null,['Structure','Access','Search','Insert','Delete'].map(x=>h('th',null,x)))),
        h('tbody',null,(DSA.dataStructures||[]).map(ds=>h('tr',null,[
          h('td',{style:{color:'var(--text)',fontWeight:500}},ds.name),
          ...Object.values(ds.complexity).map(v=>{const cls=v.includes('1)')&&!v.includes('n')?'c-fast':v.includes('log')?'c-med':'c-slow';return h('td',{className:cls},v);})
        ])))
      ])]),
    ]),
    // Pattern recognition
    h('div',{style:{background:'var(--bg2)',border:'1px solid rgba(255,255,255,0.04)',borderRadius:'var(--radius)',padding:'16px',marginBottom:'20px'}},[
      h('div',{style:{font:'normal 16px/1 var(--font-display)',color:'var(--accent)',marginBottom:'12px'}},'Interview Pattern Shortcuts'),
      ...([
        ['"Find pair/triplet with sum"','→ HashMap or Two Pointers'],
        ['"Longest/shortest subarray with condition"','→ Sliding Window'],
        ['"Subarray sum equals K (negatives ok)"','→ Prefix Sum + HashMap'],
        ['"Shortest path / minimum steps"','→ BFS (unweighted) or Dijkstra'],
        ['"Top K / Kth element"','→ Heap of size K'],
        ['"Count ways / combinations"','→ Dynamic Programming'],
        ['"Connected components"','→ Union-Find or DFS'],
        ['"Parentheses / nesting"','→ Stack'],
        ['"Next greater/smaller element"','→ Monotonic Stack'],
        ['"Prefix lookup / autocomplete"','→ Trie'],
      ]).map(([s,a])=>h('div',{style:{display:'flex',gap:'8px',marginBottom:'5px',fontSize:'12px',flexWrap:'wrap'}},[
        h('span',{style:{color:'var(--blue)',fontFamily:'var(--font-mono)',fontSize:'11px'}},s),
        h('span',{style:{color:'var(--text2)'}},a),
      ])),
    ]),
    // Study order
    h('div',{style:{background:'var(--accent-bg)',border:'1px solid var(--accent-border)',borderRadius:'var(--radius)',padding:'16px'}},[
      h('div',{style:{font:'normal 16px/1 var(--font-display)',color:'var(--accent)',marginBottom:'10px'}},'Recommended Study Order'),
      ...TOPICS.map((t,i)=>h('div',{style:{display:'flex',gap:'10px',marginBottom:'6px',fontSize:'12px',color:'var(--text2)',cursor:'pointer'},onClick:()=>{state.view='topic';state.topic=t.id;state.subView='problems';render();window.scrollTo(0,0);}},[
        h('span',{style:{color:'var(--accent)',fontFamily:'var(--font-mono)',fontSize:'11px',minWidth:'18px',opacity:.5}},String(i+1).padStart(2,'0')),
        h('span',null,t.name+' — '+t.desc),
      ])),
    ]),
  ]);
}

// ====== RENDER: DECISION TREE ======
function renderDecisionTree(){
  const path=state.dtPath;
  let currentId=null;
  if(path.length===0)currentId=null;
  else currentId=path[path.length-1];
  
  const currentNode=currentId?DECISION_TREE.find(n=>n.id===currentId):DECISION_TREE[0];
  
  return h('div',{className:'fade-in'},[
    h('button',{className:'back-btn',onClick:()=>{if(path.length>0){path.pop();render();}else{state.view='dashboard';render();window.scrollTo(0,0);}}},[path.length>0?'← Back':'← Dashboard']),
    h('div',{className:'section-header'},[
      h('h2',null,'🧭 Pattern Decision Tree'),
      h('p',null,'Answer questions to find the right approach for your problem'),
    ]),
    currentNode.result?
      h('div',{className:'dt-result'},[
        h('h4',null,'→ '+currentNode.result),
        h('p',null,currentNode.detail),
        currentNode.topic?h('button',{className:'qa-btn',style:{marginTop:'10px'},onClick:()=>{state.view='topic';state.topic=currentNode.topic;state.subView='guide';render();window.scrollTo(0,0);}},[h('span',{className:'qa-icon'},'📖'),'Study this pattern']):null,
        h('button',{className:'qa-btn',style:{marginTop:'10px',marginLeft:'8px'},onClick:()=>{state.dtPath=[];render();}},[h('span',{className:'qa-icon'},'🔄'),'Start over']),
      ]):
      h('div',{className:'dt-node'},[
        h('div',{className:'dt-question'},currentNode.q),
        h('div',{className:'dt-options'},currentNode.opts.map(opt=>
          h('div',{className:'dt-option',onClick:()=>{state.dtPath.push(opt.next);render();}},[
            h('span',{className:'dt-arrow'},'→'),opt.label
          ])
        )),
      ]),
    // Show path breadcrumb
    path.length>0?h('div',{style:{marginTop:'16px',fontSize:'11px',color:'var(--text3)',fontFamily:'var(--font-mono)'}},'Path: '+path.map(p=>{const n=DECISION_TREE.find(x=>x.id===p);return n?(n.result||'...'):p;}).join(' → ')):null,
  ]);
}

// ====== RENDER: REVIEW QUEUE ======
function renderReviewQueue(){
  const review=getReviewQueue();
  const now=Date.now();
  return h('div',{className:'fade-in'},[
    h('button',{className:'back-btn',onClick:()=>{state.view='dashboard';render();window.scrollTo(0,0);}},'← Dashboard'),
    h('div',{className:'section-header'},[
      h('h2',null,'🔄 Review Queue'),
      h('p',null,'Problems you solved 3+ days ago. Re-solve to strengthen memory.'),
    ]),
    review.length===0?h('div',{className:'empty'},'No problems ready for review yet. Solve some problems and come back in a few days!'):
    h('div',null,review.map(p=>{
      const daysSince=Math.floor((now-(state.completedAt[p.topicId+':'+p.id]||0))/86400000);
      return h('div',null,[
        h('div',{className:'problem-row',onClick:()=>{
          const k=p.topicId+':'+p.id;
          if(state.openProblems.has(k))state.openProblems.delete(k);else state.openProblems.add(k);render();
        }},[
          h('span',{className:'problem-num'},'#'+p.num),
          h('span',{className:'problem-title'},p.title),
          h('span',{style:{font:'500 10px/1 var(--font-mono)',color:'var(--text3)'}},daysSince+'d ago'),
          h('span',{className:'problem-diff diff-'+p.difficulty},p.difficulty),
          h('a',{href:p.url,target:'_blank',rel:'noopener',style:{color:'var(--text3)',fontSize:'11px',textDecoration:'none'},onClick:e=>e.stopPropagation()},'↗'),
          h('button',{className:'qa-btn',style:{padding:'3px 8px',fontSize:'10px',marginLeft:'4px'},onClick:e=>{e.stopPropagation();state.completedAt[p.topicId+':'+p.id]=Date.now();saveProgress();render();toast('Marked as re-reviewed ✓');}},'Re-reviewed'),
        ]),
        state.openProblems.has(p.topicId+':'+p.id)&&p.note?h('div',{className:'problem-note'},p.note):null,
      ]);
    })),
  ]);
}

// ====== RENDER: TOPIC ======
function renderTopicView(){
  const tid=state.topic;const topic=TOPICS.find(t=>t.id===tid);
  if(!topic)return h('div',null,'Not found');
  const prog=getTopicProgress(tid);
  return h('div',{className:'fade-in'},[
    h('button',{className:'back-btn',onClick:()=>{state.view='dashboard';state.search='';render();window.scrollTo(0,0);}},'← All Topics'),
    h('div',{className:'section-header'},[h('h2',null,topic.icon+' '+topic.name),h('p',null,prog.done+'/'+prog.total+' ('+prog.pct+'%)')]),
    h('div',{className:'sub-nav'},[
      h('button',{className:'sub-btn'+(state.subView==='problems'?' active':''),onClick:()=>{state.subView='problems';render();}},'📋 Problems ('+prog.total+')'),
      h('button',{className:'sub-btn'+(state.subView==='guide'?' active':''),onClick:()=>{state.subView='guide';render();}},'📖 Study Guide'),
    ]),
    state.subView==='problems'?renderProblems(tid):renderGuide(tid),
  ]);
}

function renderProblems(tid){
  const tiers=PROBLEMS[tid]||[];
  const diffs=['All','Easy','Medium','Hard'];
  let filtered=tiers.map(t=>({...t,problems:t.problems.filter(p=>{
    if(state.diffFilter!=='All'&&p.difficulty!==state.diffFilter)return false;
    if(state.blind75Only&&!BLIND75.has(p.num))return false;
    if(state.search){const q=state.search.toLowerCase();return p.title.toLowerCase().includes(q)||(p.note||'').toLowerCase().includes(q)||(p.patterns||[]).some(x=>x.toLowerCase().includes(q));}
    return true;
  })}));
  const totalF=filtered.reduce((s,t)=>s+t.problems.length,0);
  return h('div',null,[
    h('div',{className:'search-wrap'},[
      h('span',{className:'search-icon'},'⌕'),
      h('input',{className:'search-input',placeholder:'Search problems...',value:state.search,onInput:e=>{state.search=e.target.value;render();}}),
      h('span',{className:'search-count'},totalF+' problems'),
    ]),
    h('div',{className:'filter-bar'},[
      h('span',{className:'filter-label'},'Difficulty'),
      ...diffs.map(d=>h('button',{className:'filter-btn'+(state.diffFilter===d?' active':''),onClick:()=>{state.diffFilter=d;render();}},d)),
      h('button',{className:'filter-btn'+(state.blind75Only?' active':''),style:state.blind75Only?{background:'var(--cyan-bg)',borderColor:'rgba(74,201,176,0.2)',color:'var(--cyan)'}:{},onClick:()=>{state.blind75Only=!state.blind75Only;render();}},'Blind 75'),
      h('button',{className:'reset-btn',style:{marginLeft:'auto'},onClick:()=>{if(confirm('Reset progress?')){tiers.forEach(t=>t.problems.forEach(p=>{delete state.completed[tid+':'+p.id];delete state.completedAt[tid+':'+p.id];}));saveProgress();render();}}},'Reset'),
    ]),
    ...filtered.map((tier,ti)=>{
      if(tier.problems.length===0)return null;
      const isOpen=state.openTiers.has(String(ti));
      return h('div',{className:'tier-section'},[
        h('div',{className:'tier-header',onClick:()=>{if(isOpen)state.openTiers.delete(String(ti));else state.openTiers.add(String(ti));render();}},[
          h('div',{className:'tier-dot',style:{background:tier.color}}),
          h('div',{className:'tier-name'},tier.name),
          h('div',{className:'tier-count'},tier.problems.length),
          h('span',{className:'card-toggle'+(isOpen?' open':''),style:{marginLeft:'6px'}},'▼'),
        ]),
        isOpen?h('div',null,[
          h('div',{className:'tier-desc'},tier.description),
          ...tier.problems.map(p=>renderProblemRow(tid,p)),
        ]):null,
      ]);
    }).filter(Boolean),
  ]);
}

function renderProblemRow(tid,p){
  const k=tid+':'+p.id;const done=!!state.completed[k];const isOpen=state.openProblems.has(k);
  const isBlind=BLIND75.has(p.num);
  const hintKey=k;const hintsRevealed=state.hintLevels[hintKey]||0;
  // Split note into progressive hints
  const noteText=p.note||'';
  const hints=noteText.split(/\.\s+/).filter(Boolean).map(s=>s.trim().replace(/\.$/,''));
  
  return h('div',null,[
    h('div',{className:'problem-row'+(done?' completed':''),onClick:e=>{if(e.target.closest('.problem-check'))return;if(isOpen)state.openProblems.delete(k);else state.openProblems.add(k);render();}},[
      h('div',{className:'problem-check'+(done?' checked':''),onClick:e=>{e.stopPropagation();toggleComplete(tid,p.id);}}),
      h('span',{className:'problem-num'},'#'+p.num),
      h('span',{className:'problem-title'},p.title),
      isBlind?h('span',{className:'problem-blind75'},'B75'):null,
      h('div',{className:'problem-patterns'},(p.patterns||[]).slice(0,3).map(x=>h('span',{className:'problem-pattern'},x))),
      h('span',{className:'problem-diff diff-'+p.difficulty},p.difficulty),
      h('a',{href:p.url,target:'_blank',rel:'noopener',style:{color:'var(--text3)',fontSize:'11px',textDecoration:'none',marginLeft:'2px'},onClick:e=>e.stopPropagation()},'↗'),
    ]),
    isOpen?h('div',{className:'hint-steps'},[
      ...hints.map((hint,i)=>
        h('div',{className:'hint-step'+(i<hintsRevealed?' revealed':' hidden'),onClick:()=>{if(i<hintsRevealed)return;state.hintLevels[hintKey]=i+1;render();}},[
          h('span',{className:'hint-num'},'H'+(i+1)),
          h('span',null,hint),
        ])
      ),
      hintsRevealed<hints.length?h('button',{className:'reveal-btn',onClick:()=>{state.hintLevels[hintKey]=(hintsRevealed||0)+1;render();}},'Reveal next hint ('+(hintsRevealed+1)+'/'+hints.length+')'):
      h('span',{style:{font:'500 10px/1 var(--font-mono)',color:'var(--green)',marginTop:'4px',display:'inline-block'}},'✓ All hints revealed'),
    ]):null,
  ]);
}

// ====== RENDER: GUIDE ======
function renderGuide(tid){
  const guide=GUIDES[tid];
  if(!guide)return h('div',{className:'empty'},'Coming soon');
  return h('div',null,guide.patterns.map((pat,pi)=>
    h('div',{style:{marginBottom:'24px'}},[
      h('div',{style:{marginBottom:'12px'}},[
        h('div',{style:{font:'500 11px/1 var(--font-mono)',color:'var(--accent)',textTransform:'uppercase',letterSpacing:'1.5px',marginBottom:'6px'}},'Section '+(pi+1)),
        pat.overview?h('p',{style:{fontSize:'13px',color:'var(--text2)',lineHeight:'1.7'}},pat.overview):null,
      ]),
      ...pat.variants.map((v,vi)=>renderVariantCard(v,tid,pi,vi)),
    ])
  ));
}

function renderVariantCard(v,tid,pi,vi){
  const ck=tid+':'+pi+':'+vi;const isOpen=state.openCards.has(ck);
  return h('div',{className:'card'},[
    h('div',{className:'card-header',onClick:()=>{if(isOpen)state.openCards.delete(ck);else state.openCards.add(ck);render();}},[
      h('h3',null,v.name),h('span',{className:'card-toggle'+(isOpen?' open':'')},'▼'),
    ]),
    isOpen?h('div',{className:'card-body'},[
      h('p',null,v.description),
      v.when?h('div',{className:'variant-when'},'When: '+v.when):null,
      v.template?h('div',null,[
        h('div',{className:'collapsible-trigger',onClick:e=>{const code=e.target.closest('.card-body').querySelector('.code-block');if(code)code.style.display=code.style.display==='none'?'block':'none';}},[h('span',null,'▶'),h('span',null,' Code Template')]),
        h('div',{className:'code-block',style:{display:'none'},innerHTML:hlCode(v.template)}),
      ]):null,
      v.problems&&v.problems.length>0?h('div',{style:{marginTop:'8px'}},[
        h('div',{style:{font:'600 10px/1 var(--font-mono)',color:'var(--accent)',textTransform:'uppercase',letterSpacing:'1px',marginBottom:'6px'}},'Practice Problems'),
        ...v.problems.map(p=>h('div',{className:'variant-problem'},[
          h('b',null,p.name),p.hint?h('span',{className:'variant-hint'},' — '+p.hint):null,
        ])),
      ]):null,
    ]):null,
  ]);
}

// ====== RENDER: SEARCH ======
function renderSearchView(){
  const q=state.search.toLowerCase();let results=[];
  Object.entries(PROBLEMS).forEach(([tid,tiers])=>{tiers.forEach(t=>{t.problems.forEach(p=>{
    if(p.title.toLowerCase().includes(q)||(p.note||'').toLowerCase().includes(q)||(p.patterns||[]).some(x=>x.toLowerCase().includes(q)))
      results.push({...p,topicId:tid,tierName:t.name,tierColor:t.color});
  });});});
  return h('div',{className:'fade-in'},[
    h('button',{className:'back-btn',onClick:()=>{state.view='dashboard';state.search='';render();window.scrollTo(0,0);}},'← Dashboard'),
    h('div',{className:'section-header'},[h('h2',null,'Search Results'),h('p',null,results.length+' found')]),
    h('div',{className:'search-wrap'},[
      h('span',{className:'search-icon'},'⌕'),
      h('input',{className:'search-input',placeholder:'Search...',value:state.search,onInput:e=>{state.search=e.target.value;render();}}),
    ]),
    ...results.slice(0,50).map(p=>renderProblemRow(p.topicId,p)),
    results.length===0?h('div',{className:'empty'},'No results'):null,
  ]);
}

// ====== FORMULA SHEET DATA ======
const FORMULAS = [
{cat:"Bit Manipulation",items:[
{name:"Swap without temp",code:"a = a ^ b;\nb = a ^ b;\na = a ^ b;",use:"Swap two integers in-place. Also: a ^= b; b ^= a; a ^= b;",tc:"O(1)"},
{name:"Check if power of 2",code:"boolean isPow2 = (n > 0) && (n & (n - 1)) == 0;",use:"Powers of 2 have exactly one bit set. n & (n-1) clears lowest set bit.",tc:"O(1)"},
{name:"Get / Set / Clear bit",code:"// Get bit at position i\nint bit = (n >> i) & 1;\n// Set bit at position i\nn = n | (1 << i);\n// Clear bit at position i\nn = n & ~(1 << i);\n// Toggle bit at position i\nn = n ^ (1 << i);",use:"Fundamental bitwise operations. Used in bitmask DP, subset enumeration.",tc:"O(1)"},
{name:"Count set bits (Brian Kernighan)",code:"int count = 0;\nwhile (n != 0) {\n    n = n & (n - 1); // clears lowest set bit\n    count++;\n}\n// Or: Integer.bitCount(n)",use:"Count 1-bits. n & (n-1) removes one set bit each iteration. Runs in O(setBits) not O(32).",tc:"O(k) k=set bits"},
{name:"Lowest set bit",code:"int lowest = n & (-n);  // isolates rightmost 1-bit",use:"Useful in Fenwick tree (BIT). -n is two's complement, flips all bits after rightmost 1.",tc:"O(1)"},
{name:"XOR tricks",code:"// Find single number (all others appear twice)\nint single = 0;\nfor (int x : nums) single ^= x;\n\n// a ^ a = 0, a ^ 0 = a\n// XOR is commutative + associative",use:"XOR cancels duplicates. Single Number (#136). Two missing: split by any differing bit.",tc:"O(n)"},
{name:"Multiply / Divide by 2",code:"n << 1   // multiply by 2\nn >> 1   // divide by 2 (floor)\nn << k   // multiply by 2^k",use:"Faster than arithmetic. Useful in binary search: mid = lo + ((hi - lo) >> 1);",tc:"O(1)"},
{name:"Check odd/even",code:"boolean isOdd = (n & 1) == 1;\nboolean isEven = (n & 1) == 0;",use:"Last bit determines parity. Faster than n % 2.",tc:"O(1)"},
{name:"Enumerate all subsets of a bitmask",code:"// All subsets of mask (including empty)\nfor (int sub = mask; sub > 0; sub = (sub - 1) & mask) {\n    // process sub\n}\n// Don't forget to handle sub = 0 (empty set)",use:"Bitmask DP — iterate all subsets of a given set. Total across all masks: O(3^n).",tc:"O(2^popcount)"},
{name:"Two's complement / negative numbers",code:"// -n == ~n + 1\n// Integer.MIN_VALUE: -2^31 = -2147483648\n// Integer.MAX_VALUE:  2^31-1 = 2147483647\n// Math.abs(Integer.MIN_VALUE) OVERFLOWS!",use:"Watch for overflow: -Integer.MIN_VALUE == Integer.MIN_VALUE. Use long for safety.",tc:"O(1)"},
]},
{cat:"Math Tricks",items:[
{name:"Multiply without * operator",code:"int multiply(int a, int b) {\n    int result = 0;\n    while (b > 0) {\n        if ((b & 1) == 1) result += a;\n        a <<= 1;\n        b >>= 1;\n    }\n    return result;\n}",use:"Russian peasant multiplication. Shift and add. Handle negatives separately.",tc:"O(log b)"},
{name:"GCD (Euclidean algorithm)",code:"int gcd(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n// LCM = (a / gcd(a,b)) * b  (divide first to avoid overflow)",use:"Greatest common divisor. LCM via GCD. Used in fraction problems, cycle detection.",tc:"O(log(min(a,b)))"},
{name:"Modular arithmetic",code:"(a + b) % m = ((a % m) + (b % m)) % m\n(a * b) % m = ((a % m) * (b % m)) % m\n(a - b) % m = ((a % m) - (b % m) + m) % m  // +m for negative\n\n// Modular exponentiation (fast power)\nlong power(long base, long exp, long mod) {\n    long result = 1;\n    base %= mod;\n    while (exp > 0) {\n        if ((exp & 1) == 1) result = result * base % mod;\n        exp >>= 1;\n        base = base * base % mod;\n    }\n    return result;\n}",use:"MOD = 1_000_000_007. Always mod after each operation. Fast power: O(log n).",tc:"O(log n)"},
{name:"Sum formulas",code:"// Sum 1 to n\nint sum = n * (n + 1) / 2;\n\n// Sum of squares\nint sumSq = n * (n + 1) * (2 * n + 1) / 6;\n\n// Arithmetic series: n terms, first a, last l\nint sum = n * (a + l) / 2;\n\n// Geometric series: a + ar + ar² + ... + ar^(n-1)\n// sum = a * (r^n - 1) / (r - 1)",use:"Missing number = expected sum - actual sum. Gauss formula everywhere.",tc:"O(1)"},
{name:"Combinatorics (nCr)",code:"// Pascal's triangle approach (avoid overflow)\nlong[][] dp = new long[n+1][n+1];\nfor (int i = 0; i <= n; i++) {\n    dp[i][0] = 1;\n    for (int j = 1; j <= i; j++)\n        dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\n}\n// dp[n][r] = C(n, r)\n\n// Unique Paths: C(m+n-2, m-1)",use:"Catalan numbers: C(n) = C(2n,n)/(n+1). Valid parentheses, BST count. Unique paths = combinatorics.",tc:"O(n²)"},
{name:"Check prime / Sieve of Eratosthenes",code:"// Check prime\nboolean isPrime(int n) {\n    if (n < 2) return false;\n    for (int i = 2; i * i <= n; i++)\n        if (n % i == 0) return false;\n    return true;\n}\n// Sieve up to n\nboolean[] sieve = new boolean[n + 1];\nArrays.fill(sieve, true);\nsieve[0] = sieve[1] = false;\nfor (int i = 2; i * i <= n; i++)\n    if (sieve[i])\n        for (int j = i * i; j <= n; j += i)\n            sieve[j] = false;",use:"Check up to √n. Sieve for bulk prime queries. Count primes (#204).",tc:"O(√n) / O(n log log n)"},
{name:"Integer overflow prevention",code:"// Check before multiplying\nif (a != 0 && b > Integer.MAX_VALUE / a) // overflow!\n\n// Safe mid calculation\nint mid = lo + (hi - lo) / 2; // NOT (lo + hi) / 2\n\n// Use long for intermediate results\nlong product = (long) a * b;\n\n// Reverse integer: check before *10\nif (rev > Integer.MAX_VALUE / 10) return 0;",use:"ALWAYS think about overflow in: reverse integer, multiply strings, atoi, sum problems.",tc:"O(1)"},
{name:"Random selection (Reservoir sampling)",code:"// Pick random element from stream of unknown size\nint result = 0, count = 0;\nfor (int x : stream) {\n    count++;\n    if (rand.nextInt(count) == 0)\n        result = x;\n}",use:"Linked List Random Node (#382). Equal probability 1/n for each element.",tc:"O(n)"},
]},
{cat:"Array Tricks",items:[
{name:"Rotate array left by k",code:"// Left rotate by k positions\nvoid rotateLeft(int[] a, int k) {\n    int n = a.length;\n    k %= n;\n    reverse(a, 0, k - 1);\n    reverse(a, k, n - 1);\n    reverse(a, 0, n - 1);\n}",use:"Three reverses trick. Right rotate: reverse whole, reverse first k, reverse rest. O(1) space!",tc:"O(n)"},
{name:"Rotate array right by k",code:"void rotateRight(int[] a, int k) {\n    int n = a.length;\n    k %= n;\n    reverse(a, 0, n - 1);     // reverse all\n    reverse(a, 0, k - 1);     // reverse first k\n    reverse(a, k, n - 1);     // reverse rest\n}",use:"Rotate Array (#189). Remember: k %= n to handle k > n.",tc:"O(n)"},
{name:"Reverse a subarray",code:"void reverse(int[] a, int lo, int hi) {\n    while (lo < hi) {\n        int temp = a[lo];\n        a[lo++] = a[hi];\n        a[hi--] = temp;\n    }\n}",use:"Building block for rotation, palindrome, next permutation. In-place O(1) space.",tc:"O(n)"},
{name:"Dutch National Flag (3-way partition)",code:"int lo = 0, mid = 0, hi = n - 1;\nwhile (mid <= hi) {\n    if (a[mid] == 0) swap(a, lo++, mid++);\n    else if (a[mid] == 1) mid++;\n    else swap(a, mid, hi--);\n}",use:"Sort Colors (#75). Partition into three groups in one pass. 3 pointers: lo, mid, hi.",tc:"O(n)"},
{name:"Kadane's algorithm",code:"int maxHere = nums[0], maxSoFar = nums[0];\nfor (int i = 1; i < n; i++) {\n    maxHere = Math.max(nums[i], maxHere + nums[i]);\n    maxSoFar = Math.max(maxSoFar, maxHere);\n}",use:"Maximum subarray (#53). At each index: extend or restart. For max product: track both min and max.",tc:"O(n)"},
{name:"Next permutation",code:"// 1. Find largest i where a[i] < a[i+1] (rightmost ascent)\n// 2. Find largest j > i where a[j] > a[i]\n// 3. Swap a[i] and a[j]\n// 4. Reverse a[i+1 .. end]\nint i = n - 2;\nwhile (i >= 0 && nums[i] >= nums[i + 1]) i--;\nif (i >= 0) {\n    int j = n - 1;\n    while (nums[j] <= nums[i]) j--;\n    swap(nums, i, j);\n}\nreverse(nums, i + 1, n - 1);",use:"Next Permutation (#31). If no ascent found (fully descending), reverse all = smallest permutation.",tc:"O(n)"},
{name:"Boyer-Moore Voting",code:"int candidate = 0, count = 0;\nfor (int num : nums) {\n    if (count == 0) candidate = num;\n    count += (num == candidate) ? 1 : -1;\n}\n// candidate is majority element (verify if needed)",use:"Majority Element (#169). Finds element appearing > n/2 times. O(1) space. For > n/3: track two candidates.",tc:"O(n)"},
{name:"Prefix Sum / Difference Array",code:"// Build prefix sum\nint[] prefix = new int[n + 1];\nfor (int i = 0; i < n; i++)\n    prefix[i + 1] = prefix[i] + nums[i];\n// Range sum [l, r] = prefix[r+1] - prefix[l]\n\n// Difference array: range update [l,r] += val\ndiff[l] += val;\nif (r + 1 < n) diff[r + 1] -= val;\n// Reconstruct: prefix sum of diff",use:"Range sum O(1) query. Difference array: O(1) range updates, O(n) rebuild. Car Pooling, Flight Bookings.",tc:"O(n) build, O(1) query"},
{name:"Two pointers: Remove duplicates in-place",code:"int slow = 0;\nfor (int fast = 0; fast < n; fast++) {\n    if (fast == 0 || nums[fast] != nums[fast - 1]) {\n        nums[slow++] = nums[fast];\n    }\n}\nreturn slow; // new length",use:"Remove Duplicates (#26). Slow pointer tracks write position. Works for sorted arrays.",tc:"O(n)"},
{name:"Product of Array Except Self",code:"int[] res = new int[n];\nres[0] = 1;\nfor (int i = 1; i < n; i++)\n    res[i] = res[i-1] * nums[i-1]; // left products\nint right = 1;\nfor (int i = n - 2; i >= 0; i--) {\n    right *= nums[i + 1];\n    res[i] *= right;                // multiply right products\n}",use:"Product Except Self (#238). No division. Left prefix product × right suffix product.",tc:"O(n), O(1) extra"},
{name:"Trapping Rain Water",code:"int left = 0, right = n-1, leftMax = 0, rightMax = 0, water = 0;\nwhile (left < right) {\n    if (height[left] < height[right]) {\n        leftMax = Math.max(leftMax, height[left]);\n        water += leftMax - height[left++];\n    } else {\n        rightMax = Math.max(rightMax, height[right]);\n        water += rightMax - height[right--];\n    }\n}",use:"Trapping Rain Water (#42). Two pointers from ends. Water at each position = min(leftMax, rightMax) - height.",tc:"O(n), O(1) space"},
]},
{cat:"String Tricks",items:[
{name:"Check anagram",code:"int[] freq = new int[26];\nfor (char c : s.toCharArray()) freq[c - 'a']++;\nfor (char c : t.toCharArray()) freq[c - 'a']--;\nfor (int f : freq) if (f != 0) return false;\nreturn true;",use:"int[26] beats HashMap for lowercase. Increment s, decrement t, check all zeros.",tc:"O(n)"},
{name:"Reverse string in-place",code:"char[] arr = s.toCharArray();\nint l = 0, r = arr.length - 1;\nwhile (l < r) {\n    char tmp = arr[l];\n    arr[l++] = arr[r];\n    arr[r--] = tmp;\n}",use:"Reverse String (#344). Two pointers swap from ends. Also works for reversing words.",tc:"O(n)"},
{name:"Reverse words in a string",code:"// 1. Reverse entire string\n// 2. Reverse each word\n// 3. Clean up extra spaces",use:"Reverse Words (#151). Reverse-reverse trick. Or split + reverse + join.",tc:"O(n)"},
{name:"String to integer (atoi)",code:"int sign = 1, i = 0, result = 0;\nwhile (i < s.length() && s.charAt(i) == ' ') i++;\nif (i < s.length() && (s.charAt(i) == '+' || s.charAt(i) == '-'))\n    sign = s.charAt(i++) == '-' ? -1 : 1;\nwhile (i < s.length() && Character.isDigit(s.charAt(i))) {\n    int digit = s.charAt(i++) - '0';\n    if (result > (Integer.MAX_VALUE - digit) / 10)\n        return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n    result = result * 10 + digit;\n}",use:"String to Integer (#8). Handle: spaces, sign, overflow, non-digit characters.",tc:"O(n)"},
{name:"KMP failure function (LPS array)",code:"int[] lps = new int[pattern.length()];\nint len = 0, i = 1;\nwhile (i < pattern.length()) {\n    if (pattern.charAt(i) == pattern.charAt(len)) {\n        lps[i++] = ++len;\n    } else if (len > 0) {\n        len = lps[len - 1]; // don't increment i\n    } else {\n        lps[i++] = 0;\n    }\n}",use:"Pattern matching in O(n+m). Repeated Substring Pattern: if n % (n-lps[n-1]) == 0 → repeating.",tc:"O(n+m)"},
{name:"Palindrome check shortcuts",code:"// Two pointer\nboolean isPalin(String s, int l, int r) {\n    while (l < r)\n        if (s.charAt(l++) != s.charAt(r--)) return false;\n    return true;\n}\n// Expand around center (find longest)\nint expandFromCenter(String s, int l, int r) {\n    while (l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {\n        l--; r++;\n    }\n    return r - l - 1;\n}",use:"Longest Palindromic Substring (#5): expand from each center (2n-1 centers). Valid Palindrome: skip non-alphanumeric.",tc:"O(n²) / O(n)"},
{name:"StringBuilder vs String concatenation",code:"// BAD: O(n²) — creates new string each time\nString s = \"\";\nfor (int i = 0; i < n; i++) s += \"x\";\n\n// GOOD: O(n) — amortized resizing\nStringBuilder sb = new StringBuilder();\nfor (int i = 0; i < n; i++) sb.append(\"x\");\nString s = sb.toString();",use:"ALWAYS use StringBuilder in loops. String is immutable in Java → concatenation creates copies.",tc:"O(n) vs O(n²)"},
]},
{cat:"LinkedList Tricks",items:[
{name:"Reverse a linked list",code:"ListNode prev = null, curr = head;\nwhile (curr != null) {\n    ListNode next = curr.next;\n    curr.next = prev;\n    prev = curr;\n    curr = next;\n}\nreturn prev; // new head",use:"THE most important LL operation. Practice until instant. Used in palindrome, reorder, k-group reverse.",tc:"O(n)"},
{name:"Find middle (fast/slow)",code:"ListNode slow = head, fast = head;\nwhile (fast != null && fast.next != null) {\n    slow = slow.next;\n    fast = fast.next.next;\n}\nreturn slow; // middle (2nd middle for even)",use:"Middle of Linked List (#876). For split (merge sort), use fast.next.next != null to get 1st middle.",tc:"O(n)"},
{name:"Detect cycle + find entry",code:"// Phase 1: Detect\nListNode slow = head, fast = head;\nwhile (fast != null && fast.next != null) {\n    slow = slow.next;\n    fast = fast.next.next;\n    if (slow == fast) break;\n}\n// Phase 2: Find entry\nListNode entry = head;\nwhile (entry != slow) {\n    entry = entry.next;\n    slow = slow.next;\n}\nreturn entry;",use:"Floyd's cycle detection. Phase 2 math: distance head→entry = distance meetingPoint→entry.",tc:"O(n)"},
{name:"Dummy head pattern",code:"ListNode dummy = new ListNode(0);\ndummy.next = head;\nListNode prev = dummy;\n// ... modify list ...\nreturn dummy.next; // NOT head",use:"Eliminates edge cases when head might be removed. Use by DEFAULT for merge, remove, partition.",tc:"O(1) overhead"},
{name:"Nth from end (gap technique)",code:"ListNode fast = dummy, slow = dummy;\nfor (int i = 0; i <= n; i++) fast = fast.next;\nwhile (fast != null) {\n    fast = fast.next;\n    slow = slow.next;\n}\nslow.next = slow.next.next; // remove nth from end",use:"Remove Nth From End (#19). Fast leads by n+1 (with dummy). One pass.",tc:"O(n)"},
]},
{cat:"Tree Tricks",items:[
{name:"Max depth / height",code:"int maxDepth(TreeNode root) {\n    if (root == null) return 0;\n    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n}",use:"Foundation for balanced check, diameter, many tree problems. Base case: null → 0.",tc:"O(n)"},
{name:"Diameter of binary tree",code:"int maxDiam = 0;\nint height(TreeNode node) {\n    if (node == null) return 0;\n    int l = height(node.left), r = height(node.right);\n    maxDiam = Math.max(maxDiam, l + r);\n    return 1 + Math.max(l, r);\n}",use:"Diameter = longest path between any two nodes. At each node: l + r is path THROUGH that node.",tc:"O(n)"},
{name:"LCA (Lowest Common Ancestor)",code:"TreeNode lca(TreeNode root, TreeNode p, TreeNode q) {\n    if (root == null || root == p || root == q) return root;\n    TreeNode l = lca(root.left, p, q);\n    TreeNode r = lca(root.right, p, q);\n    if (l != null && r != null) return root; // split\n    return l != null ? l : r;\n}",use:"LCA (#236). If found in both subtrees → current is LCA. For BST: go left if both < root, right if both >.",tc:"O(n)"},
{name:"Validate BST with bounds",code:"boolean valid(TreeNode n, long min, long max) {\n    if (n == null) return true;\n    if (n.val <= min || n.val >= max) return false;\n    return valid(n.left, min, n.val)\n        && valid(n.right, n.val, max);\n}",use:"Use Long.MIN/MAX to avoid edge cases. Or: inorder traversal must be strictly increasing.",tc:"O(n)"},
{name:"Serialize / Deserialize",code:"// Serialize: preorder with # for null\nvoid ser(TreeNode n, StringBuilder sb) {\n    if (n == null) { sb.append(\"#,\"); return; }\n    sb.append(n.val).append(\",\");\n    ser(n.left, sb);\n    ser(n.right, sb);\n}",use:"Serialize & Deserialize (#297). Preorder + null markers = unique tree. Deserialize with index pointer.",tc:"O(n)"},
{name:"Build tree from traversals",code:"// Preorder[0] = root\n// Find root in inorder → left and right subtree sizes\n// Recurse: left = inorder[0..idx-1], right = inorder[idx+1..end]\n// Use HashMap for O(1) inorder index lookup",use:"Build Tree from Preorder & Inorder (#105). Key: inorder splits left/right, preorder gives root order.",tc:"O(n)"},
{name:"Morris Traversal (O(1) space inorder)",code:"TreeNode curr = root;\nwhile (curr != null) {\n    if (curr.left == null) {\n        visit(curr);\n        curr = curr.right;\n    } else {\n        TreeNode pred = curr.left;\n        while (pred.right != null && pred.right != curr)\n            pred = pred.right;\n        if (pred.right == null) {\n            pred.right = curr; // thread\n            curr = curr.left;\n        } else {\n            pred.right = null; // restore\n            visit(curr);\n            curr = curr.right;\n        }\n    }\n}",use:"Inorder traversal with O(1) space. Uses threaded binary tree. Recover BST (#99) can use this.",tc:"O(n) time, O(1) space"},
]},
{cat:"Graph Tricks",items:[
{name:"BFS shortest path template",code:"Queue<int[]> queue = new ArrayDeque<>();\nboolean[][] visited = new boolean[m][n];\nint[][] dirs = {{0,1},{0,-1},{1,0},{-1,0}};\nqueue.offer(new int[]{sr, sc});\nvisited[sr][sc] = true;\nint steps = 0;\nwhile (!queue.isEmpty()) {\n    int size = queue.size();\n    for (int i = 0; i < size; i++) {\n        int[] cell = queue.poll();\n        if (cell[0] == tr && cell[1] == tc) return steps;\n        for (int[] d : dirs) {\n            int nr = cell[0]+d[0], nc = cell[1]+d[1];\n            if (nr>=0 && nr<m && nc>=0 && nc<n && !visited[nr][nc]) {\n                visited[nr][nc] = true;\n                queue.offer(new int[]{nr, nc});\n            }\n        }\n    }\n    steps++;\n}",use:"Shortest path in unweighted grid. Level-by-level = distance. Mark visited BEFORE enqueueing.",tc:"O(V+E)"},
{name:"Topological sort (Kahn's BFS)",code:"int[] indegree = new int[n];\nfor (int[] e : edges) indegree[e[1]]++;\nQueue<Integer> q = new ArrayDeque<>();\nfor (int i = 0; i < n; i++)\n    if (indegree[i] == 0) q.offer(i);\nList<Integer> order = new ArrayList<>();\nwhile (!q.isEmpty()) {\n    int u = q.poll();\n    order.add(u);\n    for (int v : adj.get(u))\n        if (--indegree[v] == 0) q.offer(v);\n}\n// if order.size() < n → cycle exists!",use:"Course Schedule (#207, #210). If processed < total → cycle exists. Works for DAGs only.",tc:"O(V+E)"},
{name:"Union-Find template",code:"int[] parent, rank;\nvoid init(int n) {\n    parent = new int[n]; rank = new int[n];\n    for (int i = 0; i < n; i++) parent[i] = i;\n}\nint find(int x) {\n    if (parent[x] != x) parent[x] = find(parent[x]); // path compression\n    return parent[x];\n}\nboolean union(int x, int y) {\n    int px = find(x), py = find(y);\n    if (px == py) return false;\n    if (rank[px] < rank[py]) { int t=px; px=py; py=t; }\n    parent[py] = px;\n    if (rank[px] == rank[py]) rank[px]++;\n    return true;\n}",use:"Near O(1) find/union. Count components, detect cycles, accounts merge, redundant connection.",tc:"O(α(n)) ≈ O(1)"},
{name:"Dijkstra's template",code:"int[] dist = new int[n];\nArrays.fill(dist, Integer.MAX_VALUE);\ndist[src] = 0;\n// [distance, node]\nPriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->a[0]-b[0]);\npq.offer(new int[]{0, src});\nwhile (!pq.isEmpty()) {\n    int[] cur = pq.poll();\n    int d = cur[0], u = cur[1];\n    if (d > dist[u]) continue; // stale\n    for (int[] e : adj.get(u)) {\n        int v = e[0], w = e[1];\n        if (dist[u] + w < dist[v]) {\n            dist[v] = dist[u] + w;\n            pq.offer(new int[]{dist[v], v});\n        }\n    }\n}",use:"Shortest path in weighted graph. SKIP stale entries. Network Delay (#743), Min Effort (#1631).",tc:"O((V+E) log V)"},
{name:"Grid to graph: 2D → 1D index",code:"int index = row * numCols + col;\nint row = index / numCols;\nint col = index % numCols;\n\nint[][] dirs = {{0,1},{0,-1},{1,0},{-1,0}}; // 4-directional\nint[][] dirs8 = {{0,1},{0,-1},{1,0},{-1,0},{1,1},{1,-1},{-1,1},{-1,-1}}; // 8-directional",use:"Union-Find on grid, BFS/DFS on matrix. Always define dirs array for clean neighbor iteration.",tc:"O(1)"},
{name:"Number of islands pattern",code:"int count = 0;\nfor (int i = 0; i < m; i++)\n    for (int j = 0; j < n; j++)\n        if (grid[i][j] == '1') {\n            dfs(grid, i, j); // marks all connected as visited\n            count++;\n        }",use:"Count connected components in grid. DFS marks visited (set to '0'). BFS also works.",tc:"O(m×n)"},
]},
{cat:"DP Tricks",items:[
{name:"Fibonacci-style space optimization",code:"// Instead of dp[n] array:\nint prev2 = 0, prev1 = 1;\nfor (int i = 2; i <= n; i++) {\n    int curr = prev1 + prev2;\n    prev2 = prev1;\n    prev1 = curr;\n}",use:"Climbing Stairs, House Robber. If dp[i] only depends on dp[i-1] and dp[i-2], use 2 variables.",tc:"O(n) time, O(1) space"},
{name:"0/1 Knapsack 1D trick",code:"// Iterate capacity BACKWARDS for 0/1 knapsack\nint[] dp = new int[capacity + 1];\nfor (int i = 0; i < n; i++)\n    for (int w = capacity; w >= weight[i]; w--)\n        dp[w] = Math.max(dp[w], dp[w - weight[i]] + value[i]);",use:"Backwards = each item used at most once. Forwards = unbounded (can reuse). Critical difference!",tc:"O(n×W)"},
{name:"Coin change (unbounded) pattern",code:"int[] dp = new int[amount + 1];\nArrays.fill(dp, amount + 1); // infinity\ndp[0] = 0;\nfor (int i = 1; i <= amount; i++)\n    for (int coin : coins)\n        if (coin <= i)\n            dp[i] = Math.min(dp[i], dp[i - coin] + 1);",use:"Coin Change (#322). Forward iteration allows reuse. For counting combos (#518): loop coins outer, amount inner.",tc:"O(n×amount)"},
{name:"LCS template",code:"int[][] dp = new int[m+1][n+1];\nfor (int i = 1; i <= m; i++)\n    for (int j = 1; j <= n; j++)\n        if (s1.charAt(i-1) == s2.charAt(j-1))\n            dp[i][j] = dp[i-1][j-1] + 1;\n        else\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);",use:"Longest Common Subsequence (#1143). Match → diagonal+1. No match → max(top, left). Edit distance variant: add cost.",tc:"O(m×n)"},
{name:"Stock buy/sell state machine",code:"// State: hold (have stock) vs cash (no stock)\nint hold = -prices[0], cash = 0;\nfor (int i = 1; i < n; i++) {\n    hold = Math.max(hold, cash - prices[i]);     // buy\n    cash = Math.max(cash, hold + prices[i]);     // sell\n}\nreturn cash;\n// With cooldown: add 'rest' state\n// With fee: subtract fee on sell\n// With K transactions: dp[k][hold/cash]",use:"All stock problems reduce to state machines. Draw states + transitions first. Best Time series (#121-#309).",tc:"O(n) or O(nk)"},
{name:"Interval DP fill order",code:"// Fill by LENGTH, not by row\nfor (int len = 2; len <= n; len++)\n    for (int i = 0; i <= n - len; i++) {\n        int j = i + len - 1;\n        // dp[i][j] depends on dp[i+1][j], dp[i][j-1], dp[i+1][j-1]\n    }",use:"Palindrome problems, Burst Balloons, Matrix Chain. Fill diagonally or by increasing length.",tc:"O(n²) or O(n³)"},
]},
{cat:"Java Gotchas",items:[
{name:"int[] vs Integer[] for sorting with comparator",code:"// Can't use Comparator with int[] directly\nInteger[] arr = Arrays.stream(nums).boxed().toArray(Integer[]::new);\nArrays.sort(arr, (a, b) -> b - a); // descending\n\n// Or sort int[] ascending, then reverse\nArrays.sort(nums);\n// reverse manually or use two pointers",use:"Primitive arrays only sort ascending. Box to Integer[] for custom comparators. Or use PriorityQueue.",tc:"O(n log n)"},
{name:"HashMap key gotchas",code:"// int[] can't be HashMap key (uses reference equality)\n// Use: Arrays.toString(arr) or String key\n// Or: encode as \"i,j\" or \"row*n+col\"\n\nMap<String, Integer> map = new HashMap<>();\nmap.put(Arrays.toString(state), value);\n\n// For 2 values: key = a * BIG_NUMBER + b\n// For coordinates: key = row * 1000 + col (if col < 1000)",use:"Arrays use reference equality. Always convert to String or encode as single integer for HashMap keys.",tc:"O(1)"},
{name:"PriorityQueue is min-heap by default",code:"// Min-heap (default)\nPriorityQueue<Integer> minHeap = new PriorityQueue<>();\n\n// Max-heap\nPriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\n// Or: new PriorityQueue<>((a, b) -> b - a);\n\n// Custom: sort by second element\nPriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> a[1] - b[1]);",use:"ALWAYS remember: Java PQ = min-heap. For max-heap, reverse comparator. poll() = O(log n), peek() = O(1).",tc:"O(log n) per op"},
{name:"Deque as Stack/Queue (NOT Stack class)",code:"Deque<Integer> stack = new ArrayDeque<>();\nstack.push(x);    // addFirst\nstack.pop();       // removeFirst\nstack.peek();      // peekFirst\n\nQueue<Integer> queue = new ArrayDeque<>();\nqueue.offer(x);    // addLast\nqueue.poll();      // removeFirst\nqueue.peek();      // peekFirst",use:"NEVER use java.util.Stack (legacy, synchronized, slow). ArrayDeque for both stack AND queue.",tc:"O(1) per op"},
{name:"String comparison",code:"// WRONG: s1 == s2 (compares references)\n// RIGHT: s1.equals(s2) (compares content)\n\n// Character comparison is fine with ==\nchar a = 'x', b = 'x';\nif (a == b) // works!\n\n// Integer comparison: == works for -128 to 127 only!\nInteger a = 200, b = 200;\na == b;       // FALSE (different objects)\na.equals(b);  // TRUE",use:"== for primitives, .equals() for objects. Integer cache: -128 to 127. Always use equals() for Integer.",tc:"O(n)"},
{name:"Overflow: int vs long",code:"// int range: -2^31 to 2^31-1 (±2.1 billion)\n// long range: -2^63 to 2^63-1\n\n// DANGER: intermediate overflow\nint a = 100000, b = 100000;\nint wrong = a * b;        // OVERFLOW!\nlong right = (long) a * b; // cast BEFORE multiply\n\n// Sum of large array → use long\nlong sum = 0;\nfor (int x : nums) sum += x;",use:"ALWAYS think: can this multiply/sum overflow int? Use long for: sums, products, prefix sums, area calculations.",tc:"—"},
{name:"Collections utility methods",code:"Arrays.sort(arr);                    // sort array\nArrays.fill(arr, val);               // fill array\nArrays.copyOfRange(arr, from, to);   // copy slice\nCollections.reverse(list);           // reverse list\nCollections.swap(list, i, j);        // swap elements\nMath.max(a, b); Math.min(a, b);      // no ternary needed\nMath.abs(x);                         // absolute value\nCharacter.isLetterOrDigit(c);        // alphanumeric check\nCharacter.toLowerCase(c);            // case conversion",use:"Know these by heart. Saves time in interviews. Arrays.fill for DP initialization. Character methods for string problems.",tc:"various"},
{name:"Negative modulo fix",code:"// Java % can return negative!\n// -7 % 3 = -1 (not 2)\n\n// Fix: ((x % m) + m) % m\nint safeMod = ((x % m) + m) % m;\n\n// Used in: Subarray Sums Divisible by K\n// Continuous Subarray Sum, Group Shifted Strings",use:"CRITICAL for prefix sum remainder problems. Java modulo preserves sign of dividend. Always add +m.",tc:"O(1)"},
]},
];

// ====== RENDER: FORMULA SHEET ======
function renderFormulas(){
  const cats=FORMULAS.map(f=>f.cat);
  const allCats=['All',...cats];
  const filter=state.formulaFilter||'All';
  const searchQ=(state.formulaSearch||'').toLowerCase();
  const filtered=FORMULAS.filter(f=>filter==='All'||f.cat===filter).map(f=>({
    ...f,items:f.items.filter(item=>{
      if(!searchQ)return true;
      return item.name.toLowerCase().includes(searchQ)||item.code.toLowerCase().includes(searchQ)||item.use.toLowerCase().includes(searchQ);
    })
  })).filter(f=>f.items.length>0);
  const totalFormulas=filtered.reduce((s,f)=>s+f.items.length,0);
  
  return h('div',{className:'fade-in'},[
    h('button',{className:'back-btn',onClick:()=>{state.view='dashboard';render();window.scrollTo(0,0);}},'← Dashboard'),
    h('div',{className:'section-header'},[
      h('h2',null,'📐 Formula & Tricks Sheet'),
      h('p',null,'Instant-recall formulas, bit tricks, and code patterns that save you under pressure'),
    ]),
    // Search
    h('div',{className:'search-wrap'},[
      h('span',{className:'search-icon'},'⌕'),
      h('input',{className:'search-input',placeholder:'Search formulas... (e.g. "swap", "rotate", "overflow")',
        value:state.formulaSearch||'',onInput:e=>{state.formulaSearch=e.target.value;render();}}),
      h('span',{className:'search-count'},totalFormulas+' formulas'),
    ]),
    // Category filters
    h('div',{className:'filter-bar',style:{flexWrap:'wrap'}},[
      ...allCats.map(c=>h('button',{
        className:'filter-btn'+(filter===c?' active':''),
        onClick:()=>{state.formulaFilter=c;render();}
      },c==='All'?'All ('+FORMULAS.reduce((s,f)=>s+f.items.length,0)+')':c)),
    ]),
    // Formula sections
    ...filtered.map(section=>
      h('div',{style:{marginBottom:'28px'}},[
        h('div',{style:{font:'normal 18px/1.2 var(--font-display)',color:'var(--accent)',marginBottom:'12px',paddingBottom:'8px',borderBottom:'1px solid var(--accent-border)'}},section.cat),
        ...section.items.map((item,idx)=>{
          const ck='formula:'+section.cat+':'+idx;
          const isOpen=state.openCards.has(ck);
          return h('div',{className:'card'},[
            h('div',{className:'card-header',onClick:()=>{if(isOpen)state.openCards.delete(ck);else state.openCards.add(ck);render();}},[
              h('h3',null,item.name),
              h('div',{style:{display:'flex',alignItems:'center',gap:'8px'}},[
                item.tc?h('span',{className:'cb '+(item.tc.includes('1)')||item.tc.includes('(1)')?'cb-fast':item.tc.includes('log')?'cb-med':'cb-slow')},item.tc):null,
                h('span',{className:'card-toggle'+(isOpen?' open':'')},'▼'),
              ]),
            ]),
            isOpen?h('div',{className:'card-body',style:{paddingTop:'12px'}},[
              h('div',{className:'code-block',innerHTML:hlCode(item.code)}),
              h('div',{style:{fontSize:'13px',color:'var(--text2)',lineHeight:'1.7',marginTop:'8px',padding:'8px 10px',background:'var(--accent-bg)',borderRadius:'var(--radius-sm)',border:'1px solid var(--accent-border)'}},item.use),
            ]):null,
          ]);
        }),
      ])
    ),
    filtered.length===0?h('div',{className:'empty'},'No formulas found'):null,
  ]);
}

// ====== MAIN RENDER ======
function render(){
  const app=document.getElementById('app');const c=h('div',{className:'container'});
  // Timer bar
  if(state.timerActive){
    const m=Math.floor(state.timerSeconds/60);const s=state.timerSeconds%60;
    c.prepend(h('div',{style:{height:'44px'}}));// spacer
  }
  if(state.view==='dashboard')c.appendChild(renderDashboard());
  else if(state.view==='topic')c.appendChild(renderTopicView());
  else if(state.view==='search')c.appendChild(renderSearchView());
  else if(state.view==='decide')c.appendChild(renderDecisionTree());
  else if(state.view==='review')c.appendChild(renderReviewQueue());
  else if(state.view==='formulas')c.appendChild(renderFormulas());
  
  app.innerHTML='';
  // Timer
  if(state.timerActive){
    const m=Math.floor(state.timerSeconds/60);const s=state.timerSeconds%60;
    const pct=(state.timerSeconds/state.timerTotal*100);
    app.appendChild(h('div',{className:'timer-bar'},[
      h('span',{className:'timer-label'},'Interview Timer'),
      h('span',{id:'timer-display',className:'timer-display'},String(m).padStart(2,'0')+':'+String(s).padStart(2,'0')),
      h('button',{className:'timer-btn',onClick:()=>startTimer(20)},'20m'),
      h('button',{className:'timer-btn',onClick:()=>startTimer(30)},'30m'),
      h('button',{className:'timer-btn',onClick:()=>startTimer(45)},'45m'),
      h('button',{className:'timer-btn',style:{color:'var(--red)'},onClick:stopTimer},'Stop'),
    ]));
    app.appendChild(h('div',{id:'timer-progress',className:'timer-progress',style:{width:pct+'%'}}));
  }
  app.appendChild(c);
}

// Keyboard shortcuts
document.addEventListener('keydown',e=>{
  if(e.target.tagName==='INPUT')return;
  if(e.key==='Escape'){state.view='dashboard';state.search='';render();window.scrollTo(0,0);}
  if(e.key==='/'&&!e.ctrlKey){e.preventDefault();const inp=document.querySelector('.search-input');if(inp)inp.focus();}
  if(e.key==='t'&&!e.ctrlKey){if(!state.timerActive)startTimer(45);else stopTimer();}
  if(e.key==='r'&&!e.ctrlKey){const p=getRandomUnsolved();if(p){state.view='topic';state.topic=p.topicId;state.subView='problems';state.search=p.title;render();window.scrollTo(0,0);toast('Random: #'+p.num+' '+p.title);}}
  if(e.key==='d'&&!e.ctrlKey){state.view='decide';state.dtPath=[];render();window.scrollTo(0,0);}
  if(e.key==='f'&&!e.ctrlKey){state.view='formulas';state.formulaFilter='All';render();window.scrollTo(0,0);}
});

render();
</script>
<script src="constraints.js"></script>
</body>
</html>
